{"version":3,"sources":["../../../src/reporters/udp_sender.js"],"names":["HOST","PORT","UDP_PACKET_MAX_LENGTH","UDPSender","options","_host","host","_port","port","_maxPacketSize","maxPacketSize","_logger","logger","_client","createSocket","on","error","err","_agentThrift","entryPoint","join","__dirname","allowOptionalArguments","allowFilesystemAccess","_jaegerThrift","source","readFileSync","_totalSpanBytes","batch","Agent","emitBatch","argumentsMessageRW","byteLength","_convertBatchToThriftMessage","_batch","length","span","Span","rw","process","_process","spans","tagMessages","j","tags","tag","push","Tag","_thriftProcessMessage","Process","serviceName","_emitSpanBatchOverhead","_calcBatchSize","_maxSpanBytes","callback","numSpans","_calcSpanSize","_invokeCallback","spanSize","flush","bufferLen","thriftBuffer","Buffer","writeResult","writeInto","_reset","send","sent","offset","spanMessages","i","ArgumentsMessage","version","id","body","Batch","close"],"mappings":"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","file":"udp_sender.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport dgram from 'dgram';\nimport fs from 'fs';\nimport path from 'path';\nimport { Thrift } from 'thriftrw';\nimport NullLogger from '../logger.js';\n\nconst HOST = 'localhost';\nconst PORT = 6832;\nconst UDP_PACKET_MAX_LENGTH = 65000;\n\nexport default class UDPSender {\n  _host: string;\n  _port: number;\n  _maxPacketSize: number;\n  _process: Process;\n  _emitSpanBatchOverhead: number;\n  _logger: Logger;\n  _client: dgram$Socket;\n  _agentThrift: Thrift;\n  _jaegerThrift: Thrift;\n  _batch: Batch;\n  _thriftProcessMessage: any;\n  _maxSpanBytes: number; // maxPacketSize - (batch + tags overhead)\n  _totalSpanBytes: number; // size of currently batched spans as Thrift bytes\n\n  constructor(options: any = {}) {\n    this._host = options.host || HOST;\n    this._port = options.port || PORT;\n    this._maxPacketSize = options.maxPacketSize || UDP_PACKET_MAX_LENGTH;\n    this._logger = options.logger || new NullLogger();\n    this._client = dgram.createSocket('udp4');\n    this._client.on('error', err => {\n      this._logger.error(`error sending spans over UDP: ${err}`);\n    });\n    this._agentThrift = new Thrift({\n      entryPoint: path.join(__dirname, '../thriftrw-idl/agent.thrift'),\n      allowOptionalArguments: true,\n      allowFilesystemAccess: true,\n    });\n    this._jaegerThrift = new Thrift({\n      source: fs.readFileSync(path.join(__dirname, '../jaeger-idl/thrift/jaeger.thrift'), 'ascii'),\n      allowOptionalArguments: true,\n    });\n    this._totalSpanBytes = 0;\n  }\n\n  _calcBatchSize(batch: Batch) {\n    return this._agentThrift.Agent.emitBatch.argumentsMessageRW.byteLength(\n      this._convertBatchToThriftMessage(this._batch)\n    ).length;\n  }\n\n  _calcSpanSize(span: any): LengthResult {\n    return this._jaegerThrift.Span.rw.byteLength(new this._jaegerThrift.Span(span));\n  }\n\n  setProcess(process: Process): void {\n    // This function is only called once during reporter construction, and thus will\n    // give us the length of the batch before any spans have been added to the span\n    // list in batch.\n    this._process = process;\n    this._batch = {\n      process: this._process,\n      spans: [],\n    };\n\n    const tagMessages = [];\n    for (let j = 0; j < this._batch.process.tags.length; j++) {\n      const tag = this._batch.process.tags[j];\n      tagMessages.push(new this._jaegerThrift.Tag(tag));\n    }\n\n    this._thriftProcessMessage = new this._jaegerThrift.Process({\n      serviceName: this._batch.process.serviceName,\n      tags: tagMessages,\n    });\n    this._emitSpanBatchOverhead = this._calcBatchSize(this._batch);\n    this._maxSpanBytes = this._maxPacketSize - this._emitSpanBatchOverhead;\n  }\n\n  _invokeCallback(callback?: SenderCallback, numSpans: number, error?: string) {\n    if (callback) {\n      callback(numSpans, error);\n    }\n  }\n\n  append(span: any, callback?: SenderCallback): void {\n    const { err, length } = this._calcSpanSize(span);\n    if (err) {\n      this._invokeCallback(callback, 1, `error converting span to Thrift: ${err}`);\n      return;\n    }\n    const spanSize = length;\n    if (spanSize > this._maxSpanBytes) {\n      this._invokeCallback(\n        callback,\n        1,\n        `span size ${spanSize} is larger than maxSpanSize ${this._maxSpanBytes}`\n      );\n      return;\n    }\n\n    if (this._totalSpanBytes + spanSize <= this._maxSpanBytes) {\n      this._batch.spans.push(span);\n      this._totalSpanBytes += spanSize;\n      if (this._totalSpanBytes < this._maxSpanBytes) {\n        // still have space in the buffer, don't flush it yet\n        this._invokeCallback(callback, 0);\n        return;\n      }\n      // buffer size === this._maxSpanBytes\n      this.flush(callback);\n      return;\n    }\n\n    this.flush((numSpans: number, err?: string) => {\n      // TODO theoretically we can have buffer overflow here too, if many spans were appended during flush()\n      this._batch.spans.push(span);\n      this._totalSpanBytes += spanSize;\n      this._invokeCallback(callback, numSpans, err);\n    });\n  }\n\n  flush(callback?: SenderCallback): void {\n    const numSpans = this._batch.spans.length;\n    if (!numSpans) {\n      this._invokeCallback(callback, 0);\n      return;\n    }\n\n    const bufferLen = this._totalSpanBytes + this._emitSpanBatchOverhead;\n    const thriftBuffer = new Buffer(bufferLen);\n    const writeResult = this._agentThrift.Agent.emitBatch.argumentsMessageRW.writeInto(\n      this._convertBatchToThriftMessage(this._batch),\n      thriftBuffer,\n      0\n    );\n    this._reset();\n\n    if (writeResult.err) {\n      this._invokeCallback(callback, numSpans, `error writing Thrift object: ${writeResult.err}`);\n      return;\n    }\n\n    // Having the error callback here does not prevent uncaught exception from being thrown,\n    // that's why in the constructor we also add a general on('error') handler.\n    this._client.send(thriftBuffer, 0, thriftBuffer.length, this._port, this._host, (err, sent) => {\n      if (err) {\n        const error: string =\n          err &&\n          `error sending spans over UDP: ${err}, packet size: ${writeResult.offset}, bytes sent: ${sent}`;\n        this._invokeCallback(callback, numSpans, error);\n      } else {\n        this._invokeCallback(callback, numSpans);\n      }\n    });\n  }\n\n  _convertBatchToThriftMessage() {\n    const spanMessages = [];\n    for (let i = 0; i < this._batch.spans.length; i++) {\n      const span = this._batch.spans[i];\n      spanMessages.push(new this._jaegerThrift.Span(span));\n    }\n\n    return new this._agentThrift.Agent.emitBatch.ArgumentsMessage({\n      version: 1,\n      id: 0,\n      body: {\n        batch: new this._jaegerThrift.Batch({\n          process: this._thriftProcessMessage,\n          spans: spanMessages,\n        }),\n      },\n    });\n  }\n\n  _reset() {\n    this._batch.spans = [];\n    this._totalSpanBytes = 0;\n  }\n\n  close(): void {\n    this._client.close();\n  }\n}\n"]}