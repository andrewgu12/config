"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
    // Public: Attach to a {LanguageClientConnection} to receive edit events.
    static attach(connection) {
        connection.onApplyEdit((m) => ApplyEditAdapter.onApplyEdit(m));
    }
    static onApplyEdit(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let changes = params.edit.changes || {};
            if (params.edit.documentChanges) {
                changes = {};
                params.edit.documentChanges.forEach((change) => {
                    if (change && change.textDocument) {
                        changes[change.textDocument.uri] = change.edits;
                    }
                });
            }
            const uris = Object.keys(changes);
            const paths = uris.map(convert_1.default.uriToPath);
            const editors = yield Promise.all(paths.map((path) => {
                return atom.workspace.open(path, {
                    searchAllPanes: true,
                    // Open new editors in the background.
                    activatePane: false,
                    activateItem: false,
                });
            }));
            const checkpoints = [];
            try {
                for (let i = 0; i < editors.length; i++) {
                    const editor = editors[i];
                    const uri = uris[i];
                    // Get an existing editor for the file, or open a new one if it doesn't exist.
                    const edits = convert_1.default.convertLsTextEdits(changes[uri]);
                    // Sort edits in reverse order to prevent edit conflicts.
                    edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
                    const buffer = editor.getBuffer();
                    const checkpoint = buffer.createCheckpoint();
                    checkpoints.push({ buffer, checkpoint });
                    let prevEdit = null;
                    for (const edit of edits) {
                        ApplyEditAdapter.validateEdit(buffer, edit, prevEdit);
                        buffer.setTextInRange(edit.oldRange, edit.newText);
                        prevEdit = edit;
                    }
                    buffer.groupChangesSinceCheckpoint(checkpoint);
                }
                return { applied: true };
            }
            catch (e) {
                atom.notifications.addError('workspace/applyEdits failed', {
                    description: 'Failed to apply edits.',
                    detail: e.message,
                });
                checkpoints.forEach(({ buffer, checkpoint }) => {
                    buffer.revertToCheckpoint(checkpoint);
                });
                return { applied: false };
            }
        });
    }
    // Private: Do some basic sanity checking on the edit ranges.
    static validateEdit(buffer, edit, prevEdit) {
        const path = buffer.getPath() || '';
        if (prevEdit && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
            throw Error(`Found overlapping edit ranges in ${path}`);
        }
        const startRow = edit.oldRange.start.row;
        const startCol = edit.oldRange.start.column;
        const lineLength = buffer.lineLengthForRow(startRow);
        if (lineLength == null || startCol > lineLength) {
            throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
        }
    }
}
exports.default = ApplyEditAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBT0Esd0NBQWlDO0FBRWpDLDBEQUEwRDtBQUMxRDtJQUNFLHlFQUF5RTtJQUNsRSxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQW9DO1FBQ3ZELFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFTSxNQUFNLENBQU8sV0FBVyxDQUFDLE1BQWdDOztZQUU5RCxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFFeEMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO2dCQUNoQyxPQUFPLEdBQUcsRUFBRSxDQUFDO2dCQUNiLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO29CQUM3QyxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7d0JBQ2xDLE9BQU8sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7b0JBQ2xELENBQUM7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1lBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDMUMsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUMvQixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7Z0JBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQy9CLGNBQWMsRUFBRSxJQUFJO29CQUNwQixzQ0FBc0M7b0JBQ3RDLFlBQVksRUFBRSxLQUFLO29CQUNuQixZQUFZLEVBQUUsS0FBSztpQkFDcEIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUVGLE1BQU0sV0FBVyxHQUFxRCxFQUFFLENBQUM7WUFDekUsSUFBSSxDQUFDO2dCQUNILEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUN4QyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFlLENBQUM7b0JBQ3hDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDcEIsOEVBQThFO29CQUM5RSxNQUFNLEtBQUssR0FBRyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUN2RCx5REFBeUQ7b0JBQ3pELEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO29CQUN0RSxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQ2xDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO29CQUM3QyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBQyxDQUFDLENBQUM7b0JBQ3ZDLElBQUksUUFBUSxHQUE0QixJQUFJLENBQUM7b0JBQzdDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7d0JBQ3pCLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUN0RCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUNuRCxRQUFRLEdBQUcsSUFBSSxDQUFDO29CQUNsQixDQUFDO29CQUNELE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDakQsQ0FBQztnQkFDRCxNQUFNLENBQUMsRUFBQyxPQUFPLEVBQUUsSUFBSSxFQUFDLENBQUM7WUFDekIsQ0FBQztZQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsNkJBQTZCLEVBQUU7b0JBQ3pELFdBQVcsRUFBRSx3QkFBd0I7b0JBQ3JDLE1BQU0sRUFBRSxDQUFDLENBQUMsT0FBTztpQkFDbEIsQ0FBQyxDQUFDO2dCQUNILFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUMsRUFBRSxFQUFFO29CQUMzQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3hDLENBQUMsQ0FBQyxDQUFDO2dCQUNILE1BQU0sQ0FBQyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUMsQ0FBQztZQUMxQixDQUFDO1FBQ0gsQ0FBQztLQUFBO0lBRUQsNkRBQTZEO0lBQ3JELE1BQU0sQ0FBQyxZQUFZLENBQ3pCLE1BQWtCLEVBQ2xCLElBQXNCLEVBQ3RCLFFBQWlDO1FBRWpDLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDcEMsRUFBRSxDQUFDLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkUsTUFBTSxLQUFLLENBQUMsb0NBQW9DLElBQUksRUFBRSxDQUFDLENBQUM7UUFDMUQsQ0FBQztRQUNELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUN6QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDNUMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JELEVBQUUsQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLElBQUksUUFBUSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDaEQsTUFBTSxLQUFLLENBQUMsd0JBQXdCLElBQUksSUFBSSxRQUFRLEdBQUcsQ0FBQyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzlFLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUFsRkQsbUNBa0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgQXBwbHlXb3Jrc3BhY2VFZGl0UGFyYW1zLFxyXG4gIEFwcGx5V29ya3NwYWNlRWRpdFJlc3BvbnNlLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IHsgVGV4dEJ1ZmZlciwgVGV4dEVkaXRvciB9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB3b3Jrc3BhY2UvYXBwbHlFZGl0IGNvbW1hbmRzIHRvIGVkaXRvcnMuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcGx5RWRpdEFkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogQXR0YWNoIHRvIGEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gcmVjZWl2ZSBlZGl0IGV2ZW50cy5cclxuICBwdWJsaWMgc3RhdGljIGF0dGFjaChjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24pIHtcclxuICAgIGNvbm5lY3Rpb24ub25BcHBseUVkaXQoKG0pID0+IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQobSkpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBvbkFwcGx5RWRpdChwYXJhbXM6IEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyk6IFByb21pc2U8QXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2U+IHtcclxuXHJcbiAgICBsZXQgY2hhbmdlcyA9IHBhcmFtcy5lZGl0LmNoYW5nZXMgfHwge307XHJcblxyXG4gICAgaWYgKHBhcmFtcy5lZGl0LmRvY3VtZW50Q2hhbmdlcykge1xyXG4gICAgICBjaGFuZ2VzID0ge307XHJcbiAgICAgIHBhcmFtcy5lZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcclxuICAgICAgICBpZiAoY2hhbmdlICYmIGNoYW5nZS50ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICAgIGNoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gY2hhbmdlLmVkaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXJpcyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xyXG4gICAgY29uc3QgcGF0aHMgPSB1cmlzLm1hcChDb252ZXJ0LnVyaVRvUGF0aCk7XHJcbiAgICBjb25zdCBlZGl0b3JzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIHBhdGhzLm1hcCgocGF0aCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBhdG9tLndvcmtzcGFjZS5vcGVuKHBhdGgsIHtcclxuICAgICAgICAgIHNlYXJjaEFsbFBhbmVzOiB0cnVlLFxyXG4gICAgICAgICAgLy8gT3BlbiBuZXcgZWRpdG9ycyBpbiB0aGUgYmFja2dyb3VuZC5cclxuICAgICAgICAgIGFjdGl2YXRlUGFuZTogZmFsc2UsXHJcbiAgICAgICAgICBhY3RpdmF0ZUl0ZW06IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY2hlY2twb2ludHM6IEFycmF5PHsgYnVmZmVyOiBUZXh0QnVmZmVyLCBjaGVja3BvaW50OiBudW1iZXJ9PiA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gZWRpdG9yc1tpXSBhcyBUZXh0RWRpdG9yO1xyXG4gICAgICAgIGNvbnN0IHVyaSA9IHVyaXNbaV07XHJcbiAgICAgICAgLy8gR2V0IGFuIGV4aXN0aW5nIGVkaXRvciBmb3IgdGhlIGZpbGUsIG9yIG9wZW4gYSBuZXcgb25lIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgICAgY29uc3QgZWRpdHMgPSBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhjaGFuZ2VzW3VyaV0pO1xyXG4gICAgICAgIC8vIFNvcnQgZWRpdHMgaW4gcmV2ZXJzZSBvcmRlciB0byBwcmV2ZW50IGVkaXQgY29uZmxpY3RzLlxyXG4gICAgICAgIGVkaXRzLnNvcnQoKGVkaXQxLCBlZGl0MikgPT4gLWVkaXQxLm9sZFJhbmdlLmNvbXBhcmUoZWRpdDIub2xkUmFuZ2UpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XHJcbiAgICAgICAgY29uc3QgY2hlY2twb2ludCA9IGJ1ZmZlci5jcmVhdGVDaGVja3BvaW50KCk7XHJcbiAgICAgICAgY2hlY2twb2ludHMucHVzaCh7YnVmZmVyLCBjaGVja3BvaW50fSk7XHJcbiAgICAgICAgbGV0IHByZXZFZGl0OiBhdG9tSWRlLlRleHRFZGl0IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBlZGl0IG9mIGVkaXRzKSB7XHJcbiAgICAgICAgICBBcHBseUVkaXRBZGFwdGVyLnZhbGlkYXRlRWRpdChidWZmZXIsIGVkaXQsIHByZXZFZGl0KTtcclxuICAgICAgICAgIGJ1ZmZlci5zZXRUZXh0SW5SYW5nZShlZGl0Lm9sZFJhbmdlLCBlZGl0Lm5ld1RleHQpO1xyXG4gICAgICAgICAgcHJldkVkaXQgPSBlZGl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIuZ3JvdXBDaGFuZ2VzU2luY2VDaGVja3BvaW50KGNoZWNrcG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7YXBwbGllZDogdHJ1ZX07XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcignd29ya3NwYWNlL2FwcGx5RWRpdHMgZmFpbGVkJywge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRmFpbGVkIHRvIGFwcGx5IGVkaXRzLicsXHJcbiAgICAgICAgZGV0YWlsOiBlLm1lc3NhZ2UsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjaGVja3BvaW50cy5mb3JFYWNoKCh7YnVmZmVyLCBjaGVja3BvaW50fSkgPT4ge1xyXG4gICAgICAgIGJ1ZmZlci5yZXZlcnRUb0NoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge2FwcGxpZWQ6IGZhbHNlfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGU6IERvIHNvbWUgYmFzaWMgc2FuaXR5IGNoZWNraW5nIG9uIHRoZSBlZGl0IHJhbmdlcy5cclxuICBwcml2YXRlIHN0YXRpYyB2YWxpZGF0ZUVkaXQoXHJcbiAgICBidWZmZXI6IFRleHRCdWZmZXIsXHJcbiAgICBlZGl0OiBhdG9tSWRlLlRleHRFZGl0LFxyXG4gICAgcHJldkVkaXQ6IGF0b21JZGUuVGV4dEVkaXQgfCBudWxsLFxyXG4gICk6IHZvaWQge1xyXG4gICAgY29uc3QgcGF0aCA9IGJ1ZmZlci5nZXRQYXRoKCkgfHwgJyc7XHJcbiAgICBpZiAocHJldkVkaXQgJiYgZWRpdC5vbGRSYW5nZS5lbmQuY29tcGFyZShwcmV2RWRpdC5vbGRSYW5nZS5zdGFydCkgPiAwKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGBGb3VuZCBvdmVybGFwcGluZyBlZGl0IHJhbmdlcyBpbiAke3BhdGh9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydFJvdyA9IGVkaXQub2xkUmFuZ2Uuc3RhcnQucm93O1xyXG4gICAgY29uc3Qgc3RhcnRDb2wgPSBlZGl0Lm9sZFJhbmdlLnN0YXJ0LmNvbHVtbjtcclxuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBidWZmZXIubGluZUxlbmd0aEZvclJvdyhzdGFydFJvdyk7XHJcbiAgICBpZiAobGluZUxlbmd0aCA9PSBudWxsIHx8IHN0YXJ0Q29sID4gbGluZUxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihgT3V0IG9mIHJhbmdlIGVkaXQgb24gJHtwYXRofToke3N0YXJ0Um93ICsgMX06JHtzdGFydENvbCArIDF9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==