"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const utils_1 = require("../utils");
const atom_1 = require("atom");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class DefinitionAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a definitionProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.definitionProvider === true;
    }
    // Public: Get the definitions for a symbol at a given {Point} within a
    // {TextEditor} including optionally highlighting all other references
    // within the document if the langauge server also supports highlighting.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `languageName` The name of the programming language.
    // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
    // * `point` The Atom {Point} containing the position of the text that represents the symbol
    //           for which the definition and highlights should be provided.
    //
    // Returns a {Promise} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    getDefinition(connection, serverCapabilities, languageName, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const definitionLocations = DefinitionAdapter.normalizeLocations(yield connection.gotoDefinition(documentPositionParams));
            if (definitionLocations == null || definitionLocations.length === 0) {
                return null;
            }
            let queryRange;
            if (serverCapabilities.documentHighlightProvider) {
                const highlights = yield connection.documentHighlight(documentPositionParams);
                if (highlights != null && highlights.length > 0) {
                    queryRange = highlights.map((h) => convert_1.default.lsRangeToAtomRange(h.range));
                }
            }
            return {
                queryRange: queryRange || [utils_1.default.getWordAtPosition(editor, point)],
                definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName),
            };
        });
    }
    // Public: Normalize the locations so a single {Location} becomes an {Array} of just
    // one. The language server protocol return either as the protocol evolved between v1 and v2.
    //
    // * `locationResult` either a single {Location} object or an {Array} of {Locations}
    //
    // Returns an {Array} of {Location}s or {null} if the locationResult was null.
    static normalizeLocations(locationResult) {
        if (locationResult == null) {
            return null;
        }
        return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter((d) => d.range.start != null);
    }
    // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
    //
    // * `locations` An {Array} of {Location} objects to be converted.
    // * `languageName` The name of the language these objects are written in.
    //
    // Returns an {Array} of {Definition}s that represented the converted {Location}s.
    static convertLocationsToDefinitions(locations, languageName) {
        return locations.map((d) => ({
            path: convert_1.default.uriToPath(d.uri),
            position: convert_1.default.positionToPoint(d.range.start),
            range: atom_1.Range.fromObject(convert_1.default.lsRangeToAtomRange(d.range)),
            language: languageName,
        }));
    }
}
exports.default = DefinitionAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RlZmluaXRpb24tYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBQ2pDLG9DQUE2QjtBQUM3QiwrQkFBZ0Q7QUFHaEQsZ0VBQWdFO0FBQ2hFLHdFQUF3RTtBQUN4RTtJQUNFLGdGQUFnRjtJQUNoRiwwRUFBMEU7SUFDMUUsRUFBRTtJQUNGLHNGQUFzRjtJQUN0RixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDRCQUE0QjtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxNQUFNLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDO0lBQ3hELENBQUM7SUFFRCx1RUFBdUU7SUFDdkUsc0VBQXNFO0lBQ3RFLHlFQUF5RTtJQUN6RSxFQUFFO0lBQ0YsbUhBQW1IO0lBQ25ILDRGQUE0RjtJQUM1Rix5REFBeUQ7SUFDekQsbUZBQW1GO0lBQ25GLDRGQUE0RjtJQUM1Rix3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDZixhQUFhLENBQ3hCLFVBQW9DLEVBQ3BDLGtCQUFzQyxFQUN0QyxZQUFvQixFQUNwQixNQUFrQixFQUNsQixLQUFZOztZQUVaLE1BQU0sc0JBQXNCLEdBQUcsaUJBQU8sQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekYsTUFBTSxtQkFBbUIsR0FBRyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FDOUQsTUFBTSxVQUFVLENBQUMsY0FBYyxDQUFDLHNCQUFzQixDQUFDLENBQ3hELENBQUM7WUFDRixFQUFFLENBQUMsQ0FBQyxtQkFBbUIsSUFBSSxJQUFJLElBQUksbUJBQW1CLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BFLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDZCxDQUFDO1lBRUQsSUFBSSxVQUFVLENBQUM7WUFDZixFQUFFLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pELE1BQU0sVUFBVSxHQUFHLE1BQU0sVUFBVSxDQUFDLGlCQUFpQixDQUFDLHNCQUFzQixDQUFDLENBQUM7Z0JBQzlFLEVBQUUsQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLElBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNoRCxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDMUUsQ0FBQztZQUNILENBQUM7WUFFRCxNQUFNLENBQUM7Z0JBQ0wsVUFBVSxFQUFFLFVBQVUsSUFBSSxDQUFDLGVBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2xFLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyw2QkFBNkIsQ0FBQyxtQkFBbUIsRUFBRSxZQUFZLENBQUM7YUFDaEcsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVELG9GQUFvRjtJQUNwRiw2RkFBNkY7SUFDN0YsRUFBRTtJQUNGLG9GQUFvRjtJQUNwRixFQUFFO0lBQ0YsOEVBQThFO0lBQ3ZFLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxjQUFxQztRQUNwRSxFQUFFLENBQUMsQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUM7SUFDbEgsQ0FBQztJQUVELG1GQUFtRjtJQUNuRixFQUFFO0lBQ0Ysa0VBQWtFO0lBQ2xFLDBFQUEwRTtJQUMxRSxFQUFFO0lBQ0Ysa0ZBQWtGO0lBQzNFLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxTQUFxQixFQUFFLFlBQW9CO1FBQ3JGLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzNCLElBQUksRUFBRSxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQzlCLFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNoRCxLQUFLLEVBQUUsWUFBSyxDQUFDLFVBQVUsQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1RCxRQUFRLEVBQUUsWUFBWTtTQUN2QixDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Q0FDRjtBQWpGRCxvQ0FpRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIExvY2F0aW9uLCBTZXJ2ZXJDYXBhYmlsaXRpZXMgfSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBQb2ludCwgVGV4dEVkaXRvciwgUmFuZ2UgfSBmcm9tICdhdG9tJztcclxuaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZGVmaW5pdGlvblByb3ZpZGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmRlZmluaXRpb25Qcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogR2V0IHRoZSBkZWZpbml0aW9ucyBmb3IgYSBzeW1ib2wgYXQgYSBnaXZlbiB7UG9pbnR9IHdpdGhpbiBhXHJcbiAgLy8ge1RleHRFZGl0b3J9IGluY2x1ZGluZyBvcHRpb25hbGx5IGhpZ2hsaWdodGluZyBhbGwgb3RoZXIgcmVmZXJlbmNlc1xyXG4gIC8vIHdpdGhpbiB0aGUgZG9jdW1lbnQgaWYgdGhlIGxhbmdhdWdlIHNlcnZlciBhbHNvIHN1cHBvcnRzIGhpZ2hsaWdodGluZy5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgaGlnaGxpZ2h0cy5cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSB1c2VkLlxyXG4gIC8vICogYGxhbmd1YWdlTmFtZWAgVGhlIG5hbWUgb2YgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHN5bWJvbCBhbmQgcG90ZW50aWFsIGhpZ2hsaWdodHMuXHJcbiAgLy8gKiBgcG9pbnRgIFRoZSBBdG9tIHtQb2ludH0gY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHRleHQgdGhhdCByZXByZXNlbnRzIHRoZSBzeW1ib2xcclxuICAvLyAgICAgICAgICAgZm9yIHdoaWNoIHRoZSBkZWZpbml0aW9uIGFuZCBoaWdobGlnaHRzIHNob3VsZCBiZSBwcm92aWRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBwdWJsaWMgYXN5bmMgZ2V0RGVmaW5pdGlvbihcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG4gICAgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcsXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogUG9pbnQsXHJcbiAgKTogUHJvbWlzZTxhdG9tSWRlLkRlZmluaXRpb25RdWVyeVJlc3VsdCB8IG51bGw+IHtcclxuICAgIGNvbnN0IGRvY3VtZW50UG9zaXRpb25QYXJhbXMgPSBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yLCBwb2ludCk7XHJcbiAgICBjb25zdCBkZWZpbml0aW9uTG9jYXRpb25zID0gRGVmaW5pdGlvbkFkYXB0ZXIubm9ybWFsaXplTG9jYXRpb25zKFxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmdvdG9EZWZpbml0aW9uKGRvY3VtZW50UG9zaXRpb25QYXJhbXMpLFxyXG4gICAgKTtcclxuICAgIGlmIChkZWZpbml0aW9uTG9jYXRpb25zID09IG51bGwgfHwgZGVmaW5pdGlvbkxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHF1ZXJ5UmFuZ2U7XHJcbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIpIHtcclxuICAgICAgY29uc3QgaGlnaGxpZ2h0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRIaWdobGlnaHQoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XHJcbiAgICAgIGlmIChoaWdobGlnaHRzICE9IG51bGwgJiYgaGlnaGxpZ2h0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcXVlcnlSYW5nZSA9IGhpZ2hsaWdodHMubWFwKChoKSA9PiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShoLnJhbmdlKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWVyeVJhbmdlOiBxdWVyeVJhbmdlIHx8IFtVdGlscy5nZXRXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KV0sXHJcbiAgICAgIGRlZmluaXRpb25zOiBEZWZpbml0aW9uQWRhcHRlci5jb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhkZWZpbml0aW9uTG9jYXRpb25zLCBsYW5ndWFnZU5hbWUpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogTm9ybWFsaXplIHRoZSBsb2NhdGlvbnMgc28gYSBzaW5nbGUge0xvY2F0aW9ufSBiZWNvbWVzIGFuIHtBcnJheX0gb2YganVzdFxyXG4gIC8vIG9uZS4gVGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCByZXR1cm4gZWl0aGVyIGFzIHRoZSBwcm90b2NvbCBldm9sdmVkIGJldHdlZW4gdjEgYW5kIHYyLlxyXG4gIC8vXHJcbiAgLy8gKiBgbG9jYXRpb25SZXN1bHRgIGVpdGhlciBhIHNpbmdsZSB7TG9jYXRpb259IG9iamVjdCBvciBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbnN9XHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufXMgb3Ige251bGx9IGlmIHRoZSBsb2NhdGlvblJlc3VsdCB3YXMgbnVsbC5cclxuICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZUxvY2F0aW9ucyhsb2NhdGlvblJlc3VsdDogTG9jYXRpb24gfCBMb2NhdGlvbltdKTogTG9jYXRpb25bXSB8IG51bGwge1xyXG4gICAgaWYgKGxvY2F0aW9uUmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobG9jYXRpb25SZXN1bHQpID8gbG9jYXRpb25SZXN1bHQgOiBbbG9jYXRpb25SZXN1bHRdKS5maWx0ZXIoKGQpID0+IGQucmFuZ2Uuc3RhcnQgIT0gbnVsbCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgaW50byBhbiBBcnJheSBvZiB7RGVmaW5pdGlvbn1zLlxyXG4gIC8vXHJcbiAgLy8gKiBgbG9jYXRpb25zYCBBbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn0gb2JqZWN0cyB0byBiZSBjb252ZXJ0ZWQuXHJcbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgdGhlc2Ugb2JqZWN0cyBhcmUgd3JpdHRlbiBpbi5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYW4ge0FycmF5fSBvZiB7RGVmaW5pdGlvbn1zIHRoYXQgcmVwcmVzZW50ZWQgdGhlIGNvbnZlcnRlZCB7TG9jYXRpb259cy5cclxuICBwdWJsaWMgc3RhdGljIGNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zKGxvY2F0aW9uczogTG9jYXRpb25bXSwgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcpOiBhdG9tSWRlLkRlZmluaXRpb25bXSB7XHJcbiAgICByZXR1cm4gbG9jYXRpb25zLm1hcCgoZCkgPT4gKHtcclxuICAgICAgcGF0aDogQ29udmVydC51cmlUb1BhdGgoZC51cmkpLFxyXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoZC5yYW5nZS5zdGFydCksXHJcbiAgICAgIHJhbmdlOiBSYW5nZS5mcm9tT2JqZWN0KENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGQucmFuZ2UpKSxcclxuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcclxuICAgIH0pKTtcclxuICB9XHJcbn1cclxuIl19