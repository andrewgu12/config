"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
class Utils {
    /**
     * Obtain the range of the word at the given editor position.
     * Uses the non-word characters from the position's grammar scope.
     */
    static getWordAtPosition(editor, position) {
        const scopeDescriptor = editor.scopeDescriptorForBufferPosition(position);
        const nonWordCharacters = Utils.escapeRegExp(editor.getNonWordCharacters(scopeDescriptor));
        const range = Utils._getRegexpRangeAtPosition(editor.getBuffer(), position, new RegExp(`^[\t ]*$|[^\\s${nonWordCharacters}]+`, 'g'));
        if (range == null) {
            return new atom_1.Range(position, position);
        }
        return range;
    }
    static escapeRegExp(string) {
        // From atom/underscore-plus.
        return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    static _getRegexpRangeAtPosition(buffer, position, wordRegex) {
        const { row, column } = position;
        const rowRange = buffer.rangeForRow(row, false);
        let matchData;
        // Extract the expression from the row text.
        buffer.scanInRange(wordRegex, rowRange, (data) => {
            const { range } = data;
            if (position.isGreaterThanOrEqual(range.start) &&
                // Range endpoints are exclusive.
                position.isLessThan(range.end)) {
                matchData = data;
                data.stop();
                return;
            }
            // Stop the scan if the scanner has passed our position.
            if (range.end.column > column) {
                data.stop();
            }
        });
        return matchData == null ? null : matchData.range;
    }
    /**
     * For the given connection and cancellationTokens map, cancel the existing
     * CancellationToken for that connection then create and store a new
     * CancellationToken to be used for the current request.
     */
    static cancelAndRefreshCancellationToken(key, cancellationTokens) {
        let cancellationToken = cancellationTokens.get(key);
        if (cancellationToken !== undefined && !cancellationToken.token.isCancellationRequested) {
            cancellationToken.cancel();
        }
        cancellationToken = new vscode_jsonrpc_1.CancellationTokenSource();
        cancellationTokens.set(key, cancellationToken);
        return cancellationToken.token;
    }
    static doWithCancellationToken(key, cancellationTokens, work) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = Utils.cancelAndRefreshCancellationToken(key, cancellationTokens);
            const result = yield work(token);
            cancellationTokens.delete(key);
            return result;
        });
    }
    static assertUnreachable(_) {
        return _;
    }
}
exports.default = Utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLCtCQUE4RTtBQUM5RSxtREFBNEU7QUFFNUU7SUFDRTs7O09BR0c7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsTUFBa0IsRUFBRSxRQUFlO1FBQ2pFLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMxRSxNQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFDM0YsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLHlCQUF5QixDQUMzQyxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQ2xCLFFBQVEsRUFDUixJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsaUJBQWlCLElBQUksRUFBRSxHQUFHLENBQUMsQ0FDeEQsQ0FBQztRQUNGLEVBQUUsQ0FBQyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sQ0FBQyxJQUFJLFlBQUssQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUNELE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU0sTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFjO1FBQ3ZDLDZCQUE2QjtRQUM3QixNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRU8sTUFBTSxDQUFDLHlCQUF5QixDQUFDLE1BQWtCLEVBQUUsUUFBZSxFQUFFLFNBQWlCO1FBQzdGLE1BQU0sRUFBQyxHQUFHLEVBQUUsTUFBTSxFQUFDLEdBQUcsUUFBUSxDQUFDO1FBQy9CLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQUksU0FBOEMsQ0FBQztRQUNuRCw0Q0FBNEM7UUFDNUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDL0MsTUFBTSxFQUFDLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztZQUNyQixFQUFFLENBQUMsQ0FDRCxRQUFRLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztnQkFDMUMsaUNBQWlDO2dCQUNqQyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQy9CLENBQUMsQ0FBQyxDQUFDO2dCQUNELFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDWixNQUFNLENBQUM7WUFDVCxDQUFDO1lBQ0Qsd0RBQXdEO1lBQ3hELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNkLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsaUNBQWlDLENBQzdDLEdBQU0sRUFDTixrQkFBdUQ7UUFFdkQsSUFBSSxpQkFBaUIsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDcEQsRUFBRSxDQUFDLENBQUMsaUJBQWlCLEtBQUssU0FBUyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQztZQUN4RixpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM3QixDQUFDO1FBRUQsaUJBQWlCLEdBQUcsSUFBSSx3Q0FBdUIsRUFBRSxDQUFDO1FBQ2xELGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUMvQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDO0lBQ2pDLENBQUM7SUFFTSxNQUFNLENBQU8sdUJBQXVCLENBQ3pDLEdBQU8sRUFDUCxrQkFBd0QsRUFDeEQsSUFBK0M7O1lBRS9DLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxHQUFHLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztZQUMvRSxNQUFNLE1BQU0sR0FBTyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0IsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNoQixDQUFDO0tBQUE7SUFFTSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBUTtRQUN0QyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztDQUNGO0FBakZELHdCQWlGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50LCBUZXh0QnVmZmVyLCBUZXh0RWRpdG9yLCBSYW5nZSwgQnVmZmVyU2NhblJlc3VsdCB9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgfSBmcm9tICd2c2NvZGUtanNvbnJwYyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVdGlscyB7XHJcbiAgLyoqXHJcbiAgICogT2J0YWluIHRoZSByYW5nZSBvZiB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gZWRpdG9yIHBvc2l0aW9uLlxyXG4gICAqIFVzZXMgdGhlIG5vbi13b3JkIGNoYXJhY3RlcnMgZnJvbSB0aGUgcG9zaXRpb24ncyBncmFtbWFyIHNjb3BlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yOiBUZXh0RWRpdG9yLCBwb3NpdGlvbjogUG9pbnQpOiBSYW5nZSB7XHJcbiAgICBjb25zdCBzY29wZURlc2NyaXB0b3IgPSBlZGl0b3Iuc2NvcGVEZXNjcmlwdG9yRm9yQnVmZmVyUG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgY29uc3Qgbm9uV29yZENoYXJhY3RlcnMgPSBVdGlscy5lc2NhcGVSZWdFeHAoZWRpdG9yLmdldE5vbldvcmRDaGFyYWN0ZXJzKHNjb3BlRGVzY3JpcHRvcikpO1xyXG4gICAgY29uc3QgcmFuZ2UgPSBVdGlscy5fZ2V0UmVnZXhwUmFuZ2VBdFBvc2l0aW9uKFxyXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCksXHJcbiAgICAgIHBvc2l0aW9uLFxyXG4gICAgICBuZXcgUmVnRXhwKGBeW1xcdCBdKiR8W15cXFxccyR7bm9uV29yZENoYXJhY3RlcnN9XStgLCAnZycpLFxyXG4gICAgKTtcclxuICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiByYW5nZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgZXNjYXBlUmVnRXhwKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIEZyb20gYXRvbS91bmRlcnNjb3JlLXBsdXMuXHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIF9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24oYnVmZmVyOiBUZXh0QnVmZmVyLCBwb3NpdGlvbjogUG9pbnQsIHdvcmRSZWdleDogUmVnRXhwKTogUmFuZ2UgfCBudWxsIHtcclxuICAgIGNvbnN0IHtyb3csIGNvbHVtbn0gPSBwb3NpdGlvbjtcclxuICAgIGNvbnN0IHJvd1JhbmdlID0gYnVmZmVyLnJhbmdlRm9yUm93KHJvdywgZmFsc2UpO1xyXG4gICAgbGV0IG1hdGNoRGF0YTogQnVmZmVyU2NhblJlc3VsdCB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxyXG4gICAgYnVmZmVyLnNjYW5JblJhbmdlKHdvcmRSZWdleCwgcm93UmFuZ2UsIChkYXRhKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtyYW5nZX0gPSBkYXRhO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcG9zaXRpb24uaXNHcmVhdGVyVGhhbk9yRXF1YWwocmFuZ2Uuc3RhcnQpICYmXHJcbiAgICAgICAgLy8gUmFuZ2UgZW5kcG9pbnRzIGFyZSBleGNsdXNpdmUuXHJcbiAgICAgICAgcG9zaXRpb24uaXNMZXNzVGhhbihyYW5nZS5lbmQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIG1hdGNoRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgZGF0YS5zdG9wKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFN0b3AgdGhlIHNjYW4gaWYgdGhlIHNjYW5uZXIgaGFzIHBhc3NlZCBvdXIgcG9zaXRpb24uXHJcbiAgICAgIGlmIChyYW5nZS5lbmQuY29sdW1uID4gY29sdW1uKSB7XHJcbiAgICAgICAgZGF0YS5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1hdGNoRGF0YSA9PSBudWxsID8gbnVsbCA6IG1hdGNoRGF0YS5yYW5nZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvciB0aGUgZ2l2ZW4gY29ubmVjdGlvbiBhbmQgY2FuY2VsbGF0aW9uVG9rZW5zIG1hcCwgY2FuY2VsIHRoZSBleGlzdGluZ1xyXG4gICAqIENhbmNlbGxhdGlvblRva2VuIGZvciB0aGF0IGNvbm5lY3Rpb24gdGhlbiBjcmVhdGUgYW5kIHN0b3JlIGEgbmV3XHJcbiAgICogQ2FuY2VsbGF0aW9uVG9rZW4gdG8gYmUgdXNlZCBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGNhbmNlbEFuZFJlZnJlc2hDYW5jZWxsYXRpb25Ub2tlbjxUIGV4dGVuZHMgb2JqZWN0PihcclxuICAgIGtleTogVCxcclxuICAgIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxULCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4pOiBDYW5jZWxsYXRpb25Ub2tlbiB7XHJcblxyXG4gICAgbGV0IGNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW5zLmdldChrZXkpO1xyXG4gICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQgJiYgIWNhbmNlbGxhdGlvblRva2VuLnRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XHJcbiAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbGxhdGlvblRva2VuID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XHJcbiAgICBjYW5jZWxsYXRpb25Ub2tlbnMuc2V0KGtleSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xyXG4gICAgcmV0dXJuIGNhbmNlbGxhdGlvblRva2VuLnRva2VuO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBkb1dpdGhDYW5jZWxsYXRpb25Ub2tlbjxUMSBleHRlbmRzIG9iamVjdCwgVDI+KFxyXG4gICAga2V5OiBUMSxcclxuICAgIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxUMSwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+LFxyXG4gICAgd29yazogKHRva2VuOiBDYW5jZWxsYXRpb25Ub2tlbikgPT4gUHJvbWlzZTxUMj4sXHJcbiAgKTogUHJvbWlzZTxUMj4ge1xyXG4gICAgY29uc3QgdG9rZW4gPSBVdGlscy5jYW5jZWxBbmRSZWZyZXNoQ2FuY2VsbGF0aW9uVG9rZW4oa2V5LCBjYW5jZWxsYXRpb25Ub2tlbnMpO1xyXG4gICAgY29uc3QgcmVzdWx0OiBUMiA9IGF3YWl0IHdvcmsodG9rZW4pO1xyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW5zLmRlbGV0ZShrZXkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgYXNzZXJ0VW5yZWFjaGFibGUoXzogbmV2ZXIpOiBuZXZlciB7XHJcbiAgICByZXR1cm4gXztcclxuICB9XHJcbn1cclxuIl19