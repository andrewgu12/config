"use strict";
var extend = require('xtend');
var escape = require('escape-string-regexp');
var repeat = require('repeat-string');
exports.DEFAULT_OPTIONS = {
    leftSeparators: [':'],
    rightSeparators: ['=', '+=', '-=', '*=', '/=', '?=', '|=', '%=', '.=', '=>'],
    spaceSeparators: ['=', '+=', '-=', '*=', '/=', '?=', '|=', '%=', '.=', '=>'],
    ignoreSeparators: ['::']
};
/**
 * Check for empty values.
 */
function isEmpty(value) {
    return !!value;
}
/**
 * Function to sort two strings by string length.
 */
function sortLength(a, b) {
    return b.length - a.length;
}
/**
 * Align a block of code.
 */
function block(text, options) {
    var _a = extend(exports.DEFAULT_OPTIONS, options), leftSeparators = _a.leftSeparators, rightSeparators = _a.rightSeparators, ignoreSeparators = _a.ignoreSeparators, spaceSeparators = _a.spaceSeparators;
    var separators = leftSeparators.concat(rightSeparators).concat(ignoreSeparators).filter(isEmpty).sort(sortLength).map(escape);
    if (!separators.length) {
        return [text, []];
    }
    var separatorRegExp = new RegExp('^(?:' + [
        '\\\\.',
        '"(?:\\\\.|[^"])*?"',
        '\'(?:\\\\.|[^\'])*?\'',
        '[^\'"]'
    ].join('|') + ')*?' +
        '(' + separators.join('|') + ')');
    function alignText(text) {
        var lines = text.split('\n');
        var matches = 0;
        function findSeparator(line, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            var match = line.substr(startIndex).match(separatorRegExp);
            if (!match) {
                return;
            }
            var pre = match[0], separator = match[1];
            var length = pre.length;
            // If the match is an ignore separator, move along the line.
            if (ignoreSeparators.indexOf(separator) > -1) {
                return findSeparator(line, length);
            }
            matches += 1;
            return [
                line.substr(0, startIndex + length - separator.length).replace(/ +$/, ''),
                separator,
                line.substr(startIndex + length).replace(/^ +/, '')
            ];
        }
        // Split each line into the left context, separator and right content.
        var parts = lines.map(function (line) { return findSeparator(line); });
        // Return early if there aren't enough matches to align.
        if (!matches) {
            return [text, []];
        }
        // Using recursion, align the parts to the right again.
        var rightParts = alignText(parts.map(function (part) { return part ? part[2] : ''; }).join('\n'));
        // Get the text of the right parts.
        var rightLines = rightParts[0].split('\n');
        // Iterate over the parts and find the longest left length string.
        var leftLength = parts.reduce(function (prev, part) {
            if (!part) {
                return prev;
            }
            var pre = part[0], separator = part[1];
            var length = pre.length + separator.length;
            if (spaceSeparators.indexOf(separator) > -1) {
                length += 1;
            }
            return length > prev ? length : prev;
        }, 0);
        // An array of insertion positions.
        var positions = [];
        // Map the parts into their sanitized pieces with whitespace padding.
        var result = parts.map(function (part, index) {
            if (!part) {
                return lines[index];
            }
            var line = part[0], separator = part[1];
            var spaces = leftLength - line.length;
            var position = 0;
            if (spaceSeparators.indexOf(separator) > -1) {
                line += ' ';
                spaces -= 1;
            }
            var padding = repeat(' ', spaces - separator.length);
            if (leftSeparators.indexOf(separator) > -1) {
                positions.push([index, line.length]);
                line += separator + padding;
            }
            else {
                line += padding + separator;
                positions.push([index, line.length - separator.length]);
            }
            if (rightParts[1][index]) {
                positions.push([
                    rightParts[1][index][0],
                    rightParts[1][index][1] + line.length + 1
                ]);
            }
            return line + ' ' + rightLines[index];
        }).join('\n');
        return [result, positions];
    }
    return alignText(text);
}
exports.block = block;
//# sourceMappingURL=alignment.js.map