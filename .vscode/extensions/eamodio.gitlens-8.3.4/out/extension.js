module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)i.d(s,o,function(t){return e[t]}.bind(null,o));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";i.r(t);var s,o,r,a,n,h,c,l,d,u,m,g,p,f,v,w,b=i(0);!function(e){e.File="file",e.Window="window"}(s||(s={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(o||(o={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(r||(r={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(a||(a={})),function(e){e.Absolute="absolute",e.Relative="relative"}(n||(n={})),function(e){e.List="list",e.Tree="tree"}(h||(h={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(c||(c={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(l||(l={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(d||(d={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(u||(u={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(m||(m={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(g||(g={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(p||(p={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(f||(f={})),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(v||(v={})),function(e){function t(e,i,s=!0){if(void 0===e.children)return e;const o=[...v.values(e.children)];for(const e of o)t(e,i,!1);if(!s&&1===o.length){const t=o[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.groupByMap=function(e,t){return e.reduce((e,i)=>{const s=t(i),o=e.get(s)||[];return e.set(s,o),o.push(i),e},new Map)},e.groupByFilterMap=function(e,t,i){return e.reduce((e,s)=>{const o=i(s);if(null!=o){const i=t(s),r=e.get(i)||[];e.set(i,r),r.push(o)}return e},new Map)},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(w||(w={}));var C=i(6);const y=i(8);y.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const x={addSuffix:!0,locale:y};var $;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-6e4*s.getTimezoneOffset(),a=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-a)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(C.distanceInWordsToNow)(e,x),format:t=>Object(C.format)(e,t)}}}($||($={}));var S=i(3);const _=i(11),D=i(10);var k,F;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=S.__rest(s,["track"]);if(!0!==o)return _(e,t,r);let a=!1;const n=_(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return D(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(k||(k={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e,t){let i,s=0;for(;!(i=e.next()).done;)(void 0===t||t(i.value))&&s++;return s},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(F||(F={}));class P{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class T{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(47===t||92===t){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}class R{isEmpty(){return!(this.left||this.mid||this.right||this.value)}}class E{constructor(e){this._iter=e}static forPaths(){return new E(new T)}static forStrings(){return new E(new P)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new R,this._root.segment=i.value()),s=this._root;;){const e=i.cmp(s.segment);if(e>0)s.left||(s.left=new R,s.left.segment=i.value()),s=s.left;else if(e<0)s.right||(s.right=new R,s.right.segment=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new R,s.mid.segment=i.value()),s=s.mid}}const o=s.value;return s.value=t,s.key=e,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.value:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.value=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.value||i,s=s.mid}}return s&&s.value||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new E(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,e)}_forEach(e,t){void 0!==e&&(this._forEach(e.left,t),e.value&&t(e.value,e.key),this._forEach(e.mid,t),this._forEach(e.right,t))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(e){return void 0===this._root||this._root.isEmpty()?0:F.count(this.entries(),void 0===e?void 0:([t])=>e(t))}entries(){return this._iterator(this._root)}values(){return F.map(this.entries(),([e])=>e)}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}some(e){return void 0!==this._root&&!this._root.isEmpty()&&F.some(this.entries(),([t])=>e(t))}*_iterator(e){void 0!==e&&(yield*this._iterator(e.left),e.value&&(yield[e.value,e.key]),yield*this._iterator(e.mid),yield*this._iterator(e.right))}}var B,A,N=i(5);!function(e){const t=/\\/g,i=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,s=/\$\{(\w*?)(?:\W|\d)*?\}/g;function o(e,t,i=" "){const s=t-c(e);return s<=0?e:i.repeat(s)+e}function r(e,t,i=" "){const s=t-c(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const t=[];let s=i.exec(e);for(;null!=s;){const o=s[2],r=s[3];t.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=i.exec(e)}return t},e.interpolate=function(e,t){return e?void 0===t?e.replace(s,""):(e=e.replace(s,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(N.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(t,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=o,e.padLeftOrTruncate=function(e,t,i){const s=c(e);return s<t?o(e,t,i):s>t?n(e,t):e},e.padRight=r,e.padOrTruncate=function(e,t,i){const s=t<0;t=Math.abs(t);const a=c(e);return a<t?s?o(e,t,i):r(e,t,i):a>t?n(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=c(e);return s<t?r(e,t,i):s>t?n(e,t):e};const a=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function n(e,t,i="…"){if(!e)return e;const s=c(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=c(e.substring(0,o));for(;r<t;)r+=c(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(a,t):e},e.sha1=function(e,t="base64"){return Object(N.createHash)("sha1").update(e).digest(t)},e.truncate=n;const h=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function c(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(h,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159||r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=l(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function l(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=c}(B||(B={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(A||(A={}));const L="gitlens",U="GitLens",O=`eamodio.${L}`,I="GitLens";var M,W,H,G,j;function V(e,t){return b.commands.executeCommand(M.SetContext,e,t)}function Q(e){const t=b.window.activeTextEditor;return null!=t&&t.document===e}function K(e){const t=e.document.uri.scheme;return t!==H.Output&&t!==H.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(M||(M={})),function(e){e.ActiveHasRemotes="gitlens:activeHasRemotes",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.HistoryExplorer="gitlens:historyExplorer",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(W||(W={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(H||(H={})),function(e){e.AngleBracketLeftHeavy="❰",e.AngleBracketRightHeavy="❱",e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowHeadRight="➤",e.ArrowLeft="←",e.ArrowLeftDouble="⇐",e.ArrowLeftRight="↔",e.ArrowLeftRightDouble="⇔",e.ArrowLeftRightDoubleStrike="⇎",e.ArrowLeftRightLong="⟷",e.ArrowRight="→",e.ArrowRightDouble="⇒",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.ArrowsHalfLeftRight="⇋",e.ArrowsHalfRightLeft="⇌",e.ArrowsLeftRight="⇆",e.ArrowsRightLeft="⇄",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.MuchGreaterThan="≪",e.MuchLessThan="⋘",e.Pencil="✎",e.Space=" ",e.SpaceThin=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(G||(G={})),(j||(j={})).GitLensVersion="gitlensVersion";const z=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var q;!function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(q||(q={}));class Y{}const X=new class extends Y{equals(e,t){return e===t}},Z=new class extends Y{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?X.equals(e.document,t.document):e.id===t.id)}},J=new class extends Y{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ee,te;!function(e){e.Computing="computing",e.Computed="computed"}(ee||(ee={}));class ie extends b.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=ie.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=b.Disposable.from(b.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(X.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=k.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ee.Computing,e===b.window.activeTextEditor&&await V(W.AnnotationStatus,this.status),this.editor=e,this.correlationKey=ie.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ee.Computed,e===b.window.activeTextEditor&&(await V(W.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ee.Computing,await this.onProvideAnnotation(e)?(this.status=ee.Computed,!0):(this.status=void 0,!1)}}function se(e){switch(e.type){case te.Branch:return"Branch";case te.Branches:return"Branches";case te.Commit:return"Commit";case te.File:return"File";case te.Repo:return"Repository";case te.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(te||(te={}));class oe{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return b.commands.executeCommand(M.Open,b.Uri.parse(e))}open(e){switch(e.type){case te.Branch:return this.openBranch(e.branch);case te.Branches:return this.openBranches();case te.Commit:return this.openCommit(e.sha);case te.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case te.Repo:return this.openRepo();case te.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const re=/(^|\s)(issue #([0-9]+))\b/gi,ae=/(^|\s)(pull request #([0-9]+))\b/gi;class ne extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(re,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ae,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const he=/(^|\s)(issue #([0-9]+))\b/gi,ce=/(^|\s)(pull request #([0-9]+))\b/gi;class le extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(he,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ce,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class de extends oe{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return B.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return B.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return B.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return B.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?B.interpolate(this.urls.fileLine,{line:s.start.line}):B.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?B.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?B.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):B.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const ue=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,me=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class ge extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(ue,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(me,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const pe=/(^|\s)(#([0-9]+))\b/gi;class fe extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(pe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const ve=/(^|\s)(#([0-9]+))\b/gi,we=/\/_git\/?/i,be=new Map([["bitbucket.org",(e,t)=>new ne(e,t)],["github.com",(e,t)=>new ge(e,t)],["gitlab.com",(e,t)=>new fe(e,t)],["visualstudio.com",(e,t)=>new class extends oe{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}enrichMessage(e){const t=this.baseUrl.replace(we,"/");return e.replace(ve,`$1[$2](${t}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class Ce{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void ur.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(be);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case a.Bitbucket:return(t,i)=>new ne(t,i,e.protocol,e.name,!0);case a.BitbucketServer:return(t,i)=>new le(t,i,e.protocol,e.name,!0);case a.Custom:return(t,i)=>new de(t,i,e.urls,e.protocol,e.name);case a.GitHub:return(t,i)=>new ge(t,i,e.protocol,e.name,!0);case a.GitLab:return(t,i)=>new fe(t,i,e.protocol,e.name,!0)}}}var ye=i(7),xe=i(2),$e=i(1);const Se="win32"===process.platform;function _e(e){if(e.match(/[\\\/]/))return e;const t=$e.join(".",e);try{if(xe.statSync(t))return t}catch(e){}const i=process.env.PATH.split(Se?";":":");for(const t of i){const i=$e.join(t,e);try{if(xe.statSync(i))return i}catch(e){}}return e}function De(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=S.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(ye.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&ur.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function ke(e){const t=await De(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!Se)return{cmd:_e(t),args:i};if(!xe.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=_e(`${t}${o}`);if(xe.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:$e.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:$e.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Fe(e){return e?ke($e.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var Pe=i(4);class Te extends b.Uri{constructor(e,t){if(null==e)return void super();if(e.scheme===H.GitLensGit){const t=JSON.parse(e.query),[i,s]=Te.ensureValidUNCPath(e.authority,$e.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Vt.isStagedUncommitted(t.sha)&&Vt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Te.ensureValidUNCPath(e.authority,$e.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Vt.isStagedUncommitted(t.sha)&&Vt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Vt.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?b.Uri.file(this.versionedPath):b.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return Te.getDirectory($e.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return $e.basename($e.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=B.pad(G.Dot,2,2),t){let i=$e.dirname(this.fsPath);return this.repoPath&&(i=$e.relative(this.repoPath,i)),void 0!==t&&(i=$e.relative(t,i)),(i=B.normalizePath(i))&&"."!==i?`${$e.basename(this.fsPath)}${e}${i}`:$e.basename(this.fsPath)}getRelativePath(e){let t=$e.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=$e.relative(e,t)),B.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Te(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Te(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=b.Uri.file($e.resolve(t,s&&e.originalFileName||e.fileName));return new Te(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Te(b.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Te(e)}static async fromUri(e){if(e instanceof Te)return e;if(!ar.git.isTrackable(e))return new Te(e);if(e.scheme===H.GitLensGit)return new Te(e);if(e.scheme===H.Git){const t=JSON.parse(e.query),i=await ar.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Vt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Te(e,{fileName:t.path,repoPath:i,sha:s})}const t=await ar.git.getVersionedUri(e);return void 0!==t?t:new Te(e,await ar.git.getRepoPath(e))}static getDirectory(e,t){let i=$e.dirname(e);return void 0!==t&&(i=$e.relative(t,i)),(i=B.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=B.pad(G.Dot,2,2),i){let s;if(e instanceof b.Uri){if(e instanceof Te)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Te.getDirectory(s,i);return o?`${$e.basename(s)}${t}${o}`:$e.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof b.Uri){if(e instanceof Te)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=$e.relative(i||"",s);return void 0!==t&&(o=$e.relative(t,o)),B.normalizePath(o)}static toKey(e){return B.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:$e.resolve(i,t.fileName),o=e,r=Vt.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:B.normalizePath($e.relative(i,s)),repoPath:i,sha:o},n=$e.parse(s);return b.Uri.parse(`${H.GitLensGit}:${$e.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Re=new Map;var Ee;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Ee||(Ee={}));const Be={dateFormat:void 0,dateStyle:void 0,reset:()=>{Be.dateStyle=cr.get(cr.name("defaultDateStyle").value),Be.dateFormat=cr.get(cr.name("defaultDateFormat").value)}};class Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Be.dateStyle===n.Absolute?this.formatDate(Be.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Tt.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Ee.Blame||this.type===Ee.File||this.type===Ee.StashFile}get isStash(){return this.type===Ee.Stash||this.type===Ee.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Tt.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Tt.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Tt.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Tt.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?b.Uri.file($e.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return b.Uri.file($e.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=$.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=$.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=B.pad(G.Dot,2,2)){return Te.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Re.get(i);if(void 0!==s)return s;const o=(s=b.Uri.parse(`https://www.gravatar.com/avatar/${this.email?B.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Re.set(i,s),s}getShortMessage(e=`${G.Space}${G.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await ar.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Te.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ne extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){super(Ee.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ne(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Le{constructor(e,t,i=!1,s,o,r=0,a=0){this.repoPath=e,this.current=i,this.sha=s,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.name=t,this.tracking=""===o||null==o?void 0:o,this.state={ahead:r,behind:a}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Le.getRemote(this.name):void 0!==this.tracking?Le.getRemote(this.tracking):void 0}getTrackingStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.tracking||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}isValid(){return Le.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Ue=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Oe=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Ie=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class Me{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=Ie.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new We(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=F.skip(B.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Ue.exec(e)))break;i.push(wt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Oe.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class We{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=Me.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class He extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l,d,u,m){super(e,t,i,s,o,r,a,n,l,d,u),this.fileStatuses=h,this.status=c,this.parentShas=m}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Tt.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?b.Uri.file($e.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=B.normalizePath($e.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Ee.StashFile:Ee.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new He(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ge,je,Ve;!function(e){e.Fetch="fetch",e.Push="push"}(Ge||(Ge={}));class Qe{constructor(e,t,i,s,o,r,a){this.repoPath=e,this.name=t,this.scheme=i,this.domain=s,this.path=o,this.provider=r,this.types=a}}!function(e){e.Config="config",e.Closed="closed",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(je||(je={}));class Ke{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(Ve||(Ve={})).StatusNode="statusNode";class ze extends b.Disposable{constructor(e,t,i,s,o,r=!1){if(super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new b.EventEmitter,this._onDidChangeFileSystem=new b.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this._closed=!1,i)this.formattedName=e.name;else{const i=$e.relative(e.uri.fsPath,t);this.formattedName=i?`${e.name} (${i})`:e.name}this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o,this._closed=r;const a=b.workspace.createFileSystemWatcher(new b.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=b.Disposable.from(a,a.onDidChange(this.onRepositoryChanged,this),a.onDidCreate(this.onRepositoryChanged,this),a.onDidDelete(this.onRepositoryChanged,this),cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=cr.initializing(e),i=cr.name("remotes").value;(t||cr.changed(e,i,this.folder.uri))&&(this._providerMap=Ce.createMap(cr.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(je.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(je.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(je.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(je.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(je.Config,je.Remotes);this.onAnyRepositoryChanged(this,je.Repository),this.fireChange(je.Repository)}}}get closed(){return this._closed}set closed(e){const t=this._closed!==e;this._closed=e,t&&(this.onAnyRepositoryChanged(this,je.Closed),this.fireChange(je.Closed))}containsUri(e){return e instanceof Te&&(e=void 0!==e.repoPath?b.Uri.file(e.repoPath):e.fileUri()),this.folder===b.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=ar.git.getBranch(this.path)),this._branch}getBranches(){return ar.git.getBranches(this.path)}getChangedFilesCount(e){return ar.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=cr.get(cr.name("remotes").value,this.folder.uri);this._providerMap=Ce.createMap(e)}this._remotes=ar.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return ar.git.getStashList(this.path)}getStatus(){return ar.git.getStatusForRepo(this.path)}getTags(){return ar.git.getTags(this.path)}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}async hasTrackingBranch(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=b.workspace.createFileSystemWatcher(new b.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=b.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=k.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new Ke(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=k.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}}class qe extends He{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new qe(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class Ye{constructor(e,t,i,s,o,r){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=r}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${this._diff.added} ${1===this._diff.added?"file":"files"} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${1===this._diff.changed?"file":"files"} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${1===this._diff.deleted?"file":"files"} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.upstream||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}}class Xe{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return b.Uri.file($e.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return Xe.getFormattedDirectory(this,e)}getFormattedPath(e=B.pad(G.Dot,2,2)){return Xe.getFormattedPath(this,e)}getOcticon(){return Je(this.status)}getStatusText(e){return Xe.getStatusText(this.status)}with(e){return new Xe(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Te.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${B.pad(G.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=B.pad(G.Dot,2,2),i){return Te.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Te.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return it[e]||it.X}(e)}}const Ze={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function Je(e,t=G.Space.repeat(4)){return Ze[e]||t}const et={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function tt(e){return et[e]||et.X}const it={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class st{constructor(e,t){this.repoPath=e,this.name=t}getBasename(){if(void 0===this._basename){const e=this.name.lastIndexOf("/");this._basename=-1!==e?this.name.substring(e+1):this.name}return this._basename}}class ot{static parse(e,t,i,s){if(!e)return;const o=new Map,r=new Map,a=[];let n,h,c=t&&i,l=void 0,d=!0;for(n of B.lines(e))if(!((h=n.split(" ")).length<2))if(void 0!==l)switch(h[0]){case"author":Tt.isUncommitted(l.sha)?l.author="You":(l.author=h.slice(1).join(" ").trim(),void 0!==s&&s===l.author&&(l.author="You"));break;case"author-mail":l.authorEmail=h.slice(1).join(" ").trim();const e=l.authorEmail.indexOf("<");if(e>=0){const t=l.authorEmail.indexOf(">",e);l.authorEmail=t>e?l.authorEmail.substring(e+1,t):l.authorEmail.substring(e+1)}break;case"author-time":l.authorDate=h[1];break;case"author-tz":l.authorTimeZone=h[1];break;case"summary":l.summary=h.slice(1).join(" ").trim();break;case"previous":l.previousSha=h[1],l.previousFileName=h.slice(2).join(" ");break;case"filename":l.fileName=h.slice(1).join(" "),d&&void 0===t&&(t=B.normalizePath(i.replace(i.startsWith("/")?`/${l.fileName}`:l.fileName,"")),c=B.normalizePath($e.relative(t,i))),d=!1,ot.parseEntry(l,t,c,r,o,a),l=void 0}else l={sha:h[0],originalLine:parseInt(h[1],10)-1,line:parseInt(h[2],10)-1,lineCount:parseInt(h[3],10)};return r.forEach(e=>{if(void 0===e.author)return;const t=o.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...o.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:a}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Ne(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const rt=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,at=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class nt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=rt.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Le(t,s[2],"*"===s[1],s[3],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=at.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const ht=/diff --git a\/(.*) b\/(.*)/,ct={};class lt{static parse(e,t,i,s,o,r,a,n,h){if(!e)return;let c,l,d=void 0,u=ct,m=void 0,g=0,p=!0;const f=B.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=B.normalizePath(i));const b=new Map,C=new Map;for(;!((v=f.next()).done||(m=v.value,n&&a&&g>=a));)switch(l=m.charCodeAt(1)){case 114:u={ref:m.substring(4)};break;case 97:Tt.isUncommitted(u.ref)?u.author="You":(u.author=m.substring(4),void 0!==r&&r===u.author&&(u.author="You"));break;case 101:u.email=m.substring(4);break;case 100:u.date=m.substring(4);break;case 112:u.parentShas=m.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(m=v.value);)void 0===u.summary?u.summary=m:u.summary+=`\n${m}`;void 0!==u.summary&&(u.summary=u.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(m=v.value);)if(!m.startsWith("warning:"))if(t===Ee.Branch){const e={status:m[0],fileName:m.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===u.fileStatuses&&(u.fileStatuses=[]),u.fileStatuses.push(e))}else{if(m.startsWith("diff")){const e=ht.exec(m);if(null!=e){u.fileName=e[1];const t=e[2];u.fileName!==t&&(u.originalFileName=t),u.status=u.fileName!==u.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}u.status=m[0],u.fileName=m.substring(1),this.parseFileName(u)}void 0!==u.fileStatuses&&(u.fileName=w.filterMap(u.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Ee.File&&void 0!==s?(i=B.normalizePath(s.replace(s.startsWith("/")?`/${u.fileName}`:u.fileName,"")),c=B.normalizePath($e.relative(i,s))):c=u.fileName,p=!1;const e=C.get(u.ref);void 0===e&&g++,d=lt.parseEntry(u,e,t,i,c,C,b,d)}return{repoPath:i,authors:b,commits:C,sha:o,count:g,maxCount:a,range:h,truncated:!!(a&&g>=a&&1!==a)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Ee.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new He(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Ee.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const dt=/^(.*)\t(.*)\s\((.*)\)$/gm,ut=/^(?:(git:\/\/)(.*?)\/|(https?:\/\/)(?:.*?@)?(.*?)\/|git@(.*):|(ssh:\/\/)(?:.*@)?(.*?)(?::.*?)?\/|(?:.*?@)(.*?):)(.*)$/;class mt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=dt.exec(e)))break;const a=r[2],[n,h,c]=this.parseGitUrl(a),l=`${h}/${c}`;let d=o[l];void 0===d?(d=new Qe(t,r[1],n,h,c,i(h,c),[{url:a,type:r[3]}]),s.push(d),o[l]=d):d.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=ut.exec(e);return null==t?["","",""]:[t[1]||t[3]||t[6],t[2]||t[4]||t[5]||t[7]||t[8],t[9].replace(/\.git\/?$/,"")]}}const gt={};class pt{static parse(e,t){if(!e)return;const i=B.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=B.normalizePath(t));const o=new Map;let r,a=gt,n=void 0;for(;!(s=i.next()).done;)switch(r=(n=s.value).charCodeAt(1)){case 114:a={ref:n.substring(4)};break;case 100:a.date=n.substring(4);break;case 108:a.stashName=n.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(n=s.value);)void 0===a.summary?a.summary=n:a.summary+=`\n${n}`;void 0!==a.summary&&(a.summary=a.summary.slice(0,-1));break;case 102:if(!(s=i.next()).done&&"</f>"!==s.value){for(;!(s=i.next()).done&&"</f>"!==(n=s.value);){if(n.startsWith("warning:"))continue;const e={status:n[0],fileName:n.substring(1),originalFileName:void 0};lt.parseFileName(e),e.fileName&&(void 0===a.fileStatuses&&(a.fileStatuses=[]),a.fileStatuses.push(e))}void 0!==a.fileStatuses&&(a.fileNames=w.filterMap(a.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "))}let e=o.get(a.ref);e=pt.parseEntry(a,e,t,o)}return{repoPath:t,commits:o}}static parseEntry(e,t,i,s){return void 0===t&&(t=new qe(Ee.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const ft=/(?:ahead ([0-9]+))/,vt=/(?:behind ([0-9]+))/;class wt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=ft.exec(t);o.ahead=null==i?0:+i[1]||0;const s=vt.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new Ye(B.normalizePath(t),i||"","",s,o,r)}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new Ye(B.normalizePath(t),i||"",o||"",s,r,a)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new Xe(e,o,r,i,s)}}class bt{static parse(e,t){if(!e)return;const i=w.filterMap(e.split("\n"),e=>e?new st(t,e):void 0);return i.length?i:void 0}}let Ct;const yt=["blame","--root","--incremental"],xt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],$t=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],St={badRevision:/bad revision \'.*?\'/i},_t={notARepository:/Not a git repository/i,outsideRepository:/is outside repository/i,noPath:/no such path/i,noCommits:/does not have any commits/i,notFound:/Path \'.*?\' does not exist in/i,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/i,headNotABranch:/HEAD does not point to a branch/i,noUpstream:/no upstream configured for branch \'(.*?)\'/i,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree|not stored as a remote-tracking branch/i};async function Dt(e,...t){try{return await Ft(e,...t)}catch(i){return Pt(i,e,...t)}}const kt=new Map;async function Ft(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=S.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let c,l,d=kt.get(h);void 0===d?(ur.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),d=De(Ct.path,t,a),kt.set(h,d)):ur.log(`Awaiting${h}`);try{c=await d}catch(e){throw l=e,e}finally{kt.delete(h);const e=process.hrtime(i),t=`${void 0===l?"Completed":"FAILED"} in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;ur.log(`${void 0===l?"Completed":"FAILED"}${h} ${t}`),ur.logGitCommand(`${n} ${t}`,a.cwd,l)}return"utf8"===r||"binary"===r?c:Pe.decode(Buffer.from(c,"binary"),r)}function Pt(e,t,...i){const s=e&&e.toString();if(s)for(const e of v.values(_t))if(e.test(s))return ur.warn("git",...i,`  cwd='${t.cwd}'\n\n  `,s.replace(/\r?\n|\r/g," ")),"";throw ur.error(e,"git",...i,`  cwd='${t.cwd}'\n\n  `),e}class Tt{static gitInfo(){return Ct}static getEncoding(e){return void 0!==e&&Pe.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Ct=await async function(e){try{return await ke(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await De("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return ke(e);try{return await De("xcode-select",["-p"]),ke(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):ke(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Fe(process.env.ProgramW6432).then(null,()=>Fe(process.env["ProgramFiles(x86)"])).then(null,()=>Fe(process.env.ProgramFiles)).then(null,()=>ke("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return ur.log(`Git found: ${Ct.version} @ ${"git"===Ct.path?"PATH":Ct.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Ct}static async getVersionedFile(e,t,s){const o=await Tt.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Tt.isStagedUncommitted(s)&&(s="");const r=B.truncate(B.sanitizeForFileSystem(Tt.isSha(s)?Tt.shortenSha(s):s),50,""),a=$e.extname(t),n=await Promise.resolve().then(i.t.bind(null,13,7));return new Promise((i,h)=>{n.file({prefix:`${$e.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(ur.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),xe.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):xe.chmod(a,33060,e=>{i(a)})}))})})}static isResolveRequired(e){return Tt.isSha(e)&&!Tt.shaStrictRegex.test(e)}static isSha(e){return Tt.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Tt.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Tt.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(Tt.isStagedUncommitted(e))return t.stagedUncommitted;if(Tt.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=B.normalizePath(e);const i=((t=B.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=B.normalizePath(i?$e.dirname(e):t),e=B.normalizePath(i?$e.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Ct.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...yt];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),i&&(Tt.isStagedUncommitted(i)?(a.push("--contents","-"),n=await Tt.show(e,t,":")):a.push(i)),Dt({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...yt];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),a.push("--contents","-"),Dt({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),Dt({cwd:e},...i)}static branch_contains(e,t,i={remote:!1}){const s=["branch","--contains"];return i.remote&&s.push("-r"),Dt({cwd:e},...s,t)}static checkout(e,t,i){const[s,o]=Tt.splitPath(t,e);return Dt({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Ft({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["diff","--diff-filter=M","-M","--no-ext-diff","--minimal"];return i&&r.push(Tt.isStagedUncommitted(i)?"--staged":i),s&&r.push(Tt.isStagedUncommitted(s)?"--staged":s),Dt({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Dt({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Dt({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Dt({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Dt({cwd:e},...o)}static log(e,t){const i=[...xt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Tt.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Dt({cwd:e},...i,"--")}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Tt.splitPath(t,e),r=[...xt];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!Tt.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),Dt({cwd:o},...r,"--",s)}static async log_recent(e,t){try{return(await Ft({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Ft({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...xt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),Dt({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Tt.isStagedUncommitted(t.ref)&&i.push(t.ref),Dt({cwd:e},...i,"--")}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Tt.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Ft({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Dt({cwd:e},...o,t,i)}static remote(e){return Dt({cwd:e},"remote","-v")}static remote_url(e,t){return Dt({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Ft({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Ft(i,...t)}catch(e){const s=e&&e.toString();if(_t.headNotABranch.test(s))return;const o=_t.noUpstream.exec(s);if(null!==o)return o[1];if(_t.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Ft(i,...t)}catch(e){return}return Pt(e,i,...t)}}static async revparse_toplevel(e){try{return(await Ft({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e);if(Tt.isStagedUncommitted(i)&&(i=":"),Tt.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Ft(a,"show",n,"--")}catch(o){const r=o&&o.toString();if(":"===i&&St.badRevision.test(r))return Tt.show(e,t,"HEAD:",s);if(St.badRevision.test(r)||_t.notFound.test(r)||_t.foundButNotInRevision.test(r))return;return Pt(o,a,n)}}static stash_apply(e,t,i){if(t)return Dt({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Dt({cwd:e},"stash","drop",t)}static stash_list(e){return Dt({cwd:e},...$t)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Dt({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Dt({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Dt({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Tt.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return Dt({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",r,s)}static tag(e){return Dt({cwd:e},...["tag","-l"])}}Tt.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Tt.shaStrictRegex=/^[0-9a-f]{40}$/,Tt.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Tt.stagedUncommittedSha="0000000000000000000000000000000000000000:",Tt.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Tt.uncommittedSha="0000000000000000000000000000000000000000";class Rt extends b.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new b.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===ar.git&&!await k.waitUntil(()=>void 0!==ar.git,2e3))throw ur.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Te.fromUri(e),this._disposed)return;const t=await ar.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(je.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){V(W.ActiveIsRevision,this.isRevision),V(W.ActiveFileIsTracked,this.isTracked),V(W.ActiveIsBlameable,this.isBlameable),V(W.ActiveHasRemotes,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,ur.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&Q(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=b.window.activeTextEditor;return null!=t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await ar.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemotes(),void 0!==t){const s=this.isBlameable;if(V(W.ActiveIsRevision,this.isRevision),V(W.ActiveFileIsTracked,this.isTracked),V(W.ActiveIsBlameable,s),V(W.ActiveHasRemotes,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class Et extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new b.EventEmitter,this._onDidChangeDirtyState=new b.EventEmitter,this._onDidTriggerDirtyIdle=new b.EventEmitter,this._documentMap=new Map,this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this),b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,0),this),b.workspace.onDidChangeTextDocument(k.debounce(this.onTextDocumentChanged,50),this),b.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),b.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(b.window.activeTextEditor)}onConfigurationChanged(e){const t=cr.initializing(e);if(!t&&(cr.changed(e,cr.name("blame")("ignoreWhitespace").value,null)||cr.changed(e,cr.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=cr.name("advanced")("blame")("delayAfterEdit").value;(t||cr.changed(e,i))&&(this._dirtyIdleTriggerDelay=cr.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!K(e))return;if(void 0===e)return V(W.ActiveIsRevision,!1),V(W.ActiveFileIsTracked,!1),V(W.ActiveIsBlameable,!1),void V(W.ActiveHasRemotes,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==H.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=b.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?Q(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof b.Uri)&&(e=Te.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Te)try{e=await b.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new At(e);else{if(!i.includes("File not found"))throw t;e=new Nt(e)}}else e instanceof b.Uri&&(e=await b.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Te?e=Te.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof b.Uri)&&(e=Te.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Te.toKey(e.uri),i=new Rt(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),b.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=k.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=k.debounce(async e=>{b.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class Bt{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=b.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class At extends Bt{}class Nt extends Bt{}class Lt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class Ut extends Et{}class Ot{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=B.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:B.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?B.padLeft(e,i):(t.collapseWhitespace&&(i-=o),B.padRight(e,i))):o<0?B.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof Ot)return B.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:B.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),B.interpolate(t,this._formatter)}}Ot._formatter=void 0;class It extends Ot{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:ar.config.defaultDateStyle)===n.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;return e=this._item.isStagedUncommitted?"Staged changes":this._item.isUncommitted?"Uncommitted changes":this._options.truncateMessageAtNewLine?this._item.getShortMessage():this._item.message,this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Mt extends Ot{get directory(){const e=Xe.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=$e.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=Xe.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=Xe.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=Xe.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${G.Pencil} ${G.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Wt,Ht,Gt,jt;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Wt||(Wt={}));class Vt extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new b.EventEmitter,this._suspended=!1,this._userNameMapCache=new Map,this._repositoryTree=E.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=b.Disposable.from(b.window.onDidChangeWindowState(this.onWindowStateChanged,this),b.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return ar.config.advanced.caching.enabled}onAnyRepositoryChanged(e,t){this._trackedCache.clear(),t===je.Closed&&setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}onConfigurationChanged(e){(cr.initializing(e)||cr.changed(e,cr.name("defaultDateStyle").value)||cr.changed(e,cr.name("defaultDateFormat").value))&&Be.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:b.workspace.workspaceFolders||[],removed:[]},ur.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==H.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==H.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...F.map(i.entries(),([t,i])=>[t,$e.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=cr.get(cr.name("advanced")("repositorySearchDepth").value,t);ur.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const s=process.hrtime(),o=[],r=this.onAnyRepositoryChanged.bind(this),a=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==a&&(ur.log(`Repository found in '${a}'`),o.push(new ze(e,a,!0,r,this._suspended))),i<=0){const e=process.hrtime(s);return ur.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),o}let n=Object.assign({},b.workspace.getConfiguration("files",t).get("exclude",{}),b.workspace.getConfiguration("search",t).get("exclude",{}));n=[...F.filterMap(v.entries(n),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const h=await this.repositorySearchCore(t.fsPath,i,n);for(let t of h){if(t=$e.dirname(t),B.normalizePath(t)===a)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(ur.log(`Repository found in '${i}'`),o.push(new ze(e,i,!1,r,this._suspended)))}const c=process.hrtime(s);return ur.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*c[0]+Math.floor(c[1]/1e6)} ms`),o}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{xe.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=$e.resolve(e,t);return new Promise((e,r)=>{xe.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await V(W.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await V(W.HasRemotes,i),!t){const e=b.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=b.Disposable.from(e,e.onDidCreate(async e=>{const i=b.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,ur.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Tt.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>xe.exists($e.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&F.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&F.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Tt.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=F.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Tt.splitPath(s,t)):s=B.normalizePath($e.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){let t;if(null!=(e=e||b.window.activeTextEditor)){const i=await ar.tracker.getOrAdd(e.document.uri);void 0!==i&&(t=i.uri.repoPath)}return null!=t?t:this.getHighlanderRepoPath()}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await ar.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return ur.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}ur.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Lt(i.key))}else ur.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(ur.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return ur.log(`Skipping blame; '${e.fsPath}' is not tracked`),Vt.emptyPromise;const[s,o]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const r=await Tt.blame(o,s,e.sha,{args:ar.config.advanced.blame.customArguments,ignoreWhitespace:ar.config.blame.ignoreWhitespace});return ot.parse(r,o,s,await this.getCurrentUsername(o))}catch(e){if(void 0!==t.state){const s=e&&e.toString();return ur.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Vt.emptyPromise,errorMessage:s}),t.setBlameFailure(),Vt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${B.sha1(t)}`,s=await ar.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return ur.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}ur.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Lt(s.key))}else ur.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(ur.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return ur.log(`Skipping blame; '${e.fsPath}' is not tracked`),Vt.emptyPromise;const[o,r]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Tt.blame_contents(r,o,t,{args:ar.config.advanced.blame.customArguments,correlationKey:`:${s}`,ignoreWhitespace:ar.config.blame.ignoreWhitespace});return ot.parse(a,r,o,await this.getCurrentUsername(r))}catch(e){if(void 0!==i.state){const t=e&&e.toString();return ur.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Vt.emptyPromise,errorMessage:t}),i.setBlameFailure(),Vt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(ur.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Tt.blame(e.repoPath,o,e.sha,{args:ar.config.advanced.blame.customArguments,ignoreWhitespace:ar.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=ot.parse(i,e.repoPath,o,await this.getCurrentUsername(e.repoPath));if(void 0===r)return;return{author:F.first(r.authors.values()),commit:F.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(ur.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await Tt.blame_contents(e.repoPath,r,i,{args:ar.config.advanced.blame.customArguments,ignoreWhitespace:ar.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=await this.getCurrentUsername(e.repoPath),n=ot.parse(s,e.repoPath,r,a);if(void 0===n)return;return{author:F.first(n.authors.values()),commit:F.first(n.commits.values()),line:n.lines[t]}}catch(e){return}}async getBlameForRange(e,t){ur.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(ur.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;ur.log(`getBranch('${e}')`);const t=await Tt.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Le(e,i[0],!0,void 0,i[1])}async getBranches(e){if(void 0===e)return[];ur.log(`getBranches('${e}')`);const t=await Tt.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return nt.parse(t,e)||[]}async getChangedFilesCount(e,t){ur.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Tt.diff_shortstat(e,t);return Me.parseShortStat(i)}async getConfig(e,t){return ur.log(`getConfig('${e}', '${t}')`),await Tt.config_get(e,t)}async getCurrentUsername(e){let t=this._userNameMapCache.get(e);return void 0===t&&(t=await Tt.config_get("user.name",e),this._userNameMapCache.set(e,t)),t}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await ar.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return ur.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}ur.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Lt(o.key))}else ur.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Vt.getEncoding(e)},o,s);return void 0!==o.state&&(ur.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=Tt.splitPath(t,e,!1);try{const t=await Tt.diff(h,n,i,s,o);return Me.parse(t)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return ur.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:Vt.emptyPromise,errorMessage:t}),Vt.emptyPromise}return}}async getDiffForLine(e,t,i,s){ur.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){ur.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Tt.diff_nameStatus(e,t,i,s);return Me.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Tt.log_recent(e,t)}async getLogCommit(e,t){ur.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){ur.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Tt.isResolveRequired(i.ref)?o||F.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),ur.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?ar.config.advanced.maxListItems||0:t.maxCount;try{const s=await Tt.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=lt.parse(s,Ee.Branch,e,void 0,t.ref,await this.getCurrentUsername(e),i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){ur.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?ar.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Wt.Author:r=[`--author=${t}`];break;case Wt.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Wt.Changes:r=[`-G${t}`];break;case Wt.Files:r=["--",`${t}`];break;case Wt.Message:r=[`--grep=${t}`];break;case Wt.Sha:r=[t],o=1}try{const a=await Tt.log_search(e,r,{maxCount:o}),n=lt.parse(a,Ee.Branch,e,void 0,void 0,await this.getCurrentUsername(e),o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===B.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=ar.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await ar.tracker.getOrAdd(new Te(b.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return ur.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return ur.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;ur.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return ur.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}ur.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new Lt(o.key))}else ur.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(ur.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return ur.log(`Skipping log; '${t}' is not tracked`),Vt.emptyPromise;const[r,a]=Tt.splitPath(t,e,!1);try{const{range:n}=i,h=S.__rest(i,["range"]),c=null==i.maxCount?ar.config.advanced.maxListItems||0:i.maxCount,l=await Tt.log_file(a,r,Object.assign({},h,{maxCount:c,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),d=lt.parse(l,Ee.File,a,r,h.ref,await this.getCurrentUsername(a),c,h.reverse,n);if(void 0!==d){const s=Object.assign({},i);d.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return d}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return ur.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Vt.emptyPromise,errorMessage:t}),Vt.emptyPromise}return}}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async hasTrackingBranch(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasTrackingBranch()}async getMergeBase(e,t,i,s={}){try{const o=await Tt.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void ur.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];ur.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];ur.log(`getRemotesCore('${e}')`),t=t||Ce.createMap(cr.get(cr.name("remotes").value,null));try{const i=await Tt.remote(e);return mt.parse(i,e,Ce.factory(t))}catch(e){return ur.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(null==e)return await this.getActiveRepoPath();if(e instanceof Te)return e.repoPath;let i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await ar.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s);let r=void 0===o?b.workspace.getWorkspaceFolder(b.Uri.file(s)):o.folder;if(void 0===r){const e=s.split("/");r={uri:b.Uri.file(s),name:e[e.length-1],index:this._repositoryTree.count()}}return i=new ze(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended),this._repositoryTree.set(s,i),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()}),s}async getRepoPathCore(e,t){try{return await Tt.revparse_toplevel(t?e:$e.dirname(e))}catch(e){return void ur.error(e,"GitService.getRepoPathCore")}}async getRepoPathOrActive(e,t){return await ar.git.getRepoPath(e)||ar.git.getActiveRepoPath(t)}async getRepositories(e){const t=(await this.getRepositoryTree()).values();return void 0!==e?F.filter(t,e):t}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Te){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;ur.log(`getStashList('${e}')`);const t=await Tt.stash_list(e);return pt.parse(t,e)}async getStatusForFile(e,t){ur.log(`getStatusForFile('${e}', '${t}')`);const i=Tt.validateVersion(2,11)?2:1,s=await Tt.status_file(e,t,i),o=wt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;ur.log(`getStatusForRepo('${e}')`);const t=Tt.validateVersion(2,11)?2:1,i=await Tt.status(e,t);return wt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];ur.log(`getTags('${e}')`);const t=await Tt.tag(e);return bt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(ur.log(`getVersionedFile('${e}', '${t}', '${i}')`),i===Vt.deletedSha)return;if(!i||Tt.isUncommitted(i)&&!Tt.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Tt.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Te.toKey(s),new Te(b.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return ur.log(`getVersionedFileText('${e}', '${t}', ${i})`),Tt.show(e,t,i,{encoding:Vt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Te.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===H.File||t===H.Git||t===H.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Vt.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=Tt.splitPath(e,t),s=Te.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Te.toKey(o)}void 0!==r&&(s+=`:${r}`),ur.log(`isTracked('${o}', '${t}', '${r}')`);let a=this._trackedCache.get(s);return void 0!==a?await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}async isTrackedCore(e,t,i){if(i===Vt.deletedSha)return!1;try{let s=!!await Tt.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return ur.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Tt.config_get("diff.guitool",e)||await Tt.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ur.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Tt.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ur.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Tt.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return Vt.isResolveRequired(t)?(ur.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),null==i?await Tt.revparse(e,t)||t:await Tt.log_resolve(e,B.normalizePath($e.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return ur.log(`stashApply('${e}', '${t}', ${i})`),Tt.stash_apply(e,t,i)}stashDelete(e,t){return ur.log(`stashDelete('${e}', '${t}')`),Tt.stash_delete(e,t)}stashSave(e,t,i){if(ur.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Tt.stash_save(e,t);Vt.ensureGitVersion("2.13.2","Stashing individual files");const s=i.map(t=>Tt.splitPath(t.fsPath,e)[0]);return Tt.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?b.Uri.file($e.join(e,t)):e;return Tt.getEncoding(b.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Tt.getGitInfo(e)}static getGitPath(){return Tt.gitInfo().path}static getGitVersion(){return Tt.gitInfo().version}static isResolveRequired(e){return Tt.isResolveRequired(e)}static isSha(e){return Tt.isSha(e)}static isStagedUncommitted(e){return Tt.isStagedUncommitted(e)}static isUncommitted(e){return Tt.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===Vt.deletedSha?t.deleted:Tt.isSha(e)||Tt.isStagedUncommitted(e)?Tt.shortenSha(e,t):e}static compareGitVersion(e,t){return A.compare(A.fromString(this.getGitVersion()),A.fromString(e))}static ensureGitVersion(e,t){const i=this.getGitVersion();if(-1===A.compare(A.fromString(i),A.fromString(e)))throw new Error(`${t} requires a newer version of Git (>= ${e}) than is currently installed (${i}). Please install a more recent version of Git to use this GitLens feature.`)}}Vt.emptyPromise=Promise.resolve(void 0),Vt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Vt.stagedUncommittedSha=Tt.stagedUncommittedSha,Vt.uncommittedSha=Tt.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Ht||(Ht={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Gt||(Gt={}));class Qt extends b.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class Kt extends Qt{get repoPath(){return this.uri.repoPath}}class zt extends Qt{constructor(e,t){super(new Te),this.message=e,this.tooltip=t}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.message,b.TreeItemCollapsibleState.None);return e.contextValue=Gt.Message,e.tooltip=this.tooltip,e}}class qt extends Qt{constructor(e,t,i){super(new Te),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.message,b.TreeItemCollapsibleState.None);return e.contextValue=Gt.Pager,e.command=this.getCommand(),e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:ar.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class Yt extends qt{constructor(e,t,i){super(`${e} ${G.Space}${G.Dash}${G.Space} this may take a while`,t,i),this.args={maxCount:0}}}class Xt extends Qt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of v.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new Xt(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Folder,e.iconPath=b.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(jt||(jt={}));class Zt extends Qt{constructor(e,t,i,s){super(Te.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await ar.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&jt.CommitIcon)===jt.CommitIcon)e.iconPath={dark:ar.context.asAbsolutePath($e.join("images","dark","icon-commit.svg")),light:ar.context.asAbsolutePath($e.join("images","light","icon-commit.svg"))};else if((this.displayAs&jt.StatusIcon)===jt.StatusIcon){const t=tt(this.status.status);e.iconPath={dark:ar.context.asAbsolutePath($e.join("images","dark",t)),light:ar.context.asAbsolutePath($e.join("images","light",t))}}else(this.displayAs&jt.Gravatar)===jt.Gravatar&&(e.iconPath=this.commit.getGravatarUri(ar.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&jt.CommitLabel?It.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dateFormat:ar.config.defaultDateFormat}):Mt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return Gt.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&jt.CommitLabel?this._tooltip=It.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:ar.config.defaultDateFormat}):this._tooltip=Mt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:us.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Jt extends Qt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(Jt.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==c.List){e=[];for(const t of v.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new Jt(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof Jt?-1:1)-(t instanceof Jt?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Folder,e.iconPath=b.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||c.Auto;if(s===c.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return c.List}return c.Tree}return s}}class ei extends Kt{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.getBranchTips=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...F.map(e.fileStatuses,t=>new Zt(t,e.toFileCommit(t),this.explorer,jt.File))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new Jt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=It.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:ar.config.defaultDateFormat});const t=this.getBranchTips&&this.getBranchTips(this.commit.sha);void 0!==t&&(e=`${G.AngleBracketLeftHeavy}${G.SpaceThin}${t}${G.SpaceThin}${G.AngleBracketRightHeavy}${G.ArrowHeadRight}${G.Space} ${e}`);const i=new b.TreeItem(e,b.TreeItemCollapsibleState.Collapsed);return i.contextValue=void 0===this.branch||this.branch.current?Gt.CommitOnCurrentBranch:Gt.Commit,this.explorer.config.avatars?i.iconPath=this.commit.getGravatarUri(ar.config.defaultGravatarsStyle):i.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-commit.svg"),light:ar.context.asAbsolutePath("images/light/icon-commit.svg")},i.tooltip=It.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}${void 0!==t?` (${t})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:ar.config.defaultDateFormat}),i}getCommand(){return{title:"Compare File with Previous Revision",command:us.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ti extends Kt{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===h.List?e:Le.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await ar.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new zt("No commits yet")];const t=await ar.git.getBranches(this.uri.repoPath),i=t[0].sha.length,s=w.groupByFilterMap(t,e=>e.sha,e=>e.name===this.branch.name?void 0:e.name),o=e=>{const t=s.get(e.substr(0,i));if(void 0!==t&&0!==t.length)return t.join(", ")},r=[...F.map(e.commits.values(),e=>new ei(e,this.explorer,this.branch,o))];return e.truncated&&r.push(new Yt("Show All Commits",this,this.explorer)),r}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.branch.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=` ${G.Space}${G.ArrowLeftRightLong}${this.branch.getTrackingStatus({prefix:`${G.Space} `})}${G.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${G.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const s=new b.TreeItem(`${this.branch.current?`${G.Check} ${G.Space}`:""}${e}`,b.TreeItemCollapsibleState.Collapsed);return s.tooltip=t,this.branch.remote?s.contextValue=Gt.RemoteBranch:this.branch.current?s.contextValue=this.branch.tracking?Gt.CurrentBranchWithTracking:Gt.CurrentBranch:s.contextValue=this.branch.tracking?Gt.BranchWithTracking:Gt.Branch,s.iconPath={dark:ar.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:ar.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},s}}class ii extends Qt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...F.filterMap(e,e=>e.remote?void 0:new ti(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===h.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=w.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),o=new Xt(this.repo.path,"",void 0,s,this.explorer),r=await o.getChildren();return void 0!==i&&r.splice(0,0,i),r}async getTreeItem(){const e=new b.TreeItem("Branches",this.active?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Gt.BranchesWithRemotes:Gt.Branches,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-branch.svg"),light:ar.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class si extends Qt{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...F.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new ti(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===h.List)return t;const i=w.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Xt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ge.Fetch),t=this.remote.types.find(e=>e.type===Ge.Push);let i;i=e&&t?G.ArrowLeftRightLong:e?G.ArrowLeft:t?G.ArrowRight:G.Dash;const s=`${this.remote.name} ${G.Space}${i}${G.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${G.Space}${G.Dot}${G.Space} ${this.remote.path}`,o=new b.TreeItem(s,b.TreeItemCollapsibleState.Collapsed);return o.contextValue=Gt.Remote,o.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?o.iconPath={dark:ar.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:ar.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-remote.svg"),light:ar.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class oi extends Qt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new zt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...F.map(e,e=>new si(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new b.TreeItem("Remotes",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Remotes,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-remote.svg"),light:ar.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class ri extends Qt{constructor(e,t,i,s){super(Te.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new Zt(this.status,e,this.explorer,jt.CommitLabel|(this.explorer.config.avatars?jt.Gravatar:jt.CommitIcon)))}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=b.TreeItemCollapsibleState.None,e.contextValue=Gt.StatusFile,this.commit.isStagedUncommitted?e.tooltip=Mt.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=Mt.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=Gt.StatusFileCommits,e.tooltip=Mt.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=tt(this.status.status);return e.iconPath={dark:ar.context.asAbsolutePath($e.join("images","dark",t)),light:ar.context.asAbsolutePath($e.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Mt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(`${t} ${1===t?"commit":"commits"}`),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:us.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ai extends Qt{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await ar.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(F.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...F.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Vt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Vt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Vt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Vt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Vt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const s=w.groupBy(e,e=>e.fileName);let o=[...F.map(v.values(s),e=>new ri(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(o,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new Jt(t,"",void 0,e,this.explorer);o=await i.getChildren()}else o.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&o.push(new Yt("Show All Changes",this,this.explorer)),o}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await ar.git.getChangedFilesCount(this.repoPath,this.status.upstream);void 0!==t&&(e=t.files)}const t=`${e} ${1===e?"file":"files"} changed`,i=new b.TreeItem(t,b.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Gt.StatusFiles,i.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-diff.svg"),light:ar.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class ni extends Qt{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await ar.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...F.map(t.commits.values(),e=>new ei(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await ar.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=F.first(t.commits.values())),[...F.map(i,e=>new ei(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} ${1===this.status.state.ahead?"commit":"commits"} (ahead of ${this.status.upstream})`:`${this.status.state.behind} ${1===this.status.state.behind?"commit":"commits"} (behind ${this.status.upstream})`,t=new b.TreeItem(e,b.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Gt.StatusUpstream,t.iconPath={dark:ar.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:ar.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class hi extends Qt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new ni(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new ni(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new ai(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new b.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=b.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o=`${e.getUpstreamStatus({prefix:`${G.Space} `})}${i?e.getDiffStatus({prefix:`${G.Space} `}):""}`,r=`${e.branch} (current)`,a="";e.upstream&&(this.explorer.config.showTrackingBranch&&(o+=`${G.Space} ${e.upstream}`),r+=`\n\nTracking ${G.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(a="-red"),e.state.ahead&&(a=e.state.behind?"-yellow":"-green"))),o=`${e.branch}${""===o?"":` ${G.Space}${e.upstream?G.ArrowLeftRightLong:G.Dash}${o}`}`,i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),s=t||i?this.active?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.Collapsed:b.TreeItemCollapsibleState.None;const n=new b.TreeItem(o,s);return n.id=this.id,n.contextValue=Gt.Status,n.tooltip=r,n.iconPath={dark:ar.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:ar.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},n}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class ci extends Zt{constructor(e,t,i){super(e,t,i,jt.File)}get resourceType(){return Gt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class li extends Kt{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await ar.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=F.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new ci(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new b.TreeItem(It.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:ar.config.defaultDateFormat}),b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Stash,e.tooltip=It.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dateFormat:ar.config.defaultDateFormat}),e}}class di extends Qt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new zt("No stashed changes")]:[...F.map(e.commits.values(),e=>new li(e,this.explorer))]}getTreeItem(){const e=new b.TreeItem("Stashes",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Stashes,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-stash.svg"),light:ar.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class ui extends Kt{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get label(){return this.explorer.config.branches.layout===h.Tree?this.tag.getBasename():this.tag.name}get ref(){return this.tag.name}async getChildren(){const e=await ar.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new zt("No commits yet")];const t=[...F.map(e.commits.values(),e=>new ei(e,this.explorer))];return e.truncated&&t.push(new Yt("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Tag,e}}class mi extends Qt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();if(0===e.length)return[new zt("No tags yet")];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...e.map(e=>new ui(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===h.List)return t;const i=w.makeHierarchical(t,e=>e.tag.name.split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Xt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}async getTreeItem(){const e=new b.TreeItem("Tags",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=Gt.Tags,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-tag.svg"),light:ar.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class gi extends Qt{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return void 0===this.children&&(this.updateSubscription(),this.children=[new hi(this.uri,this.repo,this.explorer,this.active),new ii(this.uri,this.repo,this.explorer,this.active),new oi(this.uri,this.repo,this.explorer,this.active),new di(this.uri,this.repo,this.explorer,this.active),new mi(this.uri,this.repo,this.explorer,this.active)]),this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${B.pad(G.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new b.TreeItem(e,this.active?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Gt.Repository,t}refresh(){this.resetChildren(),this.updateSubscription()}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||b.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(ur.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(je.Repository)||e.changed(je.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(je.Stashes)){const e=this.children.find(e=>e instanceof di);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(je.Remotes)){const e=this.children.find(e=>e instanceof oi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(je.Tags)){const e=this.children.find(e=>e instanceof mi);void 0!==e&&this.explorer.refreshNode(e)}}}}class pi extends Qt{constructor(e){super(void 0),this.explorer=e,ar.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(b.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!K(e))return;let t=!1;try{const i=await ar.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await ar.git.getRepository(i);if(void 0===s||s.closed)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new gi(Te.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new b.TreeItem("No active repository",b.TreeItemCollapsibleState.None);return e.id=this.id,e}}class fi extends Qt{constructor(e,t,i=Gt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new ei(this.commit,this.explorer).getChildren();return e.splice(0,0,new zt(It.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!0}),It.fromTemplate("${message}",this.commit))),e}async getTreeItem(){const e=It.fromTemplate(`Commit \${sha} ${B.pad(G.Dash,1,1)} \${authorAgoOrDate}`,this.commit,ar.config.defaultDateFormat),t=new b.TreeItem(e,b.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class vi extends Qt{constructor(e,t,i,s,o=Gt.ResultsCommits){super(Te.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...F.map(e.commits.values(),e=>new ei(e,this.explorer))];return e.truncated&&t.push(new Yt("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new b.TreeItem(await this.getLabel(),e&&e.count>0?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class wi extends Qt{constructor(e,t,i,s,o){super(Te.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.None);e.contextValue=Gt.StatusFile,e.tooltip=Mt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=tt(this.status.status);return e.iconPath={dark:ar.context.asAbsolutePath($e.join("images","dark",t)),light:ar.context.asAbsolutePath($e.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Mt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:us.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Te.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class bi extends Qt{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...F.map(e,e=>new wi(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new Jt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new b.TreeItem(await this.getLabel(),e&&e.length>0?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.None);return t.contextValue=Gt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await ar.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${0===t?"No":t} ${1===t?"file":"files"} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class Ci extends Qt{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new vi(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>ar.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new bi(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await ar.git.getRepositoryCount()>1){const t=await ar.git.getRepository(this.uri.repoPath);e=` ${B.pad(G.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new b.TreeItem(`Comparing ${this.ref1.label||Vt.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||Vt.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,b.TreeItemCollapsibleState.Expanded);return t.contextValue=Gt.ComparisonResults,t}}class yi extends Qt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=jt.CommitLabel|(this.explorer.config.avatars?jt.Gravatar:jt.StatusIcon),i=await ar.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Vt.uncommittedSha,void 0!==i.indexStatus?o=Vt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Vt.stagedUncommittedSha,o="HEAD");const r=new He(Ee.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new Zt(i,r,this.explorer,t))}const s=await ar.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...F.map(s.commits.values(),e=>new Zt(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new zt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new b.TreeItem(`${this.uri.getFormattedPath()}`,b.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-history.svg"),light:ar.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable=this.disposable||this.repo.onDidChange(this.onRepoChanged,this)}onRepoChanged(e){e.changed(je.Repository)&&(ur.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class xi extends Qt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new yi(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new b.TreeItem(`${this.uri.getFormattedPath()}`,b.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.History,e.iconPath={dark:ar.context.asAbsolutePath("images/dark/icon-history.svg"),light:ar.context.asAbsolutePath("images/light/icon-history.svg")},e}}class $i extends Qt{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return void 0===this.children&&(this.children=this.repositories.sort((e,t)=>e.index-t.index).filter(e=>!e.closed).map(e=>new gi(Te.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new pi(this.explorer))),this.children}refresh(){this.resetChildren()}getTreeItem(){const e=new b.TreeItem("Repositories",b.TreeItemCollapsibleState.Expanded);return e.contextValue=Gt.Repositories,e}}function Si(){return!cr.get(cr.name("advanced")("quickPick")("closeOnFocusOut").value)}function _i(e,t){const i=new b.CancellationTokenSource;return async function(e,t,i){const s=i&&await ar.keyboard.beginScope(i);try{await b.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Si()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Di{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):b.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class ki extends Di{constructor(e){super({label:e,description:""})}}class Fi extends Di{constructor(e,t){super({label:"",description:""},e,t)}}class Pi extends Di{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return _s(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ti extends Di{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await _s(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ri{constructor(e){this.commit=e;const t=e.getShortMessage(`${G.Space}$(ellipsis)`);e.isStash?(this.label=t,this.description="",this.detail=`${G.Space} ${e.stashName||e.shortSha} ${B.pad(G.Dot,1,1)} ${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${B.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${G.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${B.pad(G.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Ei extends Di{constructor(e,t={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays commit in the GitLens Results explorer`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){ar.resultsExplorer.showCommitInResults(this.commit)}}class Bi extends Di{constructor(e,t,i={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays commits in the GitLens Results explorer`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){ar.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Ai extends Bi{constructor(e,t,i={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays results in the GitLens Results explorer`}){super(e,{label:t},i),this.results=e,this.search=t}}class Ni extends Di{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${B.pad(G.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Hi.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([ar.git.getBranches(this.repoPath),ar.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Hi.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.cancel()}}}const Li=Object.create(null),Ui=["left","right",",",".","escape"],Oi=[];class Ii extends b.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||Li}async dispose(){const e=Oi.indexOf(this.mapping);ur.log("KeyboardScope.dispose",Oi.length,e),e===Oi.length-1?(Oi.pop(),await this.updateKeyCommandsContext(Oi[Oi.length-1])):Oi.splice(e,1)}async begin(){return Oi.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Oi[Oi.length-1];t===this.mapping&&t[e]&&(ur.log("KeyboardScope.clearKeyCommand",Oi.length,e),t[e]=void 0,await V(`${W.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Oi[Oi.length-1];i===this.mapping&&(ur.log("KeyboardScope.setKeyCommand",Oi.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await V(`${W.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Ui)t.push(V(`${W.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class Mi extends b.Disposable{constructor(){super(()=>this.dispose());const e=Ui.map(e=>b.commands.registerCommand(`${L}.key.${e}`,()=>this.execute(e),this));this._disposable=b.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return ur.log("Keyboard.beginScope",Oi.length),await new Ii(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Oi.length)try{let t=Oi[Oi.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return ur.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void ur.error(e,"Keyboard.execute")}}}class Wi{constructor(e){this.branchOrTag=e,e instanceof Le?(this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""):(this.label=`${G.Space.repeat(4)} ${e.name}`,this.description=`${G.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Le&&this.branchOrTag.remote}}class Hi{static showProgress(e){return _i(e,{left:Li,",":Li,".":Li})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new Wi(e)),...t.map(e=>new Wi(e)),...e.filter(e=>e.remote).map(e=>new Wi(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await ar.keyboard.beginScope({left:s.goBackCommand||Li});s.progressCancellation&&s.progressCancellation.cancel();const a=await b.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Si()});return await r.dispose(),a}}class Gi{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""}}class ji{static async show(e,t,i={}){const s=e.map(e=>new Gi(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await b.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Si()})}}class Vi extends Di{constructor(e,t){super({label:`$(link-external) Open ${se(t)} in ${e.provider.name}`,description:`${B.pad(G.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class Qi extends Di{constructor(e,t,i){const s=se(t);let o="";switch(t.type){case te.Branch:o=`$(git-branch) ${t.branch}`;break;case te.Branches:o="$(git-branch) Branches";break;case te.Commit:o=`$(git-commit) ${Vt.shortenSha(t.sha)}`;break;case te.File:o=`$(file-text) ${$e.basename(t.fileName)}`;break;case te.Repo:o="$(repo) Repository";break;case te.Revision:if(void 0!==t.commit&&t.commit instanceof He)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${$e.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${G.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${$e.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Vt.shortenSha(t.sha);o=`$(file-text) ${$e.basename(t.fileName)}${e?` in ${G.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${G.Ellipsis}`,description:`${B.pad(G.Dash,2,3)} ${o}`},us.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${B.pad(G.Dash,2,3)} $(repo) ${r.provider.path} ${B.pad(G.Dot,1,1)} ${o}`},us.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class Ki{static async show(e,t,i,s){const o=e.map(e=>new Vi(e,i));s&&o.splice(0,0,s);const r=await b.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Si()});if(void 0!==r)return r}}class zi{static showProgress(e){return _i(`${e} history ${G.Dash} search by commit message, filename, or commit id`,{left:Li,",":Li,".":Li})}static async show(e,t,i,s,o,r){const a=Array.from(F.map(e.commits.values(),e=>new Ri(e))),n=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i} history`},us.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await ar.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&a.splice(0,0,new Qi(h,{type:"branch",branch:i},n)),a.splice(0,0,new Di({label:"$(search) Show Commit Search",description:`${B.pad(G.Dash,2,3)} search for commits by message, author, files, or commit id`},us.ShowCommitSearch,[Te.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new Di({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},us.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new Di({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${e.maxCount} newer commits`},us.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=F.last(e.commits.values());null!=n&&(c=new Di({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${e.maxCount} older commits`},us.ShowQuickBranchHistory,[new Te(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await ar.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await b.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${G.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Si()});return await l.dispose(),d}}class qi extends Di{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${B.pad(G.Dash,2,3)} $(file-text) ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await ar.git.checkoutFile(e),_s(e,{preserveFocus:!0,preview:!1})}}class Yi extends Pi{constructor(e,t){super(b.Uri.file($e.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)}`})}}class Xi extends Pi{constructor(e,t){let i,s;"D"===e.status?(s=Te.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.previousShortSha} (deleted in ${G.Space}$(git-commit) ${e.shortSha})`):(s=Te.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class Zi{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&$e.basename(e.workingFileName)||$e.basename(e.fileName),h=e.isUncommitted;if(h){const t=await ar.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new qi(e)),e.previousFileShortSha&&r.push(new Di({label:"$(git-compare) Open Changes",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},us.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Di({label:"$(git-compare) Open Changes with Working Tree",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-text) ${n}`},us.DiffWithWorking,[b.Uri.file($e.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new Yi(e)),r.push(new Xi(e));const c=await ar.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await ar.git.getBranch(e.repoPath);void 0!==t&&r.push(new Qi(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new Qi(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new qi(e)),r.push(new Di({label:"$(clippy) Copy Commit ID to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.shortSha}`},us.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Di({label:"$(clippy) Copy Commit Message to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},us.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Di({label:"$(history) Show File History",description:`${B.pad(G.Dash,2,3)} of ${$e.basename(e.fileName)}`},us.ShowQuickFileHistory,[b.Uri.file($e.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new Di({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${B.pad(G.Dash,2,3)} of ${$e.basename(e.fileName)} ${B.pad(G.Dot,1,1)} from ${G.Space}$(git-commit) ${e.shortSha}`},us.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new Di({label:"$(git-commit) Show Commit Details",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha}`},us.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await ar.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:ar.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Li;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=F.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?Li:new Fi(us.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await ar.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?Li:new Fi(us.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new Fi(us.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new Fi(us.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const u=await ar.keyboard.beginScope({left:i,",":l,".":d}),m=await b.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${B.pad(G.Dot,1,1)} ${h?`Uncommitted ${G.ArrowRightHollow} `:""}${e.shortSha} ${B.pad(G.Dot,1,1)} ${e.author}, ${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`,ignoreFocusOut:Si(),onDidSelectItem:e=>{u.setKeyCommand("right",e)}});return await u.dispose(),m}}class Ji extends Pi{constructor(e,t){const i=Je(t.status),s=Xe.getFormattedDirectory(t,!0);super(Te.toRevisionUri(e.sha,t,e.repoPath),{label:`${B.pad(i,4,2)} ${$e.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):b.commands.executeCommand(us.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class es extends Ti{constructor(e,t=!1,i){const s=e.repoPath;super(w.filterMap(e.fileStatuses,e=>Te.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class ts extends Ti{constructor(e,t){super(w.filterMap(e.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${B.pad(G.Dash,2,3)} in ${G.Space}$(git-commit) ${e.shortSha}`})}}class is{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new Ji(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new Di({label:"$(git-pull-request) Apply Stashed Changes",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},us.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Di({label:"$(x) Delete Stashed Changes",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},us.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Ei(e));else{r.splice(n++,0,new Ei(e));const t=await ar.git.getRemotes(e.repoPath);t.length&&r.splice(n++,0,new Qi(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new es(e)),r.splice(n++,0,new ts(e)),r.splice(n++,0,new Di({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},us.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new Di({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-directory) Working Tree`},us.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new Di({label:"$(clippy) Copy Commit ID to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.shortSha}`},us.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new Di({label:"$(clippy) Copy Commit Message to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`},us.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new Di({label:"Changed Files",description:e.getDiffStatus()},us.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await ar.git.getLog(e.repoPath,{maxCount:ar.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Li:new Fi(us.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await ar.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&F.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Li:new Fi(us.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new Fi(us.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new Fi(us.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await ar.keyboard.beginScope({left:i,",":h,".":c}),d=await b.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${B.pad(G.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getShortMessage(`${G.Space}$(ellipsis)`)}`,ignoreFocusOut:Si(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class ss{static showProgress(e){return _i(e,{left:Li,",":Li,".":Li})}static async show(e,t,i,s){const o=e&&[...F.map(e.commits.values(),e=>new Ri(e))]||[new ki("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await ar.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await b.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Si()});return await r.dispose(),a}}class os{static showProgress(e){return _i(e,{left:Li,",":Li,".":Li})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(F.map(e.commits.values(),e=>new Ri(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new Ni(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await ar.git.findWorkingFileName($e.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new Di({label:"$(history) Show File History",description:`${B.pad(G.Dash,2,3)} of ${$e.basename(i)}`},us.ShowQuickFileHistory,[b.Uri.file($e.resolve(e.repoPath,i)),{goBackCommand:new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},us.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await ar.git.getBranch(t.repoPath);if(void 0!==i){const a=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},us.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new Di({label:"$(history) Show Branch History",description:`${B.pad(G.Dash,2,3)} shows  ${G.Space}$(git-branch) ${i.name} history`},us.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=await ar.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new Qi(n,e,a))}}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await ar.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await b.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Si()});return await a.dispose(),n}}class rs{static async show(){const e=Object.keys(ar.config.modes);if(0===e.length)return;const t=ar.config.mode.active,i=e.map(e=>{const i=ar.config.modes[e];return{label:`${t===e?"$(check)  ":"     "}${i.name} mode`,description:i.description?` ${G.Dash}  ${i.description}`:"",key:e}});return t&&i.splice(0,0,{label:`Exit ${ar.config.modes[t].name} mode`,key:void 0}),await b.window.showQuickPick(i,{placeHolder:"select a GitLens mode to enter"})}}class as{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class ns{static async show(e,t){const i=[...F.map(await ar.git.getRepositories(),e=>new as(e))];return void 0!==t&&i.splice(0,0,t),await b.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Si()})}}class hs extends Pi{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":G.Space.repeat(3)}${B.pad(s,2,2)} ${$e.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new He(Ee.File,e.repoPath,Vt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new He(Ee.File,e.repoPath,Vt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Vt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return b.commands.executeCommand(us.DiffWithPrevious,Te.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class cs extends Di{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},us.OpenChangedFiles,[void 0,{uris:i}])}}class ls{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...F.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new hs(e.with({indexStatus:null}),e.indexStatus),new hs(e.with({workTreeStatus:null}))]:[new hs(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${e.branch} status`},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new Di({label:"Unstaged Files",description:o.unstagedStatus},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new cs(o.stagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new cs(o.unstagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Di({label:"Staged Files",description:o.stagedStatus},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Di({label:"Unstaged Files",description:o.unstagedStatus},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new cs(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Di({label:"$(x) Close Unchanged Files",description:""},us.CloseUnchangedFiles))):i.push(new Di({label:"No changes in the working tree",description:""},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Di({label:"$(inbox) Show Stashed Changes",description:`${B.pad(G.Dash,2,3)} shows stashed changes in the repository`},us.ShowQuickStashList,[Te.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Di({label:`$(cloud-upload)${G.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${G.Space}$(git-branch) ${e.upstream}`,description:`${B.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.branch} but not ${G.Space}$(git-branch) ${e.upstream}`},us.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Di({label:`$(cloud-download)${G.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${G.Space}$(git-branch) ${e.upstream}`,description:`${B.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.upstream} but not ${G.Space}$(git-branch) ${e.branch}${e.sha?` (since ${G.Space}$(git-commit) ${Vt.shortenSha(e.sha)})`:""}`},us.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Di({label:`$(git-branch) ${e.branch} is up-to-date with ${G.Space}$(git-branch) ${e.upstream}`,description:""},us.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await ar.keyboard.beginScope({left:t}),a=await b.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${B.pad(G.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Si(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class ds{static showProgress(e){return _i("apply"===e?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,{left:Li,",":Li,".":Li})}static async show(e,t,i,s,o){const r=e&&Array.from(F.map(e.commits.values(),e=>new Ri(e)))||[];if("list"===t&&r.splice(0,0,new Di({label:"$(plus) Stash Changes",description:`${B.pad(G.Dash,2,3)} stashes all changes`},us.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await ar.keyboard.beginScope({left:s});i.cancel();const n=await b.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,ignoreFocusOut:Si()});return await a.dispose(),n}}var us;function ms(e,t){if(e instanceof b.Uri)return e;if(null==t)return;const i=t.document;return null!=i?i.uri:void 0}async function gs(e,t,i,s){let o=await ar.git.getRepoPathOrActive(e,t);if(!o){const e=await ns.show(i,s);if(e instanceof Di)return void await e.execute();if(void 0===e)return void(void 0!==s&&await s.execute());o=e.repoPath}return o}function ps(e){return"view"===e.type&&e.node.branch instanceof Le}function fs(e){return"view"===e.type&&e.node.commit instanceof Ae}function vs(e){return"view"===e.type&&e.node.remote instanceof Qe}function ws(e){return null!=e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function bs(e){return null!=e&&null!=e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithPreviousInDiff="gitlens.diffWithPreviousInDiff",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowGitExplorer="gitlens.showGitExplorer",e.ShowHistoryExplorer="gitlens.showHistoryExplorer",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowResultsExplorer="gitlens.showResultsExplorer",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.SwitchMode="gitlens.switchMode",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame",e.ToggleReviewMode="gitlens.toggleReviewMode",e.ToggleZenMode="gitlens.toggleZenMode"}(us||(us={}));class Cs extends b.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=b.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>b.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=b.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=Cs.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(null==o||function(e){return null!=e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(null==o||o instanceof b.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof Qt){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(bs(o)){const t=[];let s=0;for(const e of i){if(!bs(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(ws(o)){const t=[];let s=0;for(const e of i){if(!ws(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class ys extends Cs{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,b.window.activeTextEditor,...t)}}let xs=void 0;class $s extends ys{constructor(e){super(e)}_execute(e,...t){return xs={command:e,args:t},super._execute(e,...t)}}class Ss extends b.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(b.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=b.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function _s(e,t={}){const{rethrow:i}=t,s=S.__rest(t,["rethrow"]);try{if(e instanceof Te&&(e=e.fileUri({noSha:!0})),e.scheme===H.GitLensGit){const t=Te.fromRevisionUri(e);if(z.includes($e.extname(t.fsPath))){const i=await ar.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==i)return e=b.Uri.file(i),void await b.commands.executeCommand(M.Open,e)}}const o=await b.workspace.openTextDocument(e);return b.window.showTextDocument(o,Object.assign({preserveFocus:!1,preview:!0,viewColumn:b.ViewColumn.Active},s))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await b.commands.executeCommand(M.Open,e);if(i)throw t;return void ur.error(t,"openEditor")}}class Ds extends Ss{constructor(){super([us.ClearFileAnnotations,us.ComputingFileAnnotations])}async execute(e,t,i){if(null!=e){if(null!=i&&!J.equals(i,e.document.uri)){const t=b.window.visibleTextEditors.find(e=>J.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return ar.fileAnnotations.clear(e)}catch(e){return ur.error(e,"ClearFileAnnotationsCommand"),b.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class ks extends b.Disposable{constructor(){super(()=>this.dispose());const e=k.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=b.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return b.commands.executeCommand(M.CloseActiveEditor)}async next(){return b.commands.executeCommand(M.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=void 0,t(e))}),s=setTimeout(()=>{t(b.window.activeTextEditor),s=void 0},e)});return this._resolver=void 0,t}}class Fs extends ys{constructor(){super(us.CloseUnchangedFiles)}async execute(e,t,i={}){t=ms(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await gs(t,e,`Close unchanged files in which repository${G.Ellipsis}`);if(!s)return;const o=await ar.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to close unchanged files");i.uris=o.files.map(e=>e.uri)}if(0===i.uris.length)return b.commands.executeCommand(M.CloseAllEditors);const s=new ks;let o=0,r=void 0;for(e=b.window.activeTextEditor;;){if(null!=e){if(Z.equals(r,e,{useId:!0,usePosition:!0}))break;if(void 0!==e.document&&(e.document.isDirty||i.uris.some(t=>J.equals(t,e.document&&e.document.uri)))){const t=r;if(r=e,e=await s.awaitNext(500),Z.equals(t,e,{useId:!0,usePosition:!0}))break;continue}}if(r=e,e=await s.awaitClose(500),void 0===r&&null==e){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return ur.error(e,"CloseUnchangedFilesCommand"),b.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Ps extends ys{constructor(){super(us.CopyMessageToClipboard)}async preExecute(e,t={}){return fs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ms(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await ar.git.getActiveRepoPath(e);if(!t)return;const i=await ar.git.getLog(t,{maxCount:1});if(!i)return;s.message=F.first(i.commits.values()).message}else if(void 0===s.message){const i=await Te.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await ar.git.getBlameForLineContents(i,t,e.document.getText()):await ar.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return ur.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const o=await ar.git.getLogCommit(i.repoPath,s.sha);if(void 0===o)return;s.message=o.message}return void o.write(s.message)}catch(e){return ur.error(e,"CopyMessageToClipboardCommand"),b.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class Ts extends ys{constructor(){super(us.CopyShaToClipboard)}async preExecute(e,t={}){return fs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ms(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await ar.git.getActiveRepoPath(e);if(!t)return;const i=await ar.git.getLog(t,{maxCount:1});if(!i)return;s.sha=F.first(i.commits.values()).sha}else if(void 0===s.sha){const i=e&&e.selection.active.line||0;if(i<0)return;try{const o=await Te.fromUri(t),r=e&&e.document&&e.document.isDirty?await ar.git.getBlameForLineContents(o,i,e.document.getText()):await ar.git.getBlameForLine(o,i);if(void 0===r)return;s.sha=r.commit.sha}catch(e){return ur.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${i})`),b.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.write(s.sha)}catch(e){return ur.error(e,"CopyShaToClipboardCommand"),b.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}class Rs extends ys{constructor(){super([us.DiffHeadWithBranch,us.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case us.DiffHeadWithBranch:t.ref2="HEAD";break;case us.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=ms(t,e);try{const o=await gs(t,e,`Compare with branch or tag in which repository${G.Ellipsis}`);if(!o)return;if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${G.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to ${G.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${G.Ellipsis}`}s=Hi.showProgress(e);const[t,r]=await Promise.all([ar.git.getBranches(o),ar.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Hi.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Di)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void ar.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return ur.error(e,"DiffBranchWithBranchCommand"),b.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.cancel()}}}class Es extends ys{constructor(){super([us.DiffDirectory,us.ExternalDiffAll,us.ExplorersOpenDirectoryDiff,us.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case us.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case us.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof Ci&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case us.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof Kt})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=ms(t,e);try{const o=await gs(t,e,`Compare directory in which repository${G.Ellipsis}`);if(!o)return;if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${G.Ellipsis}`;s=Hi.showProgress(e);const[t,r]=await Promise.all([ar.git.getBranches(o),ar.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Hi.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Di)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void ar.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await b.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return b.commands.executeCommand(M.Open,b.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return ur.error(e,"DiffDirectoryCommand"),b.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.cancel()}}}var Bs,As,Ns;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitDisabledWarning="suppressGitDisabledWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice"}(Bs||(Bs={}));class Ls{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Ls.showMessage("info","Commit has no previous commit.",Bs.CommitHasNoPreviousCommitWarning):Ls.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,Bs.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Ls.showMessage("warn",`${e}. The commit could not be found.`,Bs.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Ls.showMessage("warn",`${e}. The file is probably not under source control.`,Bs.FileNotUnderSourceControlWarning)}static showGitDisabledErrorMessage(){return Ls.showMessage("error","GitLens requires Git to be enabled. Please re-enable Git — set `git.enabled` to true and reload",Bs.GitDisabledWarning)}static showGitVersionUnsupportedErrorMessage(e){return Ls.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,Bs.GitVersionWarning)}static async showKeyBindingsInfoMessage(){if(ar.config.advanced.messages.suppressShowKeyBindingsNotice)return;if(ar.config.keymap!==g.Alternate)return void await this.suppressedMessage(Bs.ShowKeyBindingsNotice);const e=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],t=await Ls.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",Bs.ShowKeyBindingsNotice,null,...e);switch(t){case e[1]:await cr.update(cr.name("keymap").value,g.Chorded,b.ConfigurationTarget.Global);break;case e[2]:await cr.update(cr.name("keymap").value,g.None,b.ConfigurationTarget.Global)}return t}static showLineUncommittedWarningMessage(e){return Ls.showMessage("warn",`${e}. The line has uncommitted changes.`,Bs.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Ls.showMessage("warn",`${e}. No repository could be found.`,Bs.NoRepositoryWarning)}static async showMessage(e,t,i,s={title:"Don't Show Again"},...o){if(ur.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),cr.get(cr.name("advanced")("messages")(i).value))return void ur.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await b.window.showInformationMessage(t,...o);break;case"warn":r=await b.window.showWarningMessage(t,...o);break;case"error":r=await b.window.showErrorMessage(t,...o)}return null!==s&&r!==s||(ur.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`),await this.suppressedMessage(i),r!==s)?(ur.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r?r.title:r}`),r):void 0}static suppressedMessage(e){const t=cr.name("advanced")("messages").value,i=cr.get(t);i[e]=!0;for(const[e,t]of Object.entries(i))!0!==t&&(i[e]=void 0);return cr.update(t,i,b.ConfigurationTarget.Global)}}class Us extends ys{constructor(){super(us.DiffLineWithPrevious)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Vt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await ar.git.getBlameForLineContents(s,t,e.document.getText()):await ar.git.getBlameForLine(s,t);if(void 0===o)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await ar.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Vt.stagedUncommittedSha}))}}catch(e){return ur.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Vt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,o)}}class Os extends ys{constructor(){super(us.DiffLineWithWorking)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Vt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await ar.git.getBlameForLineContents(s,t,e.document.getText()):await ar.git.getBlameForLine(s,t);if(void 0===o)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await ar.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Vt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return ur.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,o)}}class Is extends ys{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ae){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Vt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(us.DiffWith,i)}constructor(){super(us.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Vt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await ar.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Vt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await ar.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([ar.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),ar.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=Vt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==Vt.deletedSha||(o="added in ");let r="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(r="not in ",o=""):r="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Vt.deletedSha&&(void 0!==t||""!==r)){const e=Vt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${$e.basename(i.lhs.uri.fsPath)}${""!==e?` (${r}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Vt.deletedSha){const e=Vt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${$e.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${G.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=b.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new b.Range(i.line,0,i.line,0)),await b.commands.executeCommand(M.Diff,void 0===t?Te.toRevisionUri(Vt.deletedSha,i.lhs.uri.fsPath,i.repoPath):b.Uri.file(t),void 0===s?Te.toRevisionUri(Vt.deletedSha,i.rhs.uri.fsPath,i.repoPath):b.Uri.file(s),a,i.showOptions)}catch(e){return ur.error(e,"DiffWithCommand","getVersionedFile"),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Ms extends ys{constructor(){super(us.DiffWithBranch)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t);if(!s.repoPath)return Ls.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${$e.basename(s.fsPath)} with ${G.Ellipsis}`,r=Hi.showProgress(o);try{const[e,t]=await Promise.all([ar.git.getBranches(s.repoPath),ar.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await Hi.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof Di)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await ar.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=B.normalizePath($e.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=b.Uri.file($e.join(s.repoPath,t.originalFileName)),c=`${$e.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${$e.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,d)}finally{r.cancel()}}}class Ws extends ys{constructor(){super(us.DiffWithNext)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof He)||void 0!==i.range)try{const r=void 0===i.commit?s.sha:i.commit.sha;if(Vt.isStagedUncommitted(r)){const e={repoPath:s.repoPath,lhs:{sha:r,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,e)}const a=await ar.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==r?void 0:2,range:i.range,renames:!0});if(void 0===a)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=r&&a.commits.get(r)||F.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await ar.git.getStatusForFile(s.repoPath,s.fsPath)))return b.commands.executeCommand(us.DiffWithWorking,t)}catch(e){return ur.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await ar.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Vt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,e)}return b.commands.executeCommand(us.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,r)}}class Hs extends ys{constructor(){super([us.DiffWithPrevious,us.DiffWithPreviousInDiff])}async preExecute(e,t={}){return e.command===us.DiffWithPreviousInDiff&&(t.inDiffEditor=!0),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Te.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===Vt.deletedSha)return Ls.showCommitHasNoPreviousCommitWarningMessage();let o=!1;Vt.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0),i.inDiffEditor&&void 0!==s&&(s+="^");const r=await ar.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||F.first(r.commits.values()),void 0===e.sha){const s=await ar.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.previousSha||Vt.deletedSha:i.commit.sha,uri:i.inDiffEditor?i.commit.previousUri:i.commit.uri},rhs:{sha:i.inDiffEditor?i.commit.sha:Vt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.sha:Vt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:i.inDiffEditor?Vt.stagedUncommittedSha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,e)}if(!i.inDiffEditor)return b.commands.executeCommand(us.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return ur.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Vt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,s)}}class Gs extends ys{constructor(){super(us.DiffWithRevision)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${B.pad(G.Dot,1,1)} ${s.shortSha}`:""} with ${G.Ellipsis}`,r=os.showProgress(o);try{const a=await ar.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===a)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Di({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},us.DiffWithRevision,[t,Object.assign({},i)]),s=F.last(a.commits.values());null!=s&&(n=new Di({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},us.DiffWithRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await os.show(a,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},us.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Di({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},us.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof Ni){const e=await h.execute();if(void 0===e)return;if(e instanceof Di)return e.execute();c=e.name}else{if(h instanceof Di)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await b.commands.executeCommand(us.DiffWith,l)}catch(e){return ur.error(e,"DiffWithRevisionCommand"),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.cancel()}}}class js extends ys{constructor(){super(us.DiffWithWorking)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Vt.isUncommitted(i.commit.sha)){if(void 0===s.sha)return b.window.showInformationMessage("File matches the working tree");if(Vt.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await ar.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:Vt.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,e)}}try{if(i.commit=await ar.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return ur.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await ar.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(us.DiffWith,r)}}!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(As||(As={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Ns||(Ns={}));class Vs{constructor(e,t){this.uri=e,this.staged=t}}class Qs extends Cs{constructor(){super(us.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new Vs(e.resourceUri,e.resourceGroupType===Ns.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=w.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new Vs(e.resourceUri,e.resourceGroupType===Ns.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===As.BOTH_MODIFIED||t===As.INDEX_MODIFIED||t===As.MODIFIED}async execute(e={}){try{const t=await gs(void 0,void 0,`Open changes from which repository${G.Ellipsis}`);if(!t)return;const i=await ar.git.getDiffTool(t);if(void 0===i){if(!await b.window.showWarningMessage("Unable to open changes in diff tool because there is no Git diff tool configured","View Git Docs"))return;return b.commands.executeCommand(M.Open,b.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await ar.git.getStatusForRepo(t);if(void 0===i)return b.window.showWarningMessage("Unable to open changes in diff tool");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new Vs(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new Vs(t.uri,!1))}for(const s of e.files)ar.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return ur.error(e,"ExternalDiffCommand"),b.window.showErrorMessage("Unable to open changes in diff tool. See output channel for more details")}}}class Ks extends ys{constructor(){super(us.OpenBranchesInRemote)}async preExecute(e,t={}){return vs(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ms(t,e))&&await Te.fromUri(t),o=await gs(s,e,`Open branches in remote for which repository${G.Ellipsis}`);if(o)try{const s=await ar.git.getRemotes(o);return b.commands.executeCommand(us.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return ur.error(e,"OpenBranchesInRemoteCommand"),b.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class zs extends ys{constructor(){super(us.OpenBranchInRemote)}async preExecute(e,t={}){return ps(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ms(t,e))&&await Te.fromUri(t),o=await gs(s,e,`Open branch in remote for which repository${G.Ellipsis}`);if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=(await ar.git.getBranches(o)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await ji.show(e,`Open which branch in remote${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Di)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}const s=await ar.git.getRemotes(o);return b.commands.executeCommand(us.OpenInRemote,t,{resource:{type:"branch",branch:i.branch||"HEAD"},remote:i.remote,remotes:s})}catch(e){return ur.error(e,"OpenBranchInRemoteCommandArgs"),b.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class qs extends ys{constructor(){super(us.OpenChangedFiles)}async execute(e,t,i={}){t=ms(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await gs(t,e,`Open changed files in which repository${G.Ellipsis}`);if(!s)return;const o=await ar.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to open changed files");i.uris=w.filterMap(o.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await _s(e,{preserveFocus:!0,preview:!1});return}catch(e){return ur.error(e,"OpenChangedFilesCommand"),b.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Ys extends ys{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(us.OpenCommitInRemote,t)}constructor(){super(us.OpenCommitInRemote)}async preExecute(e,t={}){return fs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=null==e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await ar.git.getBlameForLineContents(s,t,e.document.getText()):await ar.git.getBlameForLine(s,t);if(void 0===o)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=await ar.git.getRemotes(s.repoPath);return b.commands.executeCommand(us.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return ur.error(e,"OpenCommitInRemoteCommand"),b.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class Xs extends ys{constructor(){super(us.OpenFileInRemote)}async preExecute(e,t={range:!0}){return fs(e)?((t=Object.assign({},t)).range=!1,ps(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await ar.git.getBranch(s.repoPath);if(void 0===e||void 0===e.tracking){const e=(await ar.git.getBranches(s.repoPath)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await ji.show(e,`Open ${s.getRelativePath()} in remote for which branch${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Di)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}else i.branch=e.name}try{const o=await ar.git.getRemotes(s.repoPath),r=i.range&&null!=e?new b.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return b.commands.executeCommand(us.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch||"HEAD",fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return ur.error(e,"OpenFileInRemoteCommand"),b.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class Zs extends ys{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof b.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(us.OpenFileRevision,s)}constructor(){super(us.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=ms(t,e)))return;const o=await Te.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${B.pad(G.Dot,1,1)} ${o.shortSha}`:""} in revision ${G.Ellipsis}`;s=os.showProgress(r);const a=await ar.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Di({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},us.OpenFileRevision,[t,Object.assign({},i)]),s=F.last(a.commits.values());null!=s&&(n=new Di({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},us.OpenFileRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await os.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${G.Space}$(git-commit) ${o.shortSha}`:""}`},us.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Di({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},us.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof Ni){const e=await h.execute();if(void 0===e)return;if(e instanceof Di)return e.execute();i.uri=Te.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Di)return h.execute();i.uri=Te.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new b.Range(i.line,0,i.line,0));const o=await _s(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:ar.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return ur.error(e,"OpenFileRevisionCommand"),b.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.cancel()}}}class Js extends ys{constructor(){super(us.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length)return this.ensureRemoteBranchName(i),new Vi(i.remotes[0],i.resource).execute();let t="";switch(i.resource.type){case te.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${G.Ellipsis}`;break;case te.Commit:t=`open commit ${Vt.shortenSha(i.resource.sha)} in${G.Ellipsis}`;break;case te.File:t=`open ${i.resource.fileName} in${G.Ellipsis}`;break;case te.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof He)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${B.pad(G.Dot,1,1)} ${i.resource.commit.previousShortSha} in${G.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${B.pad(G.Dot,1,1)} ${i.resource.commit.shortSha} in${G.Ellipsis}`);else{const e=void 0===i.resource.sha?"":Vt.shortenSha(i.resource.sha),s=e?` ${B.pad(G.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${G.Ellipsis}`}}if(1===i.remotes.length)return new Vi(i.remotes[0],i.resource).execute();const s=await Ki.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return s.execute()}catch(e){return ur.error(e,"OpenInRemoteCommand"),b.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class eo extends ys{constructor(){super(us.OpenRepoInRemote)}async preExecute(e,t={}){return vs(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ms(t,e))&&await Te.fromUri(t),o=await gs(s,e,`Open which repository in remote${G.Ellipsis}`);if(o)try{const s=await ar.git.getRemotes(o);return b.commands.executeCommand(us.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return ur.error(e,"OpenRepoInRemoteCommand"),b.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class to extends ys{constructor(){super(us.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=ms(t,e)))return;if(i.uri=await Te.fromUri(t),i.uri instanceof Te&&i.uri.sha){const[e,t]=await ar.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Te(b.Uri.file($e.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new b.Range(i.line,0,i.line,0));const s=await _s(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:ar.fileAnnotations.show(s,i.annotationType,i.line)}catch(e){return ur.error(e,"OpenWorkingFileCommand"),b.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class io extends Cs{constructor(){super(us.ResetSuppressedWarnings)}async execute(){await cr.update(cr.name("advanced")("messages").value,void 0,b.ConfigurationTarget.Global)}}const so=/^([@~=:#])/,oo=new Map([["@",Wt.Author],["~",Wt.Changes],["=",Wt.ChangedOccurrences],[":",Wt.Files],["#",Wt.Sha]]);class ro extends $s{constructor(){super(us.ShowCommitSearch)}async execute(e,t,i={}){const s=(t=ms(t,e))&&await Te.fromUri(t),o=await gs(s,e,`Search for commits in which repository${G.Ellipsis}`,i.goBackCommand);if(!o)return;i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&null!=e&&null!=s){const t=await ar.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){ur.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await b.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=so.exec(i.search);t&&t[1]?(i.searchBy=oo.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Vt.isSha(i.search)?i.searchBy=Wt.Sha:i.searchBy=Wt.Message}void 0===i.searchBy&&(i.searchBy=Wt.Message);let a=void 0;switch(i.searchBy){case Wt.Author:a=`commits with an author matching '${i.search}'`;break;case Wt.Changes:a=`commits with changes matching '${i.search}'`;break;case Wt.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Wt.Files:a=`commits with files matching '${i.search}'`;break;case Wt.Message:a=`commits with a message matching '${i.search}'`;break;case Wt.Sha:a=`commits with an id matching '${i.search}'`}const n=ss.showProgress(a);try{const s=await ar.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to commit search`},us.ShowCommitSearch,[t,r]),c=await ss.show(s,a,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new Di({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},us.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new Ai(s,a):void 0});if(void 0===c)return;return c instanceof Di?c.execute():b.commands.executeCommand(us.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,2)} to search for ${a}`},us.ShowCommitSearch,[t,i])})}catch(e){return ur.error(e,"ShowCommitSearchCommand"),b.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.cancel()}}}class ao extends Cs{constructor(){super(us.ShowGitExplorer)}execute(){return ar.gitExplorer.show(d.Repository)}}class no extends Cs{constructor(){super(us.ShowHistoryExplorer)}execute(){return ar.config.historyExplorer.enabled?ar.historyExplorer.show():ar.gitExplorer.show(d.History)}}class ho extends Cs{constructor(){super(us.ShowLastQuickPick)}async execute(){const e=xs;if(void 0!==e)try{return b.commands.executeCommand(e.command,...e.args)}catch(e){return ur.error(e,"ShowLastQuickPickCommand"),b.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class co extends $s{constructor(){super(us.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=ms(t,e))&&await Te.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:zi.showProgress(i.branch);try{const r=i.repoPath||await gs(s,e,`Show branch history in which repository${G.Ellipsis}`);if(!r)return;if(void 0===i.branch){const s=await ar.git.getBranches(r);let a;await ar.git.getRepoPathOrActive(t,e)||(a=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to which repository`},us.ShowQuickBranchHistory,[t,i]));const n=await ji.show(s,`Show history for branch${G.Ellipsis}`,{goBackCommand:a});if(void 0===n)return;if(n instanceof Di)return n.execute();if(i.branch=n.branch.name,void 0===i.branch)return;o=zi.showProgress(i.branch)}if(void 0===i.log&&(i.log=await ar.git.getLog(r,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return b.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await zi.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof Di)return a.execute();const n=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i.branch} history`},us.ShowQuickBranchHistory,[t,Object.assign({},i)]);return b.commands.executeCommand(us.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:n})}catch(e){return ur.error(e,"ShowQuickBranchHistoryCommand"),b.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.cancel()}}}class lo extends $s{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(us.ShowQuickCommitDetails,t)}constructor(){super(us.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,fs(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;const s=await Te.fromUri(t);let o=s.repoPath,r=$e.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await ar.git.getBlameForLine(s,t);if(void 0===a)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(a.commit.isUncommitted)return Ls.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=a.commit.sha,o=a.commit.repoPath,r=a.commit.fileName,i.commit=a.commit}catch(e){return ur.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await ar.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Ls.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Ls.showCommitNotFoundWarningMessage("Unable to show commit details");if(void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand){const e=await ar.git.getBranch(i.commit.repoPath);void 0!==e&&(i.goBackCommand=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${e.name} history`},us.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]))}const s=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${i.commit.shortSha}`},us.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),a=await is.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===a)return;return a instanceof Ji?b.commands.executeCommand(us.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.sha,goBackCommand:s}):a.execute()}catch(e){return ur.error(e,"ShowQuickCommitDetailsCommand"),b.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class uo extends $s{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(us.ShowQuickCommitFileDetails,t)}constructor(){super(us.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,fs(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await ar.git.getBlameForLine(o,t);if(void 0===r)return Ls.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(r.commit.isUncommitted)return Ls.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=r.commit.sha,i.commit=r.commit,s=$e.relative(i.commit.repoPath,o.fsPath)}catch(e){return ur.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await ar.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Ls.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Ls.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await ar.git.findWorkingFileName(i.commit);const r=Vt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${r}`},us.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(file-text) ${$e.basename(i.commit.fileName)} in ${G.Space}$(git-commit) ${r}`},us.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await Zi.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===n)return;return n instanceof Di?n.execute():void 0}catch(e){return ur.error(e,"ShowQuickCommitFileDetailsCommand"),b.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class mo extends $s{constructor(){super(us.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=ms(t,e);try{const s=await gs(t,e,`Show current branch history for which repository${G.Ellipsis}`);if(!s)return;const o=await ar.git.getBranch(s);if(void 0===o)return;return b.commands.executeCommand(us.ShowQuickBranchHistory,t,{branch:o.name,repoPath:s,goBackCommand:i.goBackCommand})}catch(e){return ur.error(e,"ShowQuickCurrentBranchHistoryCommand"),b.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class go extends $s{constructor(){super(us.ShowQuickFileHistory)}async execute(e,t,i={}){if(null==(t=ms(t,e)))return b.commands.executeCommand(us.ShowQuickCurrentBranchHistory);const s=await Te.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${B.pad(G.Dot,1,1)} ${s.shortSha}`:""}`,r=os.showProgress(o);try{if(void 0===i.log&&(i.log=await ar.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Ls.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let a=void 0;if(i.log.truncated){const e=new Di({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${i.log.maxCount} newer commits`},us.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=F.last(i.log.commits.values());null!=o&&(a=new Di({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${i.log.maxCount} older commits`},us.ShowQuickFileHistory,[new Te(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await os.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==i.log&&i.log.truncated?new Di({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},us.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Bi(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof Di)return n.execute();const h=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(n.commit.fileName)}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},us.ShowQuickFileHistory,[t,i]);return b.commands.executeCommand(us.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return ur.error(e,"ShowQuickFileHistoryCommand"),b.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.cancel()}}}class po extends $s{constructor(){super(us.ShowQuickRepoStatus)}async execute(e,t,i={}){t=ms(t,e);try{const s=await gs(t,e,`Show status for which repository${G.Ellipsis}`);if(!s)return;const o=await ar.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to show repository status");const r=await ls.show(o,i.goBackCommand);if(void 0===r)return;return r instanceof Di?r.execute():void 0}catch(e){return ur.error(e,"ShowQuickRepoStatusCommand"),b.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class fo extends $s{constructor(){super(us.ShowQuickStashList)}async execute(e,t,i={}){t=ms(t,e);const s=ds.showProgress("list");try{const o=await gs(t,e,`Show stashed changes for which repository${G.Ellipsis}`);if(!o)return;const r=await ar.git.getStashList(o);if(void 0===r)return b.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to stashed changes`},us.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await ds.show(r,"list",s,i.goBackCommand,a);if(void 0===n)return;return n instanceof Di?n.execute():b.commands.executeCommand(us.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:a})}catch(e){return ur.error(e,"ShowQuickStashListCommand"),b.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.cancel()}}}class vo extends Cs{constructor(){super(us.ShowResultsExplorer)}execute(){return ar.resultsExplorer.show()}}class wo extends Cs{constructor(){super(us.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return fs(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await ar.git.getActiveRepoPath();if(!i){const s=await ns.show(`Apply stashed changes from which repository${G.Ellipsis}`,e.goBackCommand);if(s instanceof Di)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to pick another repository`},us.StashApply,[e]),i=s.repoPath}const s=ds.showProgress("apply");try{const o=await ar.git.getStashList(i);if(void 0===o)return b.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new Di({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to apply stashed changes`},us.StashApply,[e]),a=await ds.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof Di)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.cancel()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await b.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await ar.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return ur.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?b.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?b.window.showInformationMessage("Stash applied with conflicts"):b.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class bo extends Cs{constructor(){super(us.StashDelete)}async preExecute(e,t={confirm:!0}){return fs(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await b.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await ar.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return ur.error(e,"StashDeleteCommand"),b.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class Co extends Cs{constructor(){super(us.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await ar.git.getHighlanderRepoPath();if(!t){const i=await ns.show(`Stash changes for which repository${G.Ellipsis}`,e.goBackCommand);if(i instanceof Di)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await b.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await ar.git.stashSave(t,e.message,e.uris)}catch(e){ur.error(e,"StashSaveCommand");const t=e&&e.message;return t.includes("newer version of Git")?b.window.showErrorMessage(`Unable to save stash. ${t}`):b.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class yo extends Cs{constructor(){super(us.SwitchMode)}async execute(){const e=await rs.show();void 0!==e&&await cr.update(cr.name("mode")("active").value,e.key,b.ConfigurationTarget.Global)}}class xo extends Cs{constructor(){super(us.ToggleReviewMode)}async execute(){if(!Object.keys(ar.config.modes).includes("review"))return;const e="review"===ar.config.mode.active?void 0:"review";await cr.update(cr.name("mode")("active").value,e,b.ConfigurationTarget.Global)}}class $o extends Cs{constructor(){super(us.ToggleZenMode)}async execute(){if(!Object.keys(ar.config.modes).includes("zen"))return;const e="zen"===ar.config.mode.active?void 0:"zen";await cr.update(cr.name("mode")("active").value,e,b.ConfigurationTarget.Global)}}class So extends Cs{constructor(){super(us.ToggleCodeLens)}execute(){return ar.codeLens.toggleCodeLens()}}class _o extends ys{constructor(){super(us.ToggleFileBlame)}async execute(e,t,i={}){if(null!=e&&null!=t&&!J.equals(t,e.document.uri)){const i=b.window.visibleTextEditors.find(e=>J.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:l.Blame})),ar.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return ur.error(e,"ToggleFileBlameCommand"),b.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Do extends ys{constructor(){super(us.ToggleFileHeatmap)}async execute(e,t){b.commands.executeCommand(us.ToggleFileBlame,t,{type:l.Heatmap})}}class ko extends ys{constructor(){super(us.ToggleFileRecentChanges)}async execute(e,t){b.commands.executeCommand(us.ToggleFileBlame,t,{type:l.RecentChanges})}}class Fo extends ys{constructor(){super(us.ToggleLineBlame)}async execute(e,t){try{return ar.lineAnnotations.toggle(e)}catch(e){return ur.error(e,"ToggleLineBlameCommand"),b.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const Po=/[`\>\#\*\_\-\+\.]/g;class To{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=$.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${G.MuchGreaterThan}\`](${Is.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===l.RecentChanges&&(i=l.Blame);const t=Te.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${G.SquareWithTopShadow}\`](${Zs.getMarkdownCommandArgs(t,i||l.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${G.ArrowUpRight}\`](${Ys.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${G.MiddleEllipsis}\`](${uo.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",a="",n="";if(e.isUncommitted)n=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{a=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${lo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=e.message;for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(Po,"\\$&").replace(/^===/gm,`${G.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}const h=new b.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(ar.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${a}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&Vt.isStagedUncommitted(t.sha)?`[\`Changes\`](${Is.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${lo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Is.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; _uncommitted changes_\n${s}`:`[\`Changes\`](${Is.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${lo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} [\`${e.shortSha}\`](${lo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new b.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Vt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await ar.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=It.fromTemplate(t,e,i);return o.renderOptions.before.contentText=B.pad(r.replace(/ /g,G.Space),1,1),o}static gutterRenderOptions(e,t,i,s){let o=0;for(const e of v.values(s.tokenOptions))if(void 0!==e){if(null==e.truncateTo){o=-1;break}o+=e.truncateTo}o>=0&&(o+=B.width(B.interpolate(i,void 0)))>0&&(o+=3);let r=void 0,a=void 0;return t.enabled&&(r="solid",a="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new b.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:r,borderWidth:a,color:new b.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:o>=0?`${o}ch`:void 0,uncommittedColor:new b.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return To.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:G.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,s=!0){const o=It.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new b.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new b.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:B.pad(o.replace(/ /g,G.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${s?"":" position: absolute;"}`}}}}}class Ro extends ie{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?ar.git.getBlameForFileContents(this._uri,e.document.getText()):ar.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?ar.git.getBlameForFileContents(this._uri,this.editor.document.getText()):ar.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=F.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=w.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new b.Range(e.line,0,e.line,Number.MAX_SAFE_INTEGER)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!ar.config.hovers.enabled||!ar.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(b.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(b.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=b.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await ar.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=To.getHoverMessage(o||s,ar.config.defaultDateFormat,await ar.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new b.Hover(r,e.validateRange(new b.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await To.changesHover(s,t.line,await Te.fromUri(e.uri));return void 0!==o.hoverMessage?new b.Hover(o.hoverMessage,e.validateRange(new b.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER))):void 0}async getCommitForHover(e){if("line"!==ar.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Eo extends Ro{async onProvideAnnotation(e,t){this.annotationType=l.Blame;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=ar.config.blame,r=B.getTokensFromTemplate(o.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),a={dateFormat:null===o.dateFormat?ar.config.defaultDateFormat:o.dateFormat,tokenOptions:r},n=Date.now(),h=o.avatars,c=ar.config.defaultGravatarsStyle,d=o.separateLines,u=To.gutterRenderOptions(d,o.heatmap,o.format,a);this.decorations=[];const m=Object.create(null),g=h?Object.create(null):void 0;let p,f,w,C=!1;for(const e of i.lines){const t=e.line;w!==e.sha?(C=!1,w=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=m[e.sha])?(f=To.gutter(p,o.format,a,u),o.heatmap.enabled&&To.applyHeatmap(f,p.date,n),f.range=new b.Range(t,0,t,0),this.decorations.push(f),h&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,c,g),m[e.sha]=f):(f=Object.assign({},f,{range:new b.Range(t,0,t,0)}),this.decorations.push(f),h&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,c,g)))):(f=Object.assign({},f),o.compact&&!C&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:G.Space.repeat(B.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),C=!0),f.range=new b.Range(t,0,t,0),this.decorations.push(f),h&&!o.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,c,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),h)){this.additionalDecorations=[];for(const e of v.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const y=process.hrtime(s);return ur.log(`${1e3*y[0]+Math.floor(y[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(ar.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:b.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class Bo extends Ro{async onProvideAnnotation(e,t){this.annotationType=l.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),r=To.heatmapRenderOptions();this.decorations=[];const a=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=a[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=To.heatmap(n,o,r)).range=new b.Range(t,0,t,0),this.decorations.push(h),a[e.sha]=h):(h=Object.assign({},h,{range:new b.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return ur.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(ar.config.hovers.annotations),this.selection(e,i),!0}}class Ao extends ie{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=l.RecentChanges;const t=await ar.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await ar.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=ar.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new b.Range(new b.Position(i,0),new b.Position(i,Number.MAX_SAFE_INTEGER)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:To.getHoverMessage(t,r,await ar.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&void 0===(a=To.getHoverDiffMessage(t,this._uri,s)))||this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const a=process.hrtime(s);return ur.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var No;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(No||(No={}));const Lo={blameAnnotation:b.window.createTextEditorDecorationType({rangeBehavior:b.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:b.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class Uo extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new b.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Lo.blameAnnotation&&Lo.blameAnnotation.dispose(),Lo.blameHighlight&&Lo.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=cr.initializing(e),i=ar.config;if(t||cr.changed(e,cr.name("blame")("highlight").value)){Lo.blameHighlight&&Lo.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Lo.blameHighlight=b.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:b.OverviewRulerLane.Right,backgroundColor:e.locations.includes(m.Line)?new b.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(m.Overview)?new b.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(m.Gutter)?ar.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(m.Gutter)?ar.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Lo.blameHighlight=void 0}if(t||cr.changed(e,cr.name("recentChanges")("highlight").value)){Lo.recentChangesAnnotation&&Lo.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Lo.recentChangesAnnotation=b.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:b.OverviewRulerLane.Right,backgroundColor:e.locations.includes(m.Line)?new b.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(m.Overview)?new b.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(m.Gutter)?ar.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(m.Gutter)?ar.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||cr.changed(e,cr.name("blame")("toggleMode").value))&&(this._toggleModes.set(l.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==s.File||this.clearAll()),(t||cr.changed(e,cr.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(l.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==s.File||this.clearAll()),(t||cr.changed(e,cr.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(l.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==s.File||this.clearAll()),!t&&(cr.changed(e,cr.name("blame").value)||cr.changed(e,cr.name("recentChanges").value)||cr.changed(e,cr.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===l.RecentChanges?e.reset({decoration:Lo.recentChangesAnnotation,highlightDecoration:Lo.recentChangesHighlight}):e.annotationType===l.Blame?e.reset({decoration:Lo.blameAnnotation,highlightDecoration:Lo.blameHighlight}):this.show(e.editor,l.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!K(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(V(W.AnnotationStatus,void 0),this.detachKeyboardHook()):(V(W.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=b.window.activeTextEditor;void 0!==t&&this.clear(t,No.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,No.DocumentChanged)}onTextDocumentClosed(e){if(ar.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,No.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=F.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,No.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===s.Window}getToggleMode(e){return void 0===e?s.File:this._toggleModes.get(e)||s.File}clear(e,t=No.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(ie.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,No.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await ar.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(ie.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===s.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of b.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await ar.tracker.getOrAdd(e.document)).isBlameable)return!1;const o=this.getProvider(e);return void 0!==o&&o.annotationType===t?(await o.selection(i),!0):void 0!==await b.window.withProgress({location:b.ProgressLocation.Window},async s=>{await V(W.AnnotationStatus,ee.Computing);const r=this.showAnnotationsCore(o,e,t,i,s),a=await r;return e===this._editor&&await V(W.AnnotationStatus,a&&a.status),r})}async toggle(e,t,i){if(void 0!==e){const i=await ar.tracker.getOrAdd(e.document);if(t===l.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,No.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await ar.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,No.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(ur.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==ie.getCorrelationKey(this._editor)||(await V(W.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(ur.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case l.Blame:e="blame annotations";break;case l.Heatmap:e="heatmap annotations";break;case l.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${$e.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await ar.tracker.getOrAdd(t.document);let a=void 0;switch(i){case l.Blame:a=new Eo(t,r,Lo.blameAnnotation,Lo.blameHighlight);break;case l.Heatmap:a=new Bo(t,r,Lo.heatmapAnnotation,Lo.heatmapHighlight);break;case l.RecentChanges:a=new Ao(t,r,Lo.recentChangesAnnotation,Lo.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,No.User),this._annotationsDisposable||0!==this._annotationProviders.size||(ur.log("Add listener registrations for annotations"),this._annotationsDisposable=b.Disposable.from(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,50),this),b.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleTextEditorsChanged,50),this),b.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),ar.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),ar.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class Oo extends b.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class Io extends b.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class Mo{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new b.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=ar.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=cr.get(cr.name("codeLens").value,e.uri);let a=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==a?a={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}:(void 0===a.scopes&&(a.scopes=o.scopes),void 0===a.symbolScopes&&(a.symbolScopes=o.symbolScopes)),a.symbolScopes=null!=a.symbolScopes?a.symbolScopes=a.symbolScopes.map(e=>e.toLowerCase()):[];const n=[],h=i.uri;let c,l;if(s)1===a.scopes.length&&a.scopes.includes(r.Document)||(l=await b.commands.executeCommand(M.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return n;if(1===a.scopes.length&&a.scopes.includes(r.Document)?c=e.isDirty?await this._git.getBlameForFileContents(h,e.getText()):await this._git.getBlameForFile(h):[c,l]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(h,e.getText()):this._git.getBlameForFile(h),b.commands.executeCommand(M.ExecuteDocumentSymbolProvider,e.uri)]),void 0===c||0===c.lines.length)return n}if(t.isCancellationRequested)return n;const d=k.once(()=>e.validateRange(new b.Range(0,1e6,1e6,1e6))),u=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==l&&(ur.log("GitCodeLensProvider.provideCodeLenses:",`${l.length} symbol(s) found`),l.forEach(t=>this.provideCodeLens(n,e,t,a,d,c,h,o,s,u))),(a.scopes.includes(r.Document)||a.symbolScopes.includes("file"))&&!a.symbolScopes.includes("!file")&&!n.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=d();let t=void 0;if(s||o.recentChange.enabled){s||(t=k.once(()=>this._git.getBlameForRangeSync(c,h,e)));const i=new b.SymbolInformation(h.getFilename(),b.SymbolKind.File,"",new b.Location(h.fileUri(),new b.Range(0,0,0,e.start.character)));n.push(new Oo(i,h,t,e,!0,i.location.range,o.recentChange.command,u))}if(!s&&o.authors.enabled){void 0===t&&(t=k.once(()=>this._git.getBlameForRangeSync(c,h,e)));const i=new b.SymbolInformation(h.getFilename(),b.SymbolKind.File,"",new b.Location(h.fileUri(),new b.Range(0,1,0,e.start.character)));n.push(new Io(i,h,t,e,!0,i.location.range,o.authors.command))}}return n}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const a=b.SymbolKind[e.kind].toLowerCase();switch(e.kind){case b.SymbolKind.File:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&(s=i());break;case b.SymbolKind.Package:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case b.SymbolKind.Class:case b.SymbolKind.Interface:case b.SymbolKind.Module:case b.SymbolKind.Namespace:case b.SymbolKind.Struct:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;case b.SymbolKind.Constructor:case b.SymbolKind.Enum:case b.SymbolKind.Function:case b.SymbolKind.Method:(t.scopes.includes(r.Blocks)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;default:t.symbolScopes.includes(a)&&(o=!t.symbolScopes.includes(`!${a}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let u,m=0;if((h||n.recentChange.enabled)&&(h||(u=k.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Oo(i,a,u,l,!1,d.range.with(new b.Position(d.range.start.line,m)),n.recentChange.command,c)),m++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case b.SymbolKind.File:break;case b.SymbolKind.Package:case b.SymbolKind.Module:case b.SymbolKind.Namespace:case b.SymbolKind.Class:case b.SymbolKind.Interface:case b.SymbolKind.Constructor:case b.SymbolKind.Method:case b.SymbolKind.Function:case b.SymbolKind.Enum:s=!0}s&&!h&&(void 0===u&&(u=k.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Io(i,a,u,l,!1,d.range.with(new b.Position(d.range.start.line,m)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof Oo?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Io?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=F.first(i.commits.values());let r=`${s.author}, ${s.formattedDate}`;switch(ar.config.debug&&(r+=` [${b.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case o.DiffWithPrevious:return this.applyDiffWithPreviousCommand(r,e,i,s);case o.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(r,e,i,s);case o.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(r,e,i,s);case o.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(r,e,i,s);case o.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(r,e,i,s);case o.ToggleFileBlame:return this.applyToggleFileBlameCommand(r,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let r=`${s} ${s>1?"authors":"author"} (${F.first(i.authors.values()).name}${s>1?" and others":""})`;switch(ar.config.debug&&(r+=` [${b.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${F.join(F.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case o.DiffWithPrevious:return this.applyDiffWithPreviousCommand(r,e,i);case o.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(r,e,i);case o.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(r,e,i);case o.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(r,e,i);case o.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(r,e,i);case o.ToggleFileBlame:return this.applyToggleFileBlameCommand(r,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:us.DiffWithPrevious,arguments:[b.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":o.ShowQuickCommitDetails,arguments:[b.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":o.ShowQuickCommitFileDetails,arguments:[b.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:o.ShowQuickCurrentBranchHistory,arguments:[b.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:o.ShowQuickFileHistory,arguments:[b.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:us.ToggleFileBlame,arguments:[b.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?ar.config.strings.codeLens.unsavedChanges.recentChangeAndAuthors:e.recentChange.enabled?ar.config.strings.codeLens.unsavedChanges.recentChangeOnly:ar.config.strings.codeLens.unsavedChanges.authorsOnly}}Mo.selector=[{scheme:H.File},{scheme:H.Git},{scheme:H.GitLensGit}];class Wo extends b.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=cr.initializing(e),i=cr.name("codeLens").value;if(t||cr.changed(e,i,null)||cr.changed(e,cr.name("defaultDateStyle").value)||cr.changed(e,cr.name("defaultDateFormat").value)){t||ur.log("CodeLens config changed; resetting CodeLens provider");const e=ar.config.codeLens;e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,V(W.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(ur.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=ar.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||(ur.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(ur.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new Mo(ar.context,ar.git,ar.tracker),this._providerDisposable=b.Disposable.from(b.languages.registerCodeLensProvider(Mo.selector,this._provider),ar.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),ar.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}const Ho=b.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:b.DecorationRangeBehavior.ClosedOpen});class Go extends b.Disposable{constructor(){super(()=>this.dispose()),this._enabled=!1,this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this),ar.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),b.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),ar.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=cr.initializing(e);(t||cr.changed(e,cr.name("currentLine").value))&&((t||cr.changed(e,cr.name("currentLine")("enabled").value))&&(ar.config.currentLine.enabled?(this._enabled=!0,this.resume()):(this._enabled=!1,this.setLineTracker(!1))),this.refresh(b.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(this.setLineTracker(!0),e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return this.setLineTracker(!1),"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=b.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(b.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(b.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(b.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Ho,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=ar.lineTracker.lines;if(void 0===e||void 0===t||!K(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=ar.config.currentLine;if(this.suspended)return this.clear(e);if(!(await ar.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!ar.lineTracker.includesAll(t))return;const s=ar.config.currentLine.scrollable,o=[];for(const r of t){const t=ar.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const a=To.trailing(t.commit,i.format,null===i.dateFormat?ar.config.defaultDateFormat:i.dateFormat,s);a.range=e.document.validateRange(new b.Range(r,Number.MAX_SAFE_INTEGER,r,Number.MAX_SAFE_INTEGER)),o.push(a)}e.setDecorations(Ho,o)}setLineTracker(e){e?ar.lineTracker.isSubscribed(this)||ar.lineTracker.start(this,b.Disposable.from(ar.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))):ar.lineTracker.stop(this)}}class jo extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this),b.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),ar.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){(cr.initializing(e)||cr.changed(e,cr.name("hovers")("enabled").value)||cr.changed(e,cr.name("hovers")("currentLine")("enabled").value))&&(ar.config.hovers.enabled&&ar.config.hovers.currentLine.enabled?(ar.lineTracker.start(this,b.Disposable.from(ar.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(b.window.activeTextEditor)):(ar.lineTracker.stop(this),this.unregister()))}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=b.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!ar.lineTracker.includes(t.line))return;const s=ar.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const r=await ar.fileAnnotations.getAnnotationType(b.window.activeTextEditor);if(void 0!==r&&ar.config.hovers.annotations.details)return;const a=!this.debugging&&"line"===ar.config.hovers.currentLine.over;if(!a&&ar.lineAnnotations.suspended)return;const n=e.validateRange(new b.Range(t.line,a?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!a&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await ar.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await ar.tracker.get(e))return;const c=To.getHoverMessage(h||o,ar.config.defaultDateFormat,await ar.git.getRemotes(o.repoPath),r,t.line);return new b.Hover(c,n)}async provideChangesHover(e,t,i){if(!ar.lineTracker.includes(t.line))return;const s=ar.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(ar.config.hovers.annotations.changes&&void 0!==await ar.fileAnnotations.getAnnotationType(b.window.activeTextEditor))return;const r=!this.debugging&&"line"===ar.config.hovers.currentLine.over;if(!r&&ar.lineAnnotations.suspended)return;const a=e.validateRange(new b.Range(t.line,r?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!r&&a.start.character!==t.character)return;const n=await ar.tracker.get(e);if(void 0===n)return;const h=await To.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new b.Hover(h.hoverMessage,a):void 0}register(e){if(this.unregister(),void 0===e)return;const t=ar.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(b.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(b.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=b.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}class Vo extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new b.EventEmitter,this._onDidChangeTreeData=new b.EventEmitter,ar.explorerCommands,b.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),b.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(c.Auto),this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(c.List),this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(c.Tree),this),b.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(ar.config.gitExplorer.autoRefresh,!0),this),b.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(ar.config.gitExplorer.autoRefresh,!1),this),b.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>Vo.setRenameFollowing(!0),this),b.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>Vo.setRenameFollowing(!1),this),b.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(d.History),this),b.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(d.Repository),this),b.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),ar.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleEditorsChanged,500),this),cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=cr.initializing(e);if(!(t||cr.changed(e,cr.name("gitExplorer").value)||cr.changed(e,cr.name("explorers").value)||cr.changed(e,cr.name("defaultGravatarsStyle").value)||cr.changed(e,cr.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||cr.changed(e,cr.name("gitExplorer")("enabled").value)||cr.changed(e,cr.name("gitExplorer")("location").value))&&V(W.GitExplorer,!!this.config.enabled&&this.config.location),(t||cr.changed(e,cr.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(ar.config.gitExplorer.autoRefresh);let i=this.view;if((t||cr.changed(e,cr.name("gitExplorer")("view").value))&&(i=this.config.view)===d.Auto&&(i=ar.context.workspaceState.get(q.GitExplorerView,d.Repository)),t&&(this.view=i,V(W.GitExplorerView,this.view),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),t||cr.changed(e,cr.name("gitExplorer")("location").value))return this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.gitExplorer:${this.config.location}`,{treeDataProvider:this}),void(this._disposable=this._tree);this.reset(i,cr.changed(e,cr.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==d.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Ht.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===d.Repository&&(this.clearRoot(),ur.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(Ht.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===d.History&&(0!==e.length&&e.some(e=>e.document&&ar.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Ht.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&ar.context.workspaceState.get(q.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},ar.config.explorers,ar.config.gitExplorer)}get view(){return this._view}set view(e){this._view=ar.config.historyExplorer.enabled?d.Repository:e}getParent(e){}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this.view===d.History?[new zt(`No active file ${G.Dash} no history to show`)]:[new zt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Ht.Command),ur.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===d.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),void 0!==this._root&&this._root.refresh(),this._onDidChangeTreeData.fire()}refreshNode(e,t){ur.log(`GitExplorer[view=${this.view}].refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){if(this.setView(e),t&&void 0!==this._root&&this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))||t)return this.refresh(Ht.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=ar.context.workspaceState.get(q.GitExplorerAutoRefresh,!0):(i=t,await ar.context.workspaceState.update(q.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=ar.git.onDidChangeRepositories(this.onRepositoriesChanged,this),ar.context.subscriptions.push(this._autoRefreshDisposable))),V(W.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Ht.AutoRefreshChanged)}setView(e){this.view!==e&&(ar.config.gitExplorer.view===d.Auto&&ar.context.workspaceState.update(q.GitExplorerView,e),this.view=e,V(W.GitExplorerView,this.view),e!==d.Repository&&ar.git.stopWatchingFileSystem())}async show(e){if(void 0===this._root||void 0===this._tree)return;await this.switchTo(e);const[t]=await this._root.getChildren();try{await this._tree.reveal(t,{select:!1})}catch(e){ur.error(e)}}async switchTo(e){return this.view!==e&&(await this.reset(e,!0),!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case d.History:{const t=this.getHistoryNode(e||b.window.activeTextEditor);return this._loading=t.then(e=>k.wait(0)),t}default:{const e=ar.git.getRepositories();this._loading=e.then(e=>k.wait(0));const t=[...await e];if(0===t.length)return;const i=t.filter(e=>!e.closed);if(0===i.length)return;if(1===i.length){const e=i[0];return new gi(Te.fromRepoPath(e.path),e,this,!0)}return new $i(i,this)}}}async getHistoryNode(e){return Vo.getHistoryNode(this,e,this._root)}async setFilesLayout(e){return cr.update(cr.name("gitExplorer")("files")("layout").value,e,b.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}async undockHistory(e=!0){ar.historyExplorer.undock(e)}static async getHistoryNode(e,t,i){if(null==t||0===b.window.visibleTextEditors.length||!b.window.visibleTextEditors.some(e=>e.document&&ar.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!ar.git.isTrackable(t.document.uri))return i;const s=await Te.fromUri(t.document.uri),o=await ar.git.getRepository(s);return void 0!==o?J.equals(s,i&&i.uri)?i:new xi(s,o,e):void 0}static setRenameFollowing(e){cr.updateEffective(cr.name("advanced")("fileHistoryFollowsRenames").value,e)}}class Qo extends b.Disposable{constructor(){super(()=>this.dispose()),b.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),b.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),b.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),b.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),b.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),b.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),b.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),b.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),b.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),b.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),b.commands.registerCommand("gitlens.explorers.closeRepository",this.closeRepository,this),b.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),b.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),b.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),b.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),b.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),b.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),b.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),b.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),b.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),b.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),b.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),b.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),b.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),b.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),b.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),b.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await ar.git.checkoutFile(e.uri),this.openFile(e)}closeRepository(e){(e instanceof gi||e instanceof hi)&&(e.repo.closed=!0)}compareWithHead(e){e instanceof Kt&&ar.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&ar.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof Kt&&ar.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await ar.git.getBranch(e.repoPath);if(void 0===t)return;const i=await ar.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&ar.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${Vt.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof Kt&&this._selection.repoPath===e.repoPath&&ar.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof Kt))return;const t=e instanceof ti?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},V(W.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,b.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return b.commands.executeCommand(us.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return _s(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return _s(t.uri||("D"===e.commit.status?Te.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Te.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Te.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Vt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=w.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Te.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=w.filterMap(e.commit.fileStatuses,e=>Te.fromFileStatus(e,i));for(const e of s)await _s(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=w.filterMap(e.commit.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await _s(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return b.commands.executeCommand(us.DiffWith,o)}async openFileRevisionInRemote(e){return b.commands.executeCommand(us.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof ti&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof Kt))return;let t=!1,i=void 0;e instanceof ti&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await b.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==s&&""!==s&&this.sendTerminalCommand("branch",`${t?"-t ":""}${s} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof ti&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.getRemote()} :${e.branch.getName()}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof ti&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof ti&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof ti){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof ni&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof ti&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof ei&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof ei))return;const t=e.branch||await ar.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof ei&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof ei&&this.sendTerminalCommand("reset",`--soft ${e.ref}`,e.repoPath)}terminalRevertCommit(e){e instanceof ei&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof si&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof Kt))return;const t=await b.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await b.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",s,e.repoPath)}terminalDeleteTag(e){e instanceof ui&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=b.window.createTerminal(I),this._disposable=b.window.onDidCloseTerminal(e=>{e.name===I&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),ar.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class Ko{async provideTextDocumentContent(e,t){const i=Te.fromRevisionUri(e);if(!i.repoPath||i.sha===Vt.deletedSha)return"";try{return await ar.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return ur.error(e,"GitContentProvider","getVersionedFileText"),void b.window.showErrorMessage(`Unable to show Git revision ${Vt.shortenSha(i.sha)} of '${$e.relative(i.repoPath,i.fsPath)}'`)}}}Ko.scheme=H.GitLensGit;class zo extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new b.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||K(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!K(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return zo.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=b.Disposable.from(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,0),this),b.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(b.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=k.debounce(e=>{b.window.activeTextEditor===e.editor&&zo.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{b.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}class qo{constructor(e,t){this.commit=e,this.logCommit=t}}class Yo extends zo{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=ar.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}async resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}async suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}isSubscribed(e){return this._subscriptions.has(e)}start(e,t){this.isSubscribed(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=b.Disposable.from(this._disposable,ar.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),ar.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),ar.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await ar.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await ar.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await ar.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new qo(s.commit))}else{const s=t.document.isDirty?await ar.git.getBlameForFileContents(i.uri,t.document.getText()):await ar.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new qo(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e)||(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),0))}}class Xo extends b.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Zo extends b.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Jo{async provideCodeLenses(e,t){const i=Te.fromRevisionUri(e.uri),s=[],o=await ar.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new Zo(o.previousUri.fsPath,o,new b.Range(0,0,0,1))),s.push(new Xo(o.uri.fsPath,o,new b.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof Xo?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof Zo?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:us.DiffWithWorking,arguments:[b.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:us.DiffWithPrevious,arguments:[b.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}Jo.selector={scheme:H.GitLensGit};class er extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new b.EventEmitter,ar.explorerCommands,b.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),b.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),b.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),b.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>Vo.setRenameFollowing(!0),this),b.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>Vo.setRenameFollowing(!1),this),ar.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleEditorsChanged,500),this),cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=cr.initializing(e);(t||cr.changed(e,cr.name("historyExplorer").value)||cr.changed(e,cr.name("explorers").value)||cr.changed(e,cr.name("defaultGravatarsStyle").value)||cr.changed(e,cr.name("advanced")("fileHistoryFollowsRenames").value))&&((t||cr.changed(e,cr.name("historyExplorer")("enabled").value)||cr.changed(e,cr.name("historyExplorer")("location").value))&&V(W.HistoryExplorer,!!this.config.enabled&&this.config.location),(t||cr.changed(e,cr.name("historyExplorer")("enabled").value))&&(this.config.enabled?this.undock(!t,!cr.changed(e,cr.name("mode").value)):this.dock(!t,!cr.changed(e,cr.name("mode").value))),t&&this.setRoot(await this.getRootNode(b.window.activeTextEditor)),(t||cr.changed(e,cr.name("historyExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.historyExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||void 0!==this._root||this.refresh(Ht.ConfigurationChanged))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Ht.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&ar.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Ht.VisibleEditorsChanged)))}get config(){return Object.assign({},ar.config.explorers,ar.config.historyExplorer)}getParent(e){}async getChildren(e){return void 0===this._root?[new zt(`No active file ${G.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0,t=!0){e&&await ar.gitExplorer.switchTo(d.History),await V(W.HistoryExplorer,!1),t&&await cr.updateEffective(cr.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Ht.Command),ur.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){ur.log(`HistoryExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async show(){if(void 0!==this._root&&void 0!==this._tree)try{await this._tree.reveal(this._root,{select:!1})}catch(e){ur.error(e)}}async undock(e=!0,t=!0){e&&await ar.gitExplorer.switchTo(d.Repository),await V(W.HistoryExplorer,this.config.location),t&&await cr.updateEffective(cr.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){return Vo.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}}class tr extends b.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new b.EventEmitter,this._enabled=!1,ar.explorerCommands,b.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),b.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(c.Auto),this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(c.List),this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(c.Tree),this),b.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),b.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),b.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),b.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),b.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),V(W.ResultsExplorerKeepResults,this.keepResults),ar.context.subscriptions.push(cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=cr.initializing(e);(t||cr.changed(e,cr.name("resultsExplorer").value)||cr.changed(e,cr.name("explorers").value)||cr.changed(e,cr.name("defaultGravatarsStyle").value))&&((t||cr.changed(e,cr.name("resultsExplorer")("location").value))&&V(W.ResultsExplorer,!!this.enabled&&this.config.location),(t||cr.changed(e,cr.name("resultsExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.resultsExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||0===this._roots.length||this.refresh(Ht.ConfigurationChanged))}get config(){return Object.assign({},ar.config.explorers,ar.config.resultsExplorer)}get enabled(){return this._enabled}get keepResults(){return ar.context.workspaceState.get(q.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),this._enabled=!1,V(W.ResultsExplorer,!1)}getParent(e){}async getChildren(e){return 0===this._roots.length?[new zt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Ht.Command),ur.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){ur.log(`ResultsExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){ur.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}async show(){if(void 0!==this._roots&&0!==this._roots.length&&void 0!==this._tree)try{await this._tree.reveal(this._roots[0],{select:!1})}catch(e){ur.error(e)}}showComparisonInResults(e,t,i){this.showResults(this.addResults(new Ci(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)))}showCommitInResults(e){this.showResults(this.addResults(new fi(e,this)))}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.showResults(this.addResults(new vi(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await ar.git.getRepositoryCount()>1){const t=await ar.git.getRepository(e.repoPath);a=` ${B.pad(G.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},k.seeded(i,e),this,Gt.SearchResults)))}async showResults(e){this._enabled=!0,await V(W.ResultsExplorer,this.config.location),setTimeout(()=>this._tree.reveal(e,{select:!0}),250)}addResults(e){return this._roots.includes(e)?e:(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),e)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return cr.update(cr.name("resultsExplorer")("files")("layout").value,e,b.ConfigurationTarget.Global)}setKeepResults(e){ar.context.workspaceState.update(q.ResultsExplorerKeepResults,e),V(W.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof Ci&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class ir extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this),...this.registerCommands())}dispose(){this._disposable&&this._disposable.dispose(),this._disposablePanel&&this._disposablePanel.dispose()}onConfigurationChanged(e){this.postUpdatedConfiguration()}onPanelDisposed(){this._disposablePanel&&this._disposablePanel.dispose(),this._panel=void 0}onViewStateChanged(e){if(ur.log("WebviewEditor.onViewStateChanged",e.webviewPanel.visible),this._invalidateOnVisible&&e.webviewPanel.visible){const e=this._invalidateOnVisible;switch(this._invalidateOnVisible=void 0,e){case"config":this.postUpdatedConfiguration();break;default:this.show()}}}async onMessageReceived(e){if(null!=e)switch(ur.log(`WebviewEditor.onMessageReceived: type=${e.type}, data=${JSON.stringify(e)}`),e.type){case"saveSettings":const t="workspace"===e.scope?b.ConfigurationTarget.Workspace:b.ConfigurationTarget.Global;for(const i in e.changes){const s=await cr.inspect(i),o=e.changes[i];await cr.update(i,o===s.defaultValue?void 0:o,t)}for(const i of e.removes)await cr.update(i,void 0,t)}}get visible(){return void 0!==this._panel&&this._panel.visible}hide(){void 0!==this._panel&&this._panel.dispose()}async show(){let e=(await this.getHtml()).replace(/{{root}}/g,b.Uri.file(ar.context.asAbsolutePath(".")).with({scheme:"vscode-resource"}).toString());e.includes("'{{bootstrap}}'")&&(e=e.replace("'{{bootstrap}}'",JSON.stringify(this.getBootstrap()))),void 0===this._panel?(this._panel=b.window.createWebviewPanel(this.id,this.title,b.ViewColumn.Active,{retainContextWhenHidden:!0,enableFindWidget:!0,enableCommandUris:!0,enableScripts:!0}),this._disposablePanel=b.Disposable.from(this._panel,this._panel.onDidDispose(this.onPanelDisposed,this),this._panel.onDidChangeViewState(this.onViewStateChanged,this),this._panel.webview.onDidReceiveMessage(this.onMessageReceived,this)),this._panel.webview.html=e):(this._panel.webview.html=e,this._panel.reveal(b.ViewColumn.Active))}async getHtml(){return ur.isDebugging?new Promise((e,t)=>{xe.readFile(ar.context.asAbsolutePath(this.filename),"utf8",(i,s)=>{i?t(i):e(s)})}):(await b.workspace.openTextDocument(ar.context.asAbsolutePath(this.filename))).getText()}postMessage(e,t="all"){if(void 0===this._panel)return!1;const i=this._panel.webview.postMessage(e);return i||"all"===this._invalidateOnVisible||(this._invalidateOnVisible=t),i}postUpdatedConfiguration(){return this.postMessage({type:"settingsChanged",config:cr.get()},"config")}}class sr extends ir{constructor(){super()}get filename(){return"settings.html"}get id(){return"gitlens.settings"}get title(){return"GitLens Settings"}getBootstrap(){return{config:cr.get(),scope:"user",scopes:this.getAvailableScopes()}}registerCommands(){return[b.commands.registerCommand("gitlens.showSettingsPage",this.show,this)]}getAvailableScopes(){const e=[["user","User"]];return void 0!==b.workspace.workspaceFolders&&b.workspace.workspaceFolders.length&&e.push(["workspace","Workspace"]),e}}class or extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}dispose(){this.clearBlame(),this._blameStatusBarItem&&this._blameStatusBarItem.dispose(),this._modeStatusBarItem&&this._modeStatusBarItem.dispose(),ar.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=cr.initializing(e);if(t||cr.changed(e,cr.name("mode").value)){const t=ar.config.mode.active&&ar.config.mode.statusBar.enabled?ar.config.modes[ar.config.mode.active]:void 0;if(t&&t.statusBarItemName){const i="left"!==ar.config.mode.statusBar.alignment?b.StatusBarAlignment.Right:b.StatusBarAlignment.Left;cr.changed(e,cr.name("mode")("statusBar")("alignment").value)&&void 0!==this._modeStatusBarItem&&this._modeStatusBarItem.alignment!==i&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0),this._modeStatusBarItem=this._modeStatusBarItem||b.window.createStatusBarItem(i,i===b.StatusBarAlignment.Right?999:1),this._modeStatusBarItem.command=us.SwitchMode,this._modeStatusBarItem.text=t.statusBarItemName,this._modeStatusBarItem.tooltip="Switch GitLens Mode",this._modeStatusBarItem.show()}else void 0!==this._modeStatusBarItem&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0)}if(t||cr.changed(e,cr.name("statusBar").value))if(ar.config.statusBar.enabled){const i="left"!==ar.config.statusBar.alignment?b.StatusBarAlignment.Right:b.StatusBarAlignment.Left;cr.changed(e,cr.name("statusBar")("alignment").value)&&void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.alignment!==i&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0),this._blameStatusBarItem=this._blameStatusBarItem||b.window.createStatusBarItem(i,i===b.StatusBarAlignment.Right?1e3:0),this._blameStatusBarItem.command=ar.config.statusBar.command,(t||cr.changed(e,cr.name("statusBar")("enabled").value))&&ar.lineTracker.start(this,b.Disposable.from(ar.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else cr.changed(e,cr.name("statusBar")("enabled").value)&&(ar.lineTracker.stop(this),void 0!==this._blameStatusBarItem&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0))}onActiveLinesChanged(e){let t=!(ar.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=ar.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateBlame(i.commit,e.editor);t=!0}t&&this.clearBlame()}async clearBlame(){void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.hide()}updateBlame(e,t){const i=ar.config.statusBar;if(i.enabled&&void 0!==this._blameStatusBarItem&&K(t)){switch(this._blameStatusBarItem.text=`$(git-commit) ${It.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?ar.config.defaultDateFormat:i.dateFormat})}`,i.command){case f.ToggleFileBlame:this._blameStatusBarItem.tooltip="Toggle Blame Annotations";break;case f.DiffWithPrevious:this._blameStatusBarItem.command=us.DiffLineWithPrevious,this._blameStatusBarItem.tooltip="Compare Line Revision with Previous";break;case f.DiffWithWorking:this._blameStatusBarItem.command=us.DiffLineWithWorking,this._blameStatusBarItem.tooltip="Compare Line Revision with Working";break;case f.ToggleCodeLens:this._blameStatusBarItem.tooltip="Toggle Git CodeLens";break;case f.ShowQuickCommitDetails:this._blameStatusBarItem.tooltip="Show Commit Details";break;case f.ShowQuickCommitFileDetails:this._blameStatusBarItem.tooltip="Show Line Commit Details";break;case f.ShowQuickFileHistory:this._blameStatusBarItem.tooltip="Show File History";break;case f.ShowQuickCurrentBranchHistory:this._blameStatusBarItem.tooltip="Show Branch History"}this._blameStatusBarItem.show()}}}class rr extends ir{constructor(){super()}get filename(){return"welcome.html"}get id(){return"gitlens.welcome"}get title(){return"Welcome to GitLens"}getBootstrap(){return{config:ar.config}}registerCommands(){return[b.commands.registerCommand("gitlens.showWelcomePage",this.show,this)]}}class ar{static initialize(e,t){if(this._context=e,this._config=ar.applyMode(t),e.subscriptions.push(this._lineTracker=new Yo),e.subscriptions.push(this._tracker=new Ut),e.subscriptions.push(this._git=new Vt),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new Uo),e.subscriptions.push(this._lineAnnotationController=new Go),e.subscriptions.push(this._lineHoverController=new jo),e.subscriptions.push(this._statusBarController=new or),e.subscriptions.push(this._codeLensController=new Wo),e.subscriptions.push(this._keyboard=new Mi),e.subscriptions.push(this._settingsEditor=new sr),e.subscriptions.push(this._welcomeEditor=new rr),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new Vo);else{let t;t=cr.onDidChange(i=>{cr.changed(i,cr.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new Vo))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new er);else{let t;t=cr.onDidChange(i=>{cr.changed(i,cr.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new er))})}e.subscriptions.push(b.workspace.registerTextDocumentContentProvider(Ko.scheme,new Ko)),e.subscriptions.push(b.languages.registerCodeLensProvider(Jo.selector,new Jo))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=ar.applyMode(cr.get())),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new Qo),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new er),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new tr),this._resultsExplorer}static get settingsEditor(){return this._settingsEditor}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static get welcomeEditor(){return this._welcomeEditor}static resetConfig(){this._config=void 0}static applyMode(e){if(!e.mode.active)return e;const t=e.modes[e.mode.active];return null==t?e:(null!=t.codeLens&&(e.codeLens.enabled=t.codeLens),null!=t.currentLine&&(e.currentLine.enabled=t.currentLine),null!=t.explorers&&(e.gitExplorer.enabled=t.explorers),null!=t.explorers&&(e.historyExplorer.enabled=t.explorers),null!=t.hovers&&(e.hovers.enabled=t.hovers),null!=t.statusBar&&(e.statusBar.enabled=t.statusBar),e)}}const nr=new Proxy({},{get:(e,t,i)=>nr});class hr{constructor(){this._onDidChange=new b.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1},this._configAffectedByMode=[`gitlens.${this.name("mode").value}`,`gitlens.${this.name("modes").value}`,`gitlens.${this.name("codeLens").value}`,`gitlens.${this.name("currentLine").value}`,`gitlens.${this.name("gitExplorer").value}`,`gitlens.${this.name("historyExplorer").value}`,`gitlens.${this.name("hovers").value}`,`gitlens.${this.name("statusBar").value}`]}static configure(e){e.subscriptions.push(b.workspace.onDidChangeConfiguration(cr.onConfigurationChanged,cr))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(L,null))return;ar.resetConfig(),cr.changed(e,cr.name("defaultGravatarsStyle").value)&&Re.clear();const t=cr.name("keymap").value;if(cr.changed(e,t)&&V(W.KeyMap,this.get(t)),cr.changed(e,cr.name("mode").value)||cr.changed(e,cr.name("modes").value)){const t=e.affectsConfiguration;e=Object.assign({},e,{affectsConfiguration:(e,i)=>!!this._configAffectedByMode.some(t=>e.startsWith(t))||t(e,i)})}this._onDidChange.fire(e)}get(e,t,i){return void 0===i?b.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e):b.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e,i)}changed(e,t,i){return e.affectsConfiguration(`${L}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return b.workspace.getConfiguration(void 0===e?void 0:L,t).inspect(void 0===e?L:e)}async migrate(e,t,i={}){const s=cr.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,b.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,b.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,b.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,b.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=cr.inspect(e);if(void 0===s)return;const o=cr.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,b.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,b.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,b.ConfigurationTarget.WorkspaceFolder))}name(e){return k.propOf(nr,e)}update(e,t,i,s){return b.workspace.getConfiguration(L,i===b.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await cr.inspect(e,i);if(void 0!==s.workspaceFolderValue){if(s.workspaceFolderValue===t)return;await cr.update(e,t,b.ConfigurationTarget.WorkspaceFolder,i)}else if(void 0!==s.workspaceValue){if(s.workspaceValue===t)return;await cr.update(e,t,b.ConfigurationTarget.Workspace)}else{if(s.globalValue===t||void 0===s.globalValue&&s.defaultValue===t)return;await cr.update(e,t,b.ConfigurationTarget.Global)}}}const cr=new hr,lr=`[${U}]`,dr=/^--inspect(-brk)?=?/;class ur{static configure(e){e.subscriptions.push(cr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(cr.initializingChangeEvent)}static onConfigurationChanged(e){const t=cr.initializing(e),i=cr.name("outputLevel").value;(t||cr.changed(e,i))&&(this.level=cr.get(i),this.level===p.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||b.window.createOutputChannel(U))}static log(e,...t){ur.isDebugging&&console.log(this.timestamp,lr,e,...t),void 0===this.output||this.level!==p.Verbose&&this.level!==p.Debug||this.output.appendLine((ur.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){ur.isDebugging&&console.error(this.timestamp,lr,t,...i,e),void 0!==this.output&&this.level!==p.Silent&&this.output.appendLine((ur.isDebugging?[this.timestamp,t,...i,e]:[t,...i,e]).join(" "))}static warn(e,...t){ur.isDebugging&&console.warn(this.timestamp,lr,e,...t),void 0!==this.output&&this.level!==p.Silent&&this.output.appendLine((ur.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t,i){this.level===p.Debug&&(void 0===this.gitOutput&&(this.gitOutput=b.window.createOutputChannel(`${U} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})${void 0===i?"":`\n\n${i.toString()}`}`))}static get isDebugging(){if(void 0===this._isDebugging){const e=process.execArgv;this._isDebugging=!!e&&e.some(e=>dr.test(e))}return this._isDebugging}}async function mr(e){const t=process.hrtime();ur.configure(e);const i=b.extensions.getExtension(O).packageJSON.version,s=b.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return ur.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),V(W.Enabled,s),void Ls.showGitDisabledErrorMessage();hr.configure(e);const o=e.globalState.get(j.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=A.fromString(t);try{if(1!==A.compare(i,A.from(7,5,10))&&(await cr.migrate("annotations.file.gutter.gravatars",cr.name("blame")("avatars").value),await cr.migrate("annotations.file.gutter.compact",cr.name("blame")("compact").value),await cr.migrate("annotations.file.gutter.dateFormat",cr.name("blame")("dateFormat").value),await cr.migrate("annotations.file.gutter.format",cr.name("blame")("format").value),await cr.migrate("annotations.file.gutter.heatmap.enabled",cr.name("blame")("heatmap")("enabled").value),await cr.migrate("annotations.file.gutter.heatmap.location",cr.name("blame")("heatmap")("location").value),await cr.migrate("annotations.file.gutter.lineHighlight.enabled",cr.name("blame")("highlight")("enabled").value),await cr.migrate("annotations.file.gutter.lineHighlight.locations",cr.name("blame")("highlight")("locations").value),await cr.migrate("annotations.file.gutter.separateLines",cr.name("blame")("separateLines").value),await cr.migrate("codeLens.locations",cr.name("codeLens")("scopes").value),await cr.migrate("codeLens.perLanguageLocations",cr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await cr.migrate("codeLens.customLocationSymbols",cr.name("codeLens")("symbolScopes").value),await cr.migrate("annotations.line.trailing.dateFormat",cr.name("currentLine")("dateFormat").value),await cr.migrate("blame.line.enabled",cr.name("currentLine")("enabled").value),await cr.migrate("annotations.line.trailing.format",cr.name("currentLine")("format").value),await cr.migrate("annotations.file.gutter.hover.changes",cr.name("hovers")("annotations")("changes").value),await cr.migrate("annotations.file.gutter.hover.details",cr.name("hovers")("annotations")("details").value),await cr.migrate("annotations.file.gutter.hover.details",cr.name("hovers")("annotations")("enabled").value),await cr.migrate("annotations.file.gutter.hover.wholeLine",cr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await cr.migrate("annotations.line.trailing.hover.changes",cr.name("hovers")("currentLine")("changes").value),await cr.migrate("annotations.line.trailing.hover.details",cr.name("hovers")("currentLine")("details").value),await cr.migrate("blame.line.enabled",cr.name("hovers")("currentLine")("enabled").value),await cr.migrate("annotations.line.trailing.hover.wholeLine",cr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await cr.migrate("gitExplorer.gravatars",cr.name("explorers")("avatars").value),await cr.migrate("gitExplorer.commitFileFormat",cr.name("explorers")("commitFileFormat").value),await cr.migrate("gitExplorer.commitFormat",cr.name("explorers")("commitFormat").value),await cr.migrate("gitExplorer.stashFileFormat",cr.name("explorers")("stashFileFormat").value),await cr.migrate("gitExplorer.stashFormat",cr.name("explorers")("stashFormat").value),await cr.migrate("gitExplorer.statusFileFormat",cr.name("explorers")("statusFileFormat").value),await cr.migrate("recentChanges.file.lineHighlight.locations",cr.name("recentChanges")("highlight")("locations").value)),1!==A.compare(i,A.from(8,0,0,"beta2"))&&(await cr.migrate("debug",cr.name("outputLevel").value,{migrationFn:e=>e?p.Debug:cr.get(cr.name("outputLevel").value)}),await cr.migrate("debug",cr.name("debug").value,{migrationFn:e=>void 0})),1!==A.compare(i,A.from(8,0,0,"rc"))){let e=cr.name("blame")("highlight")("locations").value;await cr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=cr.name("recentChanges")("highlight")("locations").value,await cr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==A.compare(i,A.from(8,0,0))&&(await cr.migrateIfMissing("annotations.file.gutter.gravatars",cr.name("blame")("avatars").value),await cr.migrateIfMissing("annotations.file.gutter.compact",cr.name("blame")("compact").value),await cr.migrateIfMissing("annotations.file.gutter.dateFormat",cr.name("blame")("dateFormat").value),await cr.migrateIfMissing("annotations.file.gutter.format",cr.name("blame")("format").value),await cr.migrateIfMissing("annotations.file.gutter.heatmap.enabled",cr.name("blame")("heatmap")("enabled").value),await cr.migrateIfMissing("annotations.file.gutter.heatmap.location",cr.name("blame")("heatmap")("location").value),await cr.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",cr.name("blame")("highlight")("enabled").value),await cr.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",cr.name("blame")("highlight")("locations").value),await cr.migrateIfMissing("annotations.file.gutter.separateLines",cr.name("blame")("separateLines").value),await cr.migrateIfMissing("codeLens.locations",cr.name("codeLens")("scopes").value),await cr.migrateIfMissing("codeLens.perLanguageLocations",cr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await cr.migrateIfMissing("codeLens.customLocationSymbols",cr.name("codeLens")("symbolScopes").value),await cr.migrateIfMissing("annotations.line.trailing.dateFormat",cr.name("currentLine")("dateFormat").value),await cr.migrateIfMissing("blame.line.enabled",cr.name("currentLine")("enabled").value),await cr.migrateIfMissing("annotations.line.trailing.format",cr.name("currentLine")("format").value),await cr.migrateIfMissing("annotations.file.gutter.hover.changes",cr.name("hovers")("annotations")("changes").value),await cr.migrateIfMissing("annotations.file.gutter.hover.details",cr.name("hovers")("annotations")("details").value),await cr.migrateIfMissing("annotations.file.gutter.hover.details",cr.name("hovers")("annotations")("enabled").value),await cr.migrateIfMissing("annotations.file.gutter.hover.wholeLine",cr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await cr.migrateIfMissing("annotations.line.trailing.hover.changes",cr.name("hovers")("currentLine")("changes").value),await cr.migrateIfMissing("annotations.line.trailing.hover.details",cr.name("hovers")("currentLine")("details").value),await cr.migrateIfMissing("blame.line.enabled",cr.name("hovers")("currentLine")("enabled").value),await cr.migrateIfMissing("annotations.line.trailing.hover.wholeLine",cr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await cr.migrateIfMissing("gitExplorer.gravatars",cr.name("explorers")("avatars").value),await cr.migrateIfMissing("gitExplorer.commitFileFormat",cr.name("explorers")("commitFileFormat").value),await cr.migrateIfMissing("gitExplorer.commitFormat",cr.name("explorers")("commitFormat").value),await cr.migrateIfMissing("gitExplorer.stashFileFormat",cr.name("explorers")("stashFileFormat").value),await cr.migrateIfMissing("gitExplorer.stashFormat",cr.name("explorers")("stashFormat").value),await cr.migrateIfMissing("gitExplorer.statusFileFormat",cr.name("explorers")("statusFileFormat").value),await cr.migrateIfMissing("recentChanges.file.lineHighlight.locations",cr.name("recentChanges")("highlight")("locations").value)),1!==A.compare(i,A.from(8,0,2))){const e=cr.name("keymap").value;await cr.migrate(e,e,{fallbackValue:g.Alternate,migrationFn:e=>"standard"===e?g.Alternate:e})}1!==A.compare(i,A.from(8,2,4))&&await cr.migrate("advanced.menus",cr.name("menus").value,{migrationFn:e=>({editor:{blame:!!e.editorContext.blame,clipboard:!!e.editorContext.copy,compare:!!e.editorContext.lineDiff,details:!!e.editorContext.details,history:!!e.editorContext.history,remote:!!e.editorContext.remote},editorGroup:{blame:!!e.editorTitle.blame,compare:!!e.editorTitle.fileDiff,history:!!e.editorTitle.history,remote:!!e.editorTitle.remote},editorTab:{compare:!!e.editorTitleContext.fileDiff,history:!!e.editorTitleContext.history,remote:!!e.editorTitleContext.remote},explorer:{compare:!!e.explorerContext.fileDiff,history:!!e.explorerContext.history,remote:!!e.explorerContext.remote}})})}catch(e){ur.error(e,"migrateSettings")}}(0,o);const r=cr.get();try{let t=r.advanced.git;if(!t)try{const i=b.extensions.getExtension("vscode.git");void 0!==i&&(t=await i.exports.getGitPath())}catch(e){}await Vt.initialize(t||b.workspace.getConfiguration("git").get("path"))}catch(e){return ur.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await b.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${L}.${cr.name("advanced")("git").value}' is pointed to its installed location.`),void V(W.Enabled,!1)}ar.initialize(e,r),V(W.KeyMap,ar.config.keymap),ar.context.subscriptions.push(new Ds),ar.context.subscriptions.push(new Fs),ar.context.subscriptions.push(new Ps),ar.context.subscriptions.push(new Ts),ar.context.subscriptions.push(new Rs),ar.context.subscriptions.push(new Es),ar.context.subscriptions.push(new Us),ar.context.subscriptions.push(new Os),ar.context.subscriptions.push(new Is),ar.context.subscriptions.push(new Ms),ar.context.subscriptions.push(new Ws),ar.context.subscriptions.push(new Hs),ar.context.subscriptions.push(new Gs),ar.context.subscriptions.push(new js),ar.context.subscriptions.push(new Qs),ar.context.subscriptions.push(new Ks),ar.context.subscriptions.push(new zs),ar.context.subscriptions.push(new qs),ar.context.subscriptions.push(new Ys),ar.context.subscriptions.push(new Xs),ar.context.subscriptions.push(new Zs),ar.context.subscriptions.push(new Js),ar.context.subscriptions.push(new eo),ar.context.subscriptions.push(new to),ar.context.subscriptions.push(new io),ar.context.subscriptions.push(new ro),ar.context.subscriptions.push(new ao),ar.context.subscriptions.push(new no),ar.context.subscriptions.push(new ho),ar.context.subscriptions.push(new co),ar.context.subscriptions.push(new lo),ar.context.subscriptions.push(new uo),ar.context.subscriptions.push(new mo),ar.context.subscriptions.push(new go),ar.context.subscriptions.push(new po),ar.context.subscriptions.push(new fo),ar.context.subscriptions.push(new vo),ar.context.subscriptions.push(new wo),ar.context.subscriptions.push(new bo),ar.context.subscriptions.push(new Co),ar.context.subscriptions.push(new yo),ar.context.subscriptions.push(new So),ar.context.subscriptions.push(new _o),ar.context.subscriptions.push(new Do),ar.context.subscriptions.push(new ko),ar.context.subscriptions.push(new Fo),ar.context.subscriptions.push(new xo),ar.context.subscriptions.push(new $o),function(e){-1===Vt.compareGitVersion("2.2.0")&&Ls.showGitVersionUnsupportedErrorMessage(e)}(Vt.getGitVersion()),async function(e,t){if(void 0===t)return ur.log("GitLens first-time install"),void(ar.config.showWhatsNewAfterUpgrades&&await b.commands.executeCommand(us.ShowWelcomePage));if(t!==e&&(ur.log(`GitLens upgraded from v${t} to v${e}`),0===A.compare(A.fromString(t),A.from(8,0,0))))return void await b.commands.executeCommand(us.ShowWelcomePage);if(!ar.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");i===o&&s===r||i<o||i===o&&s<r||await b.commands.executeCommand(us.ShowWelcomePage)}(i,o),Ls.showKeyBindingsInfoMessage(),e.globalState.update(j.GitLensVersion,i);const a=process.hrtime(t);ur.log(`GitLens(v${i}) activated in ${1e3*a[0]+Math.floor(a[1]/1e6)} ms`)}function gr(){}ur.level=p.Silent,i.d(t,"activate",function(){return mr}),i.d(t,"deactivate",function(){return gr})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("clipboardy")},function(e,t){e.exports=require("tmp")}]);