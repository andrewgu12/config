module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)i.d(s,o,function(t){return e[t]}.bind(null,o));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";var s,o;i.r(t),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const r=[...s.values(e.children)];for(const e of r)t(e,i,!1);if(!o&&1===r.length){const t=r[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.groupByMap=function(e,t){return e.reduce((e,i)=>{const s=t(i),o=e.get(s)||[];return e.set(s,o),o.push(i),e},new Map)},e.groupByFilterMap=function(e,t,i){return e.reduce((e,s)=>{const o=i(s);if(null!=o){const i=t(s),r=e.get(i)||[];e.set(i,r),r.push(o)}return e},new Map)},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var r=i(6);const a=i(8);a.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const n={addSuffix:!0,locale:a};var h;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-6e4*s.getTimezoneOffset(),a=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-a)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(r.distanceInWordsToNow)(e,n),format:t=>Object(r.format)(e,t)}}}(h||(h={}));var c=i(3);const l=i(11),d=i(10);var u,m;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=c.__rest(s,["track"]);if(!0!==o)return l(e,t,r);let a=!1;const n=l(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return d(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(u||(u={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e,t){let i,s=0;for(;!(i=e.next()).done;)(void 0===t||t(i.value))&&s++;return s},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(m||(m={}));class g{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class p{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(47===t||92===t){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}class f{isEmpty(){return!(this.left||this.mid||this.right||this.value)}}class v{constructor(e){this._iter=e}static forPaths(){return new v(new p)}static forStrings(){return new v(new g)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new f,this._root.segment=i.value()),s=this._root;;){const e=i.cmp(s.segment);if(e>0)s.left||(s.left=new f,s.left.segment=i.value()),s=s.left;else if(e<0)s.right||(s.right=new f,s.right.segment=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new f,s.mid.segment=i.value()),s=s.mid}}const o=s.value;return s.value=t,s.key=e,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.value:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.value=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.value||i,s=s.mid}}return s&&s.value||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new v(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,e)}_forEach(e,t){void 0!==e&&(this._forEach(e.left,t),e.value&&t(e.value,e.key),this._forEach(e.mid,t),this._forEach(e.right,t))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(e){return void 0===this._root||this._root.isEmpty()?0:m.count(this.entries(),void 0===e?void 0:([t])=>e(t))}entries(){return this._iterator(this._root)}values(){return m.map(this.entries(),([e])=>e)}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}some(e){return void 0!==this._root&&!this._root.isEmpty()&&m.some(this.entries(),([t])=>e(t))}*_iterator(e){void 0!==e&&(yield*this._iterator(e.left),e.value&&(yield[e.value,e.key]),yield*this._iterator(e.mid),yield*this._iterator(e.right))}}var w,b,C=i(5);!function(e){const t=/\\/g,i=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,s=/\$\{(\w*?)(?:\W|\d)*?\}/g;function o(e,t,i=" "){const s=t-c(e);return s<=0?e:i.repeat(s)+e}function r(e,t,i=" "){const s=t-c(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const t=[];let s=i.exec(e);for(;null!=s;){const o=s[2],r=s[3];t.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=i.exec(e)}return t},e.interpolate=function(e,t){return e?void 0===t?e.replace(s,""):(e=e.replace(s,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(C.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(t,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=o,e.padLeftOrTruncate=function(e,t,i){const s=c(e);return s<t?o(e,t,i):s>t?n(e,t):e},e.padRight=r,e.padOrTruncate=function(e,t,i){const s=t<0;t=Math.abs(t);const a=c(e);return a<t?s?o(e,t,i):r(e,t,i):a>t?n(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=c(e);return s<t?r(e,t,i):s>t?n(e,t):e};const a=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function n(e,t,i="…"){if(!e)return e;const s=c(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=c(e.substring(0,o));for(;r<t;)r+=c(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(a,t):e},e.sha1=function(e,t="base64"){return Object(C.createHash)("sha1").update(e).digest(t)},e.truncate=n;const h=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function c(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(h,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159||r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=l(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function l(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=c}(w||(w={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(b||(b={}));var y,x,$,S,D,_,k,F,P,R,T,E,B,A,N=i(0);!function(e){e.File="file",e.Window="window"}(y||(y={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(x||(x={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}($||($={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(S||(S={})),function(e){e.Absolute="absolute",e.Relative="relative"}(D||(D={})),function(e){e.List="list",e.Tree="tree"}(_||(_={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(k||(k={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(F||(F={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(P||(P={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(R||(R={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(T||(T={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(E||(E={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(B||(B={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(A||(A={}));const L="gitlens",U="GitLens",O="GitLens",I="eamodio.gitlens",M=1e8;var W,H,G,j,V;function Q(e,t){return N.commands.executeCommand(W.SetContext,e,t)}function K(e){const t=N.window.activeTextEditor;return null!=t&&t.document===e}function z(e){const t=e.document.uri.scheme;return t!==G.Output&&t!==G.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(W||(W={})),function(e){e.ActiveHasRemote="gitlens:activeHasRemote",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.HistoryExplorer="gitlens:historyExplorer",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(H||(H={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(G||(G={})),function(e){e.AngleBracketLeftHeavy="❰",e.AngleBracketRightHeavy="❱",e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowHeadRight="➤",e.ArrowLeft="←",e.ArrowLeftDouble="⇐",e.ArrowLeftRight="↔",e.ArrowLeftRightDouble="⇔",e.ArrowLeftRightDoubleStrike="⇎",e.ArrowLeftRightLong="⟷",e.ArrowRight="→",e.ArrowRightDouble="⇒",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.ArrowsHalfLeftRight="⇋",e.ArrowsHalfRightLeft="⇌",e.ArrowsLeftRight="⇆",e.ArrowsRightLeft="⇄",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.MuchGreaterThan="≪",e.MuchLessThan="⋘",e.Pencil="✎",e.Space=" ",e.SpaceThin=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(j||(j={})),(V||(V={})).GitLensVersion="gitlensVersion";const q=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var Y;!function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(Y||(Y={}));class X{}const Z=new class extends X{equals(e,t){return e===t}},J=new class extends X{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?Z.equals(e.document,t.document):e.id===t.id)}},ee=new class extends X{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var te,ie;!function(e){e.Computing="computing",e.Computed="computed"}(te||(te={}));class se extends N.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=se.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=N.Disposable.from(N.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(Z.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=u.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=te.Computing,e===N.window.activeTextEditor&&await Q(H.AnnotationStatus,this.status),this.editor=e,this.correlationKey=se.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=te.Computed,e===N.window.activeTextEditor&&(await Q(H.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=te.Computing,await this.onProvideAnnotation(e)?(this.status=te.Computed,!0):(this.status=void 0,!1)}}function oe(e){switch(e.type){case ie.Branch:return"Branch";case ie.Branches:return"Branches";case ie.Commit:return"Commit";case ie.File:return"File";case ie.Repo:return"Repository";case ie.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(ie||(ie={}));class re{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return N.commands.executeCommand(W.Open,N.Uri.parse(e))}open(e){switch(e.type){case ie.Branch:return this.openBranch(e.branch);case ie.Branches:return this.openBranches();case ie.Commit:return this.openCommit(e.sha);case ie.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case ie.Repo:return this.openRepo();case ie.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const ae=/(^|\s)(issue #([0-9]+))\b/gi,ne=/(^|\s)(pull request #([0-9]+))\b/gi;class he extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(ae,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ne,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const ce=/(^|\s)(issue #([0-9]+))\b/gi,le=/(^|\s)(pull request #([0-9]+))\b/gi;class de extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(ce,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(le,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class ue extends re{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return w.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return w.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return w.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return w.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?w.interpolate(this.urls.fileLine,{line:s.start.line}):w.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?w.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?w.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):w.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const me=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,ge=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class pe extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(me,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ge,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const fe=/(^|\s)(#([0-9]+))\b/gi;class ve extends re{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(fe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const we=`[${U}]`,be=/^--inspect(-brk)?=?/;class Ce{static configure(e){e.subscriptions.push(mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}static onConfigurationChanged(e){const t=mr.initializing(e);let i=mr.name("debug").value;(t||mr.changed(e,i))&&(this.debug=mr.get(i)),i=mr.name("outputLevel").value,(t||mr.changed(e,i))&&(this.level=mr.get(i),this.level===B.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||N.window.createOutputChannel(U))}static log(e,...t){this.debug&&console.log(this.timestamp,we,e,...t),void 0===this.output||this.level!==B.Verbose&&this.level!==B.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,we,t,...i,e),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,...i,e]:[t,...i,e]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,we,e,...t),void 0!==this.output&&this.level!==B.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t,i){this.level===B.Debug&&(void 0===this.gitOutput&&(this.gitOutput=N.window.createOutputChannel(`${U} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})${void 0===i?"":`\n\n${i.toString()}`}`))}static get isDebugging(){if(void 0===this._isDebugging){const e=process.execArgv;this._isDebugging=!!e&&e.some(e=>be.test(e))}return this._isDebugging}}Ce.debug=!1,Ce.level=B.Silent;const ye=/(^|\s)(#([0-9]+))\b/gi,xe=/\/_git\/?/i,$e=new Map([["bitbucket.org",(e,t)=>new he(e,t)],["github.com",(e,t)=>new pe(e,t)],["gitlab.com",(e,t)=>new ve(e,t)],["visualstudio.com",(e,t)=>new class extends re{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}enrichMessage(e){const t=this.baseUrl.replace(xe,"/");return e.replace(ye,`$1[$2](${t}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class Se{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void Ce.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map($e);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case S.Bitbucket:return(t,i)=>new he(t,i,e.protocol,e.name,!0);case S.BitbucketServer:return(t,i)=>new de(t,i,e.protocol,e.name,!0);case S.Custom:return(t,i)=>new ue(t,i,e.urls,e.protocol,e.name);case S.GitHub:return(t,i)=>new pe(t,i,e.protocol,e.name,!0);case S.GitLab:return(t,i)=>new ve(t,i,e.protocol,e.name,!0)}}}var De=i(7),_e=i(2),ke=i(1);const Fe="win32"===process.platform;function Pe(e){if(e.match(/[\\\/]/))return e;const t=ke.join(".",e);try{if(_e.statSync(t))return t}catch(e){}const i=process.env.PATH.split(Fe?";":":");for(const t of i){const i=ke.join(t,e);try{if(_e.statSync(i))return i}catch(e){}}return e}function Re(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=c.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(De.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&Ce.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function Te(e){const t=await Re(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!Fe)return{cmd:Pe(t),args:i};if(!_e.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=Pe(`${t}${o}`);if(_e.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:ke.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:ke.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Ee(e){return e?Te(ke.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var Be=i(4);class Ae extends N.Uri{constructor(e,t){if(null==e)return void super();if(e.scheme===G.GitLensGit){const t=JSON.parse(e.query),[i,s]=Ae.ensureValidUNCPath(e.authority,ke.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!qt.isStagedUncommitted(t.sha)&&qt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Ae.ensureValidUNCPath(e.authority,ke.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!qt.isStagedUncommitted(t.sha)&&qt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&qt.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?N.Uri.file(this.versionedPath):N.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return Ae.getDirectory(ke.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return ke.basename(ke.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=w.pad(j.Dot,2,2),t){let i=ke.dirname(this.fsPath);return this.repoPath&&(i=ke.relative(this.repoPath,i)),void 0!==t&&(i=ke.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?`${ke.basename(this.fsPath)}${e}${i}`:ke.basename(this.fsPath)}getRelativePath(e){let t=ke.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=ke.relative(e,t)),w.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Ae(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Ae(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=N.Uri.file(ke.resolve(t,s&&e.originalFileName||e.fileName));return new Ae(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Ae(N.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Ae(e)}static async fromUri(e){if(e instanceof Ae)return e;if(!lr.git.isTrackable(e))return new Ae(e);if(e.scheme===G.GitLensGit)return new Ae(e);if(e.scheme===G.Git){const t=JSON.parse(e.query),i=await lr.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=qt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Ae(e,{fileName:t.path,repoPath:i,sha:s})}const t=await lr.git.getVersionedUri(e);return void 0!==t?t:new Ae(e,await lr.git.getRepoPath(e))}static getDirectory(e,t){let i=ke.dirname(e);return void 0!==t&&(i=ke.relative(t,i)),(i=w.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=w.pad(j.Dot,2,2),i){let s;if(e instanceof N.Uri){if(e instanceof Ae)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Ae.getDirectory(s,i);return o?`${ke.basename(s)}${t}${o}`:ke.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof N.Uri){if(e instanceof Ae)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=ke.relative(i||"",s);return void 0!==t&&(o=ke.relative(t,o)),w.normalizePath(o)}static toKey(e){return w.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:ke.resolve(i,t.fileName),o=e,r=qt.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:w.normalizePath(ke.relative(i,s)),repoPath:i,sha:o},n=ke.parse(s);return N.Uri.parse(`${G.GitLensGit}:${ke.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Ne=new Map;var Le;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Le||(Le={}));const Ue={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ue.dateStyle=mr.get(mr.name("defaultDateStyle").value),Ue.dateFormat=mr.get(mr.name("defaultDateFormat").value)}};class Oe{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ue.dateStyle===D.Absolute?this.formatDate(Ue.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=At.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Le.Blame||this.type===Le.File||this.type===Le.StashFile}get isStash(){return this.type===Le.Stash||this.type===Le.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=At.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=At.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return At.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&At.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?N.Uri.file(ke.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return N.Uri.file(ke.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=h.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=w.pad(j.Dot,2,2)){return Ae.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Ne.get(i);if(void 0!==s)return s;const o=(s=N.Uri.parse(`https://www.gravatar.com/avatar/${this.email?w.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Ne.set(i,s),s}getShortMessage(e=`${j.Space}${j.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await lr.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Ae.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ie extends Oe{constructor(e,t,i,s,o,r,a,n,h,c,l){super(Le.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ie(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Me{constructor(e,t,i=!1,s,o,r=0,a=0){this.repoPath=e,this.current=i,this.sha=s,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.name=t,this.tracking=""===o||null==o?void 0:o,this.state={ahead:r,behind:a}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Me.getRemote(this.name):void 0!==this.tracking?Me.getRemote(this.tracking):void 0}getTrackingStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.tracking||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${j.ArrowDown}${e.separator}${this.state.ahead}${j.ArrowUp}`}isValid(){return Me.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const We=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,He=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Ge=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class je{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=Ge.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new Ve(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=m.skip(w.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=We.exec(e)))break;i.push(xt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=He.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class Ve{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=je.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class Qe extends Oe{constructor(e,t,i,s,o,r,a,n,h,c,l,d,u,m){super(e,t,i,s,o,r,a,n,l,d,u),this.fileStatuses=h,this.status=c,this.parentShas=m}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&At.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?N.Uri.file(ke.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=w.normalizePath(ke.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Le.StashFile:Le.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new Qe(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ke,ze,qe;!function(e){e.Fetch="fetch",e.Push="push"}(Ke||(Ke={}));class Ye{constructor(e,t,i,s,o,r,a){this.repoPath=e,this.name=t,this.scheme=i,this.domain=s,this.path=o,this.provider=r,this.types=a}}!function(e){e.Config="config",e.Closed="closed",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(ze||(ze={}));class Xe{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(qe||(qe={})).StatusNode="statusNode";class Ze extends N.Disposable{constructor(e,t,i,s,o,r=!1){if(super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new N.EventEmitter,this._onDidChangeFileSystem=new N.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this._closed=!1,i)this.formattedName=e.name;else{const i=ke.relative(e.uri.fsPath,t);this.formattedName=i?`${e.name} (${i})`:e.name}this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o,this._closed=r;const a=N.workspace.createFileSystemWatcher(new N.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=N.Disposable.from(a,a.onDidChange(this.onRepositoryChanged,this),a.onDidCreate(this.onRepositoryChanged,this),a.onDidDelete(this.onRepositoryChanged,this),mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=mr.initializing(e),i=mr.name("remotes").value;(t||mr.changed(e,i,this.folder.uri))&&(this._providerMap=Se.createMap(mr.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(ze.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(ze.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(ze.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(ze.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(ze.Config,ze.Remotes);this.onAnyRepositoryChanged(this,ze.Repository),this.fireChange(ze.Repository)}}}get closed(){return this._closed}set closed(e){const t=this._closed!==e;this._closed=e,t&&(this.onAnyRepositoryChanged(this,ze.Closed),this.fireChange(ze.Closed))}containsUri(e){return e instanceof Ae&&(e=void 0!==e.repoPath?N.Uri.file(e.repoPath):e.fileUri()),this.folder===N.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=lr.git.getBranch(this.path)),this._branch}getBranches(){return lr.git.getBranches(this.path)}getChangedFilesCount(e){return lr.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=mr.get(mr.name("remotes").value,this.folder.uri);this._providerMap=Se.createMap(e)}this._remotes=lr.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return lr.git.getStashList(this.path)}getStatus(){return lr.git.getStatusForRepo(this.path)}getTags(){return lr.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=N.workspace.createFileSystemWatcher(new N.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=N.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=u.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new Xe(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=u.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}}class Je extends Qe{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new Je(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class et{constructor(e,t,i,s,o,r){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=r}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${this._diff.added} ${1===this._diff.added?"file":"files"} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${1===this._diff.changed?"file":"files"} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${1===this._diff.deleted?"file":"files"} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.upstream||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${j.ArrowDown}${e.separator}${this.state.ahead}${j.ArrowUp}`}}class tt{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return N.Uri.file(ke.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return tt.getFormattedDirectory(this,e)}getFormattedPath(e=w.pad(j.Dot,2,2)){return tt.getFormattedPath(this,e)}getOcticon(){return st(this.status)}getStatusText(e){return tt.getStatusText(this.status)}with(e){return new tt(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Ae.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${w.pad(j.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=w.pad(j.Dot,2,2),i){return Ae.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Ae.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return at[e]||at.X}(e)}}const it={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function st(e,t=j.Space.repeat(4)){return it[e]||t}const ot={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function rt(e){return ot[e]||ot.X}const at={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class nt{constructor(e,t){this.repoPath=e,this.name=t}getBasename(){if(void 0===this._basename){const e=this.name.lastIndexOf("/");this._basename=-1!==e?this.name.substring(e+1):this.name}return this._basename}}class ht{static parse(e,t,i,s){if(!e)return;const o=new Map,r=new Map,a=[];let n,h,c=t&&i,l=void 0,d=!0;for(n of w.lines(e))if(!((h=n.split(" ")).length<2))if(void 0!==l)switch(h[0]){case"author":At.isUncommitted(l.sha)?l.author="You":(l.author=h.slice(1).join(" ").trim(),void 0!==s&&s===l.author&&(l.author="You"));break;case"author-mail":l.authorEmail=h.slice(1).join(" ").trim();const e=l.authorEmail.indexOf("<");if(e>=0){const t=l.authorEmail.indexOf(">",e);l.authorEmail=t>e?l.authorEmail.substring(e+1,t):l.authorEmail.substring(e+1)}break;case"author-time":l.authorDate=h[1];break;case"author-tz":l.authorTimeZone=h[1];break;case"summary":l.summary=h.slice(1).join(" ").trim();break;case"previous":l.previousSha=h[1],l.previousFileName=h.slice(2).join(" ");break;case"filename":l.fileName=h.slice(1).join(" "),d&&void 0===t&&(t=w.normalizePath(i.replace(i.startsWith("/")?`/${l.fileName}`:l.fileName,"")),c=w.normalizePath(ke.relative(t,i))),d=!1,ht.parseEntry(l,t,c,r,o,a),l=void 0}else l={sha:h[0],originalLine:parseInt(h[1],10)-1,line:parseInt(h[2],10)-1,lineCount:parseInt(h[3],10)};return r.forEach(e=>{if(void 0===e.author)return;const t=o.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...o.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:a}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Ie(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const ct=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,lt=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class dt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=ct.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Me(t,s[2],"*"===s[1],s[3],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=lt.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const ut=/diff --git a\/(.*) b\/(.*)/,mt={};class gt{static parse(e,t,i,s,r,a,n,h,c){if(!e)return;let l,d,u=void 0,m=mt,g=void 0,p=0,f=!0;const v=w.lines(e+"</f>");let b=v.next();if(b.done)return;void 0!==i&&(i=w.normalizePath(i));const C=new Map,y=new Map;for(;!((b=v.next()).done||(g=b.value,h&&n&&p>=n));)switch(d=g.charCodeAt(1)){case 114:m={ref:g.substring(4)};break;case 97:At.isUncommitted(m.ref)?m.author="You":(m.author=g.substring(4),void 0!==a&&a===m.author&&(m.author="You"));break;case 101:m.email=g.substring(4);break;case 100:m.date=g.substring(4);break;case 112:m.parentShas=g.substring(4).split(" ");break;case 115:for(;!(b=v.next()).done&&"</s>"!==(g=b.value);)void 0===m.summary?m.summary=g:m.summary+=`\n${g}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((b=v.next()).done||"</f>"===b.value)break;for(;!(b=v.next()).done&&"</f>"!==(g=b.value);)if(!g.startsWith("warning:"))if(t===Le.Branch){const e={status:g[0],fileName:g.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(g.startsWith("diff")){const e=ut.exec(g);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(b=v.next()).done&&"</f>"!==b.value;);break}m.status=g[0],m.fileName=g.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),f&&void 0===i&&t===Le.File&&void 0!==s?(i=w.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),l=w.normalizePath(ke.relative(i,s))):l=m.fileName,f=!1;const e=y.get(m.ref);void 0===e&&p++,u=gt.parseEntry(m,e,t,i,l,y,C,u)}return{repoPath:i,authors:C,commits:y,sha:r,count:p,maxCount:n,range:c,truncated:!!(n&&p>=n&&1!==n)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Le.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new Qe(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Le.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const pt=/^(.*)\t(.*)\s\((.*)\)$/gm,ft=/^(?:(git:\/\/)(.*?)\/|(https?:\/\/)(?:.*?@)?(.*?)\/|git@(.*):|(ssh:\/\/)(?:.*@)?(.*?)(?::.*?)?\/|(?:.*?@)(.*?):)(.*)$/;class vt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=pt.exec(e)))break;const a=r[2],[n,h,c]=this.parseGitUrl(a),l=`${h}/${c}`;let d=o[l];void 0===d?(d=new Ye(t,r[1],n,h,c,i(h,c),[{url:a,type:r[3]}]),s.push(d),o[l]=d):d.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=ft.exec(e);return null==t?["","",""]:[t[1]||t[3]||t[6],t[2]||t[4]||t[5]||t[7]||t[8],t[9].replace(/\.git\/?$/,"")]}}const wt={};class bt{static parse(e,t){if(!e)return;const i=w.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=w.normalizePath(t));const r=new Map;let a,n=wt,h=void 0;for(;!(s=i.next()).done;)switch(a=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if(!(s=i.next()).done&&"</f>"!==s.value){for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};gt.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "))}let e=r.get(n.ref);e=bt.parseEntry(n,e,t,r)}return{repoPath:t,commits:r}}static parseEntry(e,t,i,s){return void 0===t&&(t=new Je(Le.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const Ct=/(?:ahead ([0-9]+))/,yt=/(?:behind ([0-9]+))/;class xt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=Ct.exec(t);o.ahead=null==i?0:+i[1]||0;const s=yt.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new et(w.normalizePath(t),i||"","",s,o,r)}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new et(w.normalizePath(t),i||"",o||"",s,r,a)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new tt(e,o,r,i,s)}}class $t{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new nt(t,e):void 0);return i.length?i:void 0}}let St;const Dt=["blame","--root","--incremental"],_t=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],kt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Ft={badRevision:/bad revision \'.*?\'/i},Pt={notARepository:/Not a git repository/i,outsideRepository:/is outside repository/i,noPath:/no such path/i,noCommits:/does not have any commits/i,notFound:/Path \'.*?\' does not exist in/i,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/i,headNotABranch:/HEAD does not point to a branch/i,noUpstream:/no upstream configured for branch \'(.*?)\'/i,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree/i};async function Rt(e,...t){try{return await Et(e,...t)}catch(i){return Bt(i,e,...t)}}const Tt=new Map;async function Et(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=c.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let l,d,u=Tt.get(h);void 0===u?(Ce.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),u=Re(St.path,t,a),Tt.set(h,u)):Ce.log(`Awaiting${h}`);try{l=await u}catch(e){throw d=e,e}finally{Tt.delete(h);const e=process.hrtime(i),t=`${void 0===d?"Completed":"FAILED"} in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;Ce.log(`${void 0===d?"Completed":"FAILED"}${h} ${t}`),Ce.logGitCommand(`${n} ${t}`,a.cwd,d)}return"utf8"===r||"binary"===r?l:Be.decode(Buffer.from(l,"binary"),r)}function Bt(e,t,...i){const o=e&&e.toString();if(o)for(const e of s.values(Pt))if(e.test(o))return Ce.warn("git",...i,`  cwd='${t.cwd}'\n\n  `,o.replace(/\r?\n|\r/g," ")),"";throw Ce.error(e,"git",...i,`  cwd='${t.cwd}'\n\n  `),e}class At{static gitInfo(){return St}static getEncoding(e){return void 0!==e&&Be.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();St=await async function(e){try{return await Te(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await Re("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Te(e);try{return await Re("xcode-select",["-p"]),Te(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Te(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Ee(process.env.ProgramW6432).then(null,()=>Ee(process.env["ProgramFiles(x86)"])).then(null,()=>Ee(process.env.ProgramFiles)).then(null,()=>Te("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return Ce.log(`Git found: ${St.version} @ ${"git"===St.path?"PATH":St.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),St}static async getVersionedFile(e,t,s){const o=await At.show(e,t,s,{encoding:"binary"});if(void 0===o)return;At.isStagedUncommitted(s)&&(s="");const r=w.truncate(w.sanitizeForFileSystem(At.isSha(s)?At.shortenSha(s):s),50,""),a=ke.extname(t),n=await Promise.resolve().then(i.t.bind(null,13,7));return new Promise((i,h)=>{n.file({prefix:`${ke.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(Ce.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),_e.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):_e.chmod(a,33060,e=>{i(a)})}))})})}static isResolveRequired(e){return At.isSha(e)&&!At.shaStrictRegex.test(e)}static isSha(e){return At.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&At.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&At.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(At.isStagedUncommitted(e))return t.stagedUncommitted;if(At.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=w.normalizePath(e);const i=((t=w.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=w.normalizePath(i?ke.dirname(e):t),e=w.normalizePath(i?ke.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=St.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=At.splitPath(t,e),a=[...Dt];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),i&&(At.isStagedUncommitted(i)?(a.push("--contents","-"),n=await At.show(e,t,":")):a.push(i)),Rt({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=At.splitPath(t,e),a=[...Dt];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),a.push("--contents","-"),Rt({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),Rt({cwd:e},...i)}static checkout(e,t,i){const[s,o]=At.splitPath(t,e);return Rt({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Et({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["diff","--diff-filter=M","-M","--no-ext-diff","--minimal"];return i&&r.push(At.isStagedUncommitted(i)?"--staged":i),s&&r.push(At.isStagedUncommitted(s)?"--staged":s),Rt({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Rt({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Rt({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Rt({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Rt({cwd:e},...o)}static log(e,t){const i=[..._t,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!At.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Rt({cwd:e},...i,"--")}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=At.splitPath(t,e),r=[..._t];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!At.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),Rt({cwd:o},...r,"--",s)}static async log_recent(e,t){try{return(await Et({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Et({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[..._t,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),Rt({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!At.isStagedUncommitted(t.ref)&&i.push(t.ref),Rt({cwd:e},...i,"--")}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!At.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Et({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Rt({cwd:e},...o,t,i)}static remote(e){return Rt({cwd:e},"remote","-v")}static remote_url(e,t){return Rt({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Et({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Et(i,...t)}catch(e){const s=e&&e.toString();if(Pt.headNotABranch.test(s))return;const o=Pt.noUpstream.exec(s);if(null!==o)return o[1];if(Pt.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Et(i,...t)}catch(e){return}return Bt(e,i,...t)}}static async revparse_toplevel(e){try{return(await Et({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=At.splitPath(t,e);if(At.isStagedUncommitted(i)&&(i=":"),At.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Et(a,"show",n,"--")}catch(o){const r=o&&o.toString();if(":"===i&&Ft.badRevision.test(r))return At.show(e,t,"HEAD:",s);if(Ft.badRevision.test(r)||Pt.notFound.test(r)||Pt.foundButNotInRevision.test(r))return;return Bt(o,a,n)}}static stash_apply(e,t,i){if(t)return Rt({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Rt({cwd:e},"stash","drop",t)}static stash_list(e){return Rt({cwd:e},...kt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Rt({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Rt({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Rt({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=At.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return Rt({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",r,s)}static tag(e){return Rt({cwd:e},...["tag","-l"])}}At.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,At.shaStrictRegex=/^[0-9a-f]{40}$/,At.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,At.stagedUncommittedSha="0000000000000000000000000000000000000000:",At.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,At.uncommittedSha="0000000000000000000000000000000000000000";class Nt extends N.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new N.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===lr.git&&!await u.waitUntil(()=>void 0!==lr.git,2e3))throw Ce.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Ae.fromUri(e),this._disposed)return;const t=await lr.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(ze.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){Q(H.ActiveIsRevision,this.isRevision),Q(H.ActiveFileIsTracked,this.isTracked),Q(H.ActiveIsBlameable,this.isBlameable),Q(H.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,Ce.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&K(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=N.window.activeTextEditor;return null!=t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await lr.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(Q(H.ActiveIsRevision,this.isRevision),Q(H.ActiveFileIsTracked,this.isTracked),Q(H.ActiveIsBlameable,s),Q(H.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class Lt extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new N.EventEmitter,this._onDidChangeDirtyState=new N.EventEmitter,this._onDidTriggerDirtyIdle=new N.EventEmitter,this._documentMap=new Map,this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this),N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveTextEditorChanged,0),this),N.workspace.onDidChangeTextDocument(u.debounce(this.onTextDocumentChanged,50),this),N.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),N.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(N.window.activeTextEditor)}onConfigurationChanged(e){const t=mr.initializing(e);if(!t&&(mr.changed(e,mr.name("blame")("ignoreWhitespace").value,null)||mr.changed(e,mr.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=mr.name("advanced")("blame")("delayAfterEdit").value;(t||mr.changed(e,i))&&(this._dirtyIdleTriggerDelay=mr.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!z(e))return;if(void 0===e)return Q(H.ActiveIsRevision,!1),Q(H.ActiveFileIsTracked,!1),Q(H.ActiveIsBlameable,!1),void Q(H.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==G.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=N.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?K(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof N.Uri)&&(e=Ae.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Ae)try{e=await N.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new Ot(e);else{if(!i.includes("File not found"))throw t;e=new It(e)}}else e instanceof N.Uri&&(e=await N.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Ae?e=Ae.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof N.Uri)&&(e=Ae.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Ae.toKey(e.uri),i=new Nt(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),N.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=u.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=u.debounce(async e=>{N.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class Ut{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=N.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class Ot extends Ut{}class It extends Ut{}class Mt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class Wt extends Lt{}class Ht{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=w.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:w.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?w.padLeft(e,i):(t.collapseWhitespace&&(i-=o),w.padRight(e,i))):o<0?w.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof Ht)return w.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:w.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),w.interpolate(t,this._formatter)}}Ht._formatter=void 0;class Gt extends Ht{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:lr.config.defaultDateStyle)===D.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;return e=this._item.isStagedUncommitted?"Staged changes":this._item.isUncommitted?"Uncommitted changes":this._options.truncateMessageAtNewLine?this._item.getShortMessage():this._item.message,this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class jt extends Ht{get directory(){const e=tt.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=ke.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=tt.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=tt.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=tt.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${j.Pencil} ${j.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Vt,Qt,Kt,zt;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Vt||(Vt={}));class qt extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new N.EventEmitter,this._suspended=!1,this._userNameMapCache=new Map,this._repositoryTree=v.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=N.Disposable.from(N.window.onDidChangeWindowState(this.onWindowStateChanged,this),N.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return lr.config.advanced.caching.enabled}onAnyRepositoryChanged(e,t){this._trackedCache.clear(),t===ze.Closed&&setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}onConfigurationChanged(e){(mr.initializing(e)||mr.changed(e,mr.name("defaultDateStyle").value)||mr.changed(e,mr.name("defaultDateFormat").value))&&Ue.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:N.workspace.workspaceFolders||[],removed:[]},Ce.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==G.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==G.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...m.map(i.entries(),([t,i])=>[t,ke.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=mr.get(mr.name("advanced")("repositorySearchDepth").value,t);Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),r=[],a=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(Ce.log(`Repository found in '${n}'`),r.push(new Ze(e,n,!0,a,this._suspended))),i<=0){const e=process.hrtime(o);return Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),r}let h=Object.assign({},N.workspace.getConfiguration("files",t).get("exclude",{}),N.workspace.getConfiguration("search",t).get("exclude",{}));h=[...m.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=ke.dirname(t),w.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(Ce.log(`Repository found in '${i}'`),r.push(new Ze(e,i,!1,a,this._suspended)))}const l=process.hrtime(o);return Ce.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),r}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{_e.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=ke.resolve(e,t);return new Promise((e,r)=>{_e.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await Q(H.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await Q(H.HasRemotes,i),!t){const e=N.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=N.Disposable.from(e,e.onDidCreate(async e=>{const i=N.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,Ce.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),At.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>_e.exists(ke.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&m.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&m.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=At.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=m.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=At.splitPath(s,t)):s=w.normalizePath(ke.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){let t;if(null!=(e=e||N.window.activeTextEditor)){const i=await lr.tracker.getOrAdd(e.document.uri);void 0!==i&&(t=i.uri.repoPath)}return null!=t?t:this.getHighlanderRepoPath()}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await lr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return Ce.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}Ce.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Mt(i.key))}else Ce.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(Ce.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return Ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),qt.emptyPromise;const[s,o]=At.splitPath(e.fsPath,e.repoPath,!1);try{const r=await At.blame(o,s,e.sha,{args:lr.config.advanced.blame.customArguments,ignoreWhitespace:lr.config.blame.ignoreWhitespace});return ht.parse(r,o,s,await this.getCurrentUsername(o))}catch(e){if(void 0!==t.state){const s=e&&e.toString();return Ce.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:qt.emptyPromise,errorMessage:s}),t.setBlameFailure(),qt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${w.sha1(t)}`,s=await lr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return Ce.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}Ce.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Mt(s.key))}else Ce.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(Ce.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return Ce.log(`Skipping blame; '${e.fsPath}' is not tracked`),qt.emptyPromise;const[o,r]=At.splitPath(e.fsPath,e.repoPath,!1);try{const a=await At.blame_contents(r,o,t,{args:lr.config.advanced.blame.customArguments,correlationKey:`:${s}`,ignoreWhitespace:lr.config.blame.ignoreWhitespace});return ht.parse(a,r,o,await this.getCurrentUsername(r))}catch(e){if(void 0!==i.state){const t=e&&e.toString();return Ce.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:qt.emptyPromise,errorMessage:t}),i.setBlameFailure(),qt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(Ce.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await At.blame(e.repoPath,o,e.sha,{args:lr.config.advanced.blame.customArguments,ignoreWhitespace:lr.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=ht.parse(i,e.repoPath,o,await this.getCurrentUsername(e.repoPath));if(void 0===r)return;return{author:m.first(r.authors.values()),commit:m.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(Ce.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await At.blame_contents(e.repoPath,r,i,{args:lr.config.advanced.blame.customArguments,ignoreWhitespace:lr.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=await this.getCurrentUsername(e.repoPath),n=ht.parse(s,e.repoPath,r,a);if(void 0===n)return;return{author:m.first(n.authors.values()),commit:m.first(n.commits.values()),line:n.lines[t]}}catch(e){return}}async getBlameForRange(e,t){Ce.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(Ce.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;Ce.log(`getBranch('${e}')`);const t=await At.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Me(e,i[0],!0,void 0,i[1])}async getBranches(e){if(void 0===e)return[];Ce.log(`getBranches('${e}')`);const t=await At.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return dt.parse(t,e)||[]}async getChangedFilesCount(e,t){Ce.log(`getChangedFilesCount('${e}', '${t}')`);const i=await At.diff_shortstat(e,t);return je.parseShortStat(i)}async getConfig(e,t){return Ce.log(`getConfig('${e}', '${t}')`),await At.config_get(e,t)}async getCurrentUsername(e){let t=this._userNameMapCache.get(e);return void 0===t&&(t=await At.config_get("user.name",e),this._userNameMapCache.set(e,t)),t}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await lr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Ce.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}Ce.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Mt(o.key))}else Ce.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:qt.getEncoding(e)},o,s);return void 0!==o.state&&(Ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=At.splitPath(t,e,!1);try{const t=await At.diff(h,n,i,s,o);return je.parse(t)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return Ce.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:qt.emptyPromise,errorMessage:t}),qt.emptyPromise}return}}async getDiffForLine(e,t,i,s){Ce.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){Ce.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await At.diff_nameStatus(e,t,i,s);return je.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await At.log_recent(e,t)}async getLogCommit(e,t){Ce.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){Ce.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||At.isResolveRequired(i.ref)?o||m.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),Ce.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?lr.config.advanced.maxListItems||0:t.maxCount;try{const s=await At.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=gt.parse(s,Le.Branch,e,void 0,t.ref,await this.getCurrentUsername(e),i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){Ce.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?lr.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Vt.Author:r=[`--author=${t}`];break;case Vt.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Vt.Changes:r=[`-G${t}`];break;case Vt.Files:r=["--",`${t}`];break;case Vt.Message:r=[`--grep=${t}`];break;case Vt.Sha:r=[t],o=1}try{const a=await At.log_search(e,r,{maxCount:o}),n=gt.parse(a,Le.Branch,e,void 0,void 0,await this.getCurrentUsername(e),o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===w.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=lr.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await lr.tracker.getOrAdd(new Ae(N.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return Ce.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;Ce.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return Ce.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}Ce.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new Mt(o.key))}else Ce.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(Ce.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return Ce.log(`Skipping log; '${t}' is not tracked`),qt.emptyPromise;const[r,a]=At.splitPath(t,e,!1);try{const{range:n}=i,h=c.__rest(i,["range"]),l=null==i.maxCount?lr.config.advanced.maxListItems||0:i.maxCount,d=await At.log_file(a,r,Object.assign({},h,{maxCount:l,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),u=gt.parse(d,Le.File,a,r,h.ref,await this.getCurrentUsername(a),l,h.reverse,n);if(void 0!==u){const s=Object.assign({},i);u.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return u}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return Ce.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:qt.emptyPromise,errorMessage:t}),qt.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await At.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void Ce.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];Ce.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];Ce.log(`getRemotesCore('${e}')`),t=t||Se.createMap(mr.get(mr.name("remotes").value,null));try{const i=await At.remote(e);return vt.parse(i,e,Se.factory(t))}catch(e){return Ce.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(null==e)return await this.getActiveRepoPath();if(e instanceof Ae)return e.repoPath;let i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await lr.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s);let r=void 0===o?N.workspace.getWorkspaceFolder(N.Uri.file(s)):o.folder;if(void 0===r){const e=s.split("/");r={uri:N.Uri.file(s),name:e[e.length-1],index:this._repositoryTree.count()}}return i=new Ze(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended),this._repositoryTree.set(s,i),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()}),s}async getRepoPathCore(e,t){try{return await At.revparse_toplevel(t?e:ke.dirname(e))}catch(e){return void Ce.error(e,"GitService.getRepoPathCore")}}async getRepoPathOrActive(e,t){return await lr.git.getRepoPath(e)||lr.git.getActiveRepoPath(t)}async getRepositories(e){const t=(await this.getRepositoryTree()).values();return void 0!==e?m.filter(t,e):t}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Ae){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;Ce.log(`getStashList('${e}')`);const t=await At.stash_list(e);return bt.parse(t,e)}async getStatusForFile(e,t){Ce.log(`getStatusForFile('${e}', '${t}')`);const i=At.validateVersion(2,11)?2:1,s=await At.status_file(e,t,i),o=xt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;Ce.log(`getStatusForRepo('${e}')`);const t=At.validateVersion(2,11)?2:1,i=await At.status(e,t);return xt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];Ce.log(`getTags('${e}')`);const t=await At.tag(e);return $t.parse(t,e)||[]}async getVersionedFile(e,t,i){if(Ce.log(`getVersionedFile('${e}', '${t}', '${i}')`),i===qt.deletedSha)return;if(!i||At.isUncommitted(i)&&!At.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await At.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Ae.toKey(s),new Ae(N.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return Ce.log(`getVersionedFileText('${e}', '${t}', ${i})`),At.show(e,t,i,{encoding:qt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Ae.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===G.File||t===G.Git||t===G.GitLensGit}async isTracked(e,t,i={}){if(i.ref===qt.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=At.splitPath(e,t),s=Ae.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Ae.toKey(o)}void 0!==r&&(s+=`:${r}`),Ce.log(`isTracked('${o}', '${t}', '${r}')`);let a=this._trackedCache.get(s);return void 0!==a?await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}async isTrackedCore(e,t,i){if(i===qt.deletedSha)return!1;try{let s=!!await At.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await At.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await At.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return Ce.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await At.config_get("diff.guitool",e)||await At.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Ce.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),At.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Ce.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),At.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return qt.isResolveRequired(t)?(Ce.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),null==i?await At.revparse(e,t)||t:await At.log_resolve(e,w.normalizePath(ke.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return Ce.log(`stashApply('${e}', '${t}', ${i})`),At.stash_apply(e,t,i)}stashDelete(e,t){return Ce.log(`stashDelete('${e}', '${t}')`),At.stash_delete(e,t)}stashSave(e,t,i){if(Ce.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return At.stash_save(e,t);qt.ensureGitVersion("2.13.2","Stashing individual files");const s=i.map(t=>At.splitPath(t.fsPath,e)[0]);return At.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?N.Uri.file(ke.join(e,t)):e;return At.getEncoding(N.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return At.getGitInfo(e)}static getGitPath(){return At.gitInfo().path}static getGitVersion(){return At.gitInfo().version}static isResolveRequired(e){return At.isResolveRequired(e)}static isSha(e){return At.isSha(e)}static isStagedUncommitted(e){return At.isStagedUncommitted(e)}static isUncommitted(e){return At.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===qt.deletedSha?t.deleted:At.isSha(e)||At.isStagedUncommitted(e)?At.shortenSha(e,t):e}static compareGitVersion(e,t){return b.compare(b.fromString(this.getGitVersion()),b.fromString(e))}static ensureGitVersion(e,t){const i=this.getGitVersion();if(-1===b.compare(b.fromString(i),b.fromString(e)))throw new Error(`${t} requires a newer version of Git (>= ${e}) than is currently installed (${i}). Please install a more recent version of Git to use this GitLens feature.`)}}qt.emptyPromise=Promise.resolve(void 0),qt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",qt.stagedUncommittedSha=At.stagedUncommittedSha,qt.uncommittedSha=At.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Qt||(Qt={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Kt||(Kt={}));class Yt extends N.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class Xt extends Yt{get repoPath(){return this.uri.repoPath}}class Zt extends Yt{constructor(e,t){super(new Ae),this.message=e,this.tooltip=t}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.message,N.TreeItemCollapsibleState.None);return e.contextValue=Kt.Message,e.tooltip=this.tooltip,e}}class Jt extends Yt{constructor(e,t,i){super(new Ae),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.message,N.TreeItemCollapsibleState.None);return e.contextValue=Kt.Pager,e.command=this.getCommand(),e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:lr.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class ei extends Jt{constructor(e,t,i){super(`${e} ${j.Space}${j.Dash}${j.Space} this may take a while`,t,i),this.args={maxCount:0}}}class ti extends Yt{constructor(e,t,i,s,o){super(Ae.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new ti(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Folder,e.iconPath=N.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(zt||(zt={}));class ii extends Yt{constructor(e,t,i,s){super(Ae.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await lr.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&zt.CommitIcon)===zt.CommitIcon)e.iconPath={dark:lr.context.asAbsolutePath(ke.join("images","dark","icon-commit.svg")),light:lr.context.asAbsolutePath(ke.join("images","light","icon-commit.svg"))};else if((this.displayAs&zt.StatusIcon)===zt.StatusIcon){const t=rt(this.status.status);e.iconPath={dark:lr.context.asAbsolutePath(ke.join("images","dark",t)),light:lr.context.asAbsolutePath(ke.join("images","light",t))}}else(this.displayAs&zt.Gravatar)===zt.Gravatar&&(e.iconPath=this.commit.getGravatarUri(lr.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=ke.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&zt.CommitLabel?Gt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dateFormat:lr.config.defaultDateFormat}):jt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return Kt.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&zt.CommitLabel?this._tooltip=Gt.fromTemplate(this.commit.isUncommitted?`\${author} ${j.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${j.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:lr.config.defaultDateFormat}):this._tooltip=jt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:fs.DiffWithPrevious,arguments:[Ae.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class si extends Yt{constructor(e,t,i,s,o){super(Ae.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(si.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==k.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new si(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof si?-1:1)-(t instanceof si?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Folder,e.iconPath=N.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||k.Auto;if(s===k.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return k.List}return k.Tree}return s}}class oi extends Xt{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.getBranchTips=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...m.map(e.fileStatuses,t=>new ii(t,e.toFileCommit(t),this.explorer,zt.File))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(ke.join(...e)),this.explorer.config.files.compact),i=new si(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=Gt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:lr.config.defaultDateFormat});const t=this.getBranchTips&&this.getBranchTips(this.commit.sha);void 0!==t&&(e=`${j.AngleBracketLeftHeavy}${j.SpaceThin}${t}${j.SpaceThin}${j.AngleBracketRightHeavy}${j.ArrowHeadRight}${j.Space} ${e}`);const i=new N.TreeItem(e,N.TreeItemCollapsibleState.Collapsed);return i.contextValue=void 0===this.branch||this.branch.current?Kt.CommitOnCurrentBranch:Kt.Commit,this.explorer.config.avatars?i.iconPath=this.commit.getGravatarUri(lr.config.defaultGravatarsStyle):i.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-commit.svg"),light:lr.context.asAbsolutePath("images/light/icon-commit.svg")},i.tooltip=Gt.fromTemplate(this.commit.isUncommitted?`\${author} ${j.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${j.Dash} \${id}${void 0!==t?` (${t})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:lr.config.defaultDateFormat}),i}getCommand(){return{title:"Compare File with Previous Revision",command:fs.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ri extends Xt{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===_.List?e:Me.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await lr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new Zt("No commits yet")];const t=await lr.git.getBranches(this.uri.repoPath),i=t[0].sha.length,s=o.groupByFilterMap(t,e=>e.sha,e=>e.name===this.branch.name?void 0:e.name),r=e=>{const t=s.get(e.substr(0,i));if(void 0!==t&&0!==t.length)return t.join(", ")},a=[...m.map(e.commits.values(),e=>new oi(e,this.explorer,this.branch,r))];return e.truncated&&a.push(new ei("Show All Commits",this,this.explorer)),a}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.branch.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=` ${j.Space}${j.ArrowLeftRightLong}${this.branch.getTrackingStatus({prefix:`${j.Space} `})}${j.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${j.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const s=new N.TreeItem(`${this.branch.current?`${j.Check} ${j.Space}`:""}${e}`,N.TreeItemCollapsibleState.Collapsed);return s.tooltip=t,this.branch.remote?s.contextValue=Kt.RemoteBranch:this.branch.current?s.contextValue=this.branch.tracking?Kt.CurrentBranchWithTracking:Kt.CurrentBranch:s.contextValue=this.branch.tracking?Kt.BranchWithTracking:Kt.Branch,s.iconPath={dark:lr.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:lr.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},s}}class ai extends Yt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...m.filterMap(e,e=>e.remote?void 0:new ri(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===_.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),r=new ti(this.repo.path,"",void 0,s,this.explorer),a=await r.getChildren();return void 0!==i&&a.splice(0,0,i),a}async getTreeItem(){const e=new N.TreeItem("Branches",this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Kt.BranchesWithRemotes:Kt.Branches,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-branch.svg"),light:lr.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class ni extends Yt{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...m.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new ri(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===_.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new ti(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ke.Fetch),t=this.remote.types.find(e=>e.type===Ke.Push);let i;i=e&&t?j.ArrowLeftRightLong:e?j.ArrowLeft:t?j.ArrowRight:j.Dash;const s=`${this.remote.name} ${j.Space}${i}${j.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${j.Space}${j.Dot}${j.Space} ${this.remote.path}`,o=new N.TreeItem(s,N.TreeItemCollapsibleState.Collapsed);return o.contextValue=Kt.Remote,o.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?o.iconPath={dark:lr.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:lr.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:lr.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class hi extends Yt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new Zt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...m.map(e,e=>new ni(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new N.TreeItem("Remotes",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Remotes,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:lr.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class ci extends Yt{constructor(e,t,i,s){super(Ae.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new ii(this.status,e,this.explorer,zt.CommitLabel|(this.explorer.config.avatars?zt.Gravatar:zt.CommitIcon)))}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=N.TreeItemCollapsibleState.None,e.contextValue=Kt.StatusFile,this.commit.isStagedUncommitted?e.tooltip=jt.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=jt.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=Kt.StatusFileCommits,e.tooltip=jt.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=rt(this.status.status);return e.iconPath={dark:lr.context.asAbsolutePath(ke.join("images","dark",t)),light:lr.context.asAbsolutePath(ke.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=ke.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=jt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(`${t} ${1===t?"commit":"commits"}`),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:fs.DiffWithPrevious,arguments:[Ae.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class li extends Yt{constructor(e,t,i,s=!1){super(Ae.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await lr.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(m.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...m.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new Qe(Le.File,t,qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,qt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new Qe(Le.File,t,qt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new Qe(Le.File,t,qt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new Qe(Le.File,t,qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const r=o.groupBy(e,e=>e.fileName);let a=[...m.map(s.values(r),e=>new ci(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(a,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(ke.join(...e)),this.explorer.config.files.compact),i=new si(t,"",void 0,e,this.explorer);a=await i.getChildren()}else a.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&a.push(new ei("Show All Changes",this,this.explorer)),a}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await lr.git.getChangedFilesCount(this.repoPath,this.status.upstream);void 0!==t&&(e=t.files)}const t=`${e} ${1===e?"file":"files"} changed`,i=new N.TreeItem(t,N.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Kt.StatusFiles,i.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-diff.svg"),light:lr.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class di extends Yt{constructor(e,t,i,s=!1){super(Ae.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await lr.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...m.map(t.commits.values(),e=>new oi(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await lr.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=m.first(t.commits.values())),[...m.map(i,e=>new oi(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} ${1===this.status.state.ahead?"commit":"commits"} (ahead of ${this.status.upstream})`:`${this.status.state.behind} ${1===this.status.state.behind?"commit":"commits"} (behind ${this.status.upstream})`,t=new N.TreeItem(e,N.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Kt.StatusUpstream,t.iconPath={dark:lr.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:lr.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class ui extends Yt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new di(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new di(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new li(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new N.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=N.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o=`${e.getUpstreamStatus({prefix:`${j.Space} `})}${i?e.getDiffStatus({prefix:`${j.Space} `}):""}`,r=`${e.branch} (current)`,a="";e.upstream&&(this.explorer.config.showTrackingBranch&&(o+=`${j.Space} ${e.upstream}`),r+=`\n\nTracking ${j.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(a="-red"),e.state.ahead&&(a=e.state.behind?"-yellow":"-green"))),o=`${e.branch}${""===o?"":` ${j.Space}${e.upstream?j.ArrowLeftRightLong:j.Dash}${o}`}`,i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),s=t||i?this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed:N.TreeItemCollapsibleState.None;const n=new N.TreeItem(o,s);return n.id=this.id,n.contextValue=Kt.Status,n.tooltip=r,n.iconPath={dark:lr.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:lr.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},n}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class mi extends ii{constructor(e,t,i){super(e,t,i,zt.File)}get resourceType(){return Kt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class gi extends Xt{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await lr.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=m.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new mi(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new N.TreeItem(Gt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:lr.config.defaultDateFormat}),N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Stash,e.tooltip=Gt.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dateFormat:lr.config.defaultDateFormat}),e}}class pi extends Yt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new Zt("No stashed changes")]:[...m.map(e.commits.values(),e=>new gi(e,this.explorer))]}getTreeItem(){const e=new N.TreeItem("Stashes",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Stashes,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-stash.svg"),light:lr.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class fi extends Xt{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get label(){return this.explorer.config.branches.layout===_.Tree?this.tag.getBasename():this.tag.name}get ref(){return this.tag.name}async getChildren(){const e=await lr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new Zt("No commits yet")];const t=[...m.map(e.commits.values(),e=>new oi(e,this.explorer))];return e.truncated&&t.push(new ei("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Tag,e}}class vi extends Yt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();if(0===e.length)return[new Zt("No tags yet")];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...e.map(e=>new fi(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===_.List)return t;const i=o.makeHierarchical(t,e=>e.tag.name.split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),s=new ti(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}async getTreeItem(){const e=new N.TreeItem("Tags",N.TreeItemCollapsibleState.Collapsed);return e.contextValue=Kt.Tags,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-tag.svg"),light:lr.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class wi extends Yt{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return void 0===this.children&&(this.updateSubscription(),this.children=[new ui(this.uri,this.repo,this.explorer,this.active),new ai(this.uri,this.repo,this.explorer,this.active),new hi(this.uri,this.repo,this.explorer,this.active),new pi(this.uri,this.repo,this.explorer,this.active),new vi(this.uri,this.repo,this.explorer,this.active)]),this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${w.pad(j.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new N.TreeItem(e,this.active?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Kt.Repository,t}refresh(){this.resetChildren(),this.updateSubscription()}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||N.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(Ce.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(ze.Repository)||e.changed(ze.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(ze.Stashes)){const e=this.children.find(e=>e instanceof pi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(ze.Remotes)){const e=this.children.find(e=>e instanceof hi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(ze.Tags)){const e=this.children.find(e=>e instanceof vi);void 0!==e&&this.explorer.refreshNode(e)}}}}class bi extends Yt{constructor(e){super(void 0),this.explorer=e,lr.context.subscriptions.push(N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(N.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!z(e))return;let t=!1;try{const i=await lr.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await lr.git.getRepository(i);if(void 0===s||s.closed)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new wi(Ae.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new N.TreeItem("No active repository",N.TreeItemCollapsibleState.None);return e.id=this.id,e}}class Ci extends Yt{constructor(e,t,i=Kt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new oi(this.commit,this.explorer).getChildren();return e.splice(0,0,new Zt(Gt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!0}),Gt.fromTemplate("${message}",this.commit))),e}async getTreeItem(){const e=Gt.fromTemplate(`Commit \${sha} ${w.pad(j.Dash,1,1)} \${authorAgoOrDate}`,this.commit,lr.config.defaultDateFormat),t=new N.TreeItem(e,N.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class yi extends Yt{constructor(e,t,i,s,o=Kt.ResultsCommits){super(Ae.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...m.map(e.commits.values(),e=>new oi(e,this.explorer))];return e.truncated&&t.push(new ei("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new N.TreeItem(await this.getLabel(),e&&e.count>0?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class xi extends Yt{constructor(e,t,i,s,o){super(Ae.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new N.TreeItem(this.label,N.TreeItemCollapsibleState.None);e.contextValue=Kt.StatusFile,e.tooltip=jt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=rt(this.status.status);return e.iconPath={dark:lr.context.asAbsolutePath(ke.join("images","dark",t)),light:lr.context.asAbsolutePath(ke.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=ke.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=jt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:fs.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Ae.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class $i extends Yt{constructor(e,t,i,s){super(Ae.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...m.map(e,e=>new xi(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==k.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>w.normalizePath(ke.join(...e)),this.explorer.config.files.compact),i=new si(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new N.TreeItem(await this.getLabel(),e&&e.length>0?N.TreeItemCollapsibleState.Expanded:N.TreeItemCollapsibleState.None);return t.contextValue=Kt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await lr.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${0===t?"No":t} ${1===t?"file":"files"} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class Si extends Yt{constructor(e,t,i,s){super(Ae.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new yi(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>lr.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new $i(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await lr.git.getRepositoryCount()>1){const t=await lr.git.getRepository(this.uri.repoPath);e=` ${w.pad(j.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new N.TreeItem(`Comparing ${this.ref1.label||qt.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||qt.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,N.TreeItemCollapsibleState.Expanded);return t.contextValue=Kt.ComparisonResults,t}}class Di extends Yt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=zt.CommitLabel|(this.explorer.config.avatars?zt.Gravatar:zt.StatusIcon),i=await lr.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=qt.uncommittedSha,void 0!==i.indexStatus?o=qt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=qt.stagedUncommittedSha,o="HEAD");const r=new Qe(Le.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new ii(i,r,this.explorer,t))}const s=await lr.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...m.map(s.commits.values(),e=>new ii(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new Zt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new N.TreeItem(`${this.uri.getFormattedPath()}`,N.TreeItemCollapsibleState.Expanded);return e.contextValue=Kt.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-history.svg"),light:lr.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable=this.disposable||this.repo.onDidChange(this.onRepoChanged,this)}onRepoChanged(e){e.changed(ze.Repository)&&(Ce.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class _i extends Yt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new Di(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new N.TreeItem(`${this.uri.getFormattedPath()}`,N.TreeItemCollapsibleState.Expanded);return e.contextValue=Kt.History,e.iconPath={dark:lr.context.asAbsolutePath("images/dark/icon-history.svg"),light:lr.context.asAbsolutePath("images/light/icon-history.svg")},e}}class ki extends Yt{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return void 0===this.children&&(this.children=this.repositories.sort((e,t)=>e.index-t.index).filter(e=>!e.closed).map(e=>new wi(Ae.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new bi(this.explorer))),this.children}refresh(){this.resetChildren()}getTreeItem(){const e=new N.TreeItem("Repositories",N.TreeItemCollapsibleState.Expanded);return e.contextValue=Kt.Repositories,e}}function Fi(){return!mr.get(mr.name("advanced")("quickPick")("closeOnFocusOut").value)}function Pi(e,t){const i=new N.CancellationTokenSource;return async function(e,t,i){const s=i&&await lr.keyboard.beginScope(i);try{await N.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Fi()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Ri{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):N.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class Ti extends Ri{constructor(e){super({label:e,description:""})}}class Ei extends Ri{constructor(e,t){super({label:"",description:""},e,t)}}class Bi extends Ri{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Ps(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ai extends Ri{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Ps(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ni{constructor(e){this.commit=e;const t=e.getShortMessage(`${j.Space}$(ellipsis)`);e.isStash?(this.label=t,this.description="",this.detail=`${j.Space} ${e.stashName||e.shortSha} ${w.pad(j.Dot,1,1)} ${e.formattedDate} ${w.pad(j.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${w.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${j.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${w.pad(j.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Li extends Ri{constructor(e,t={label:"Show in Results",description:`${w.pad(j.Dash,2,2)} displays commit in the GitLens Results explorer`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){lr.resultsExplorer.showCommitInResults(this.commit)}}class Ui extends Ri{constructor(e,t,i={label:"Show in Results",description:`${w.pad(j.Dash,2,2)} displays commits in the GitLens Results explorer`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){lr.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Oi extends Ui{constructor(e,t,i={label:"Show in Results",description:`${w.pad(j.Dash,2,2)} displays results in the GitLens Results explorer`}){super(e,{label:t},i),this.results=e,this.search=t}}class Ii extends Ri{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${w.pad(j.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Qi.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([lr.git.getBranches(this.repoPath),lr.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Qi.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.cancel()}}}const Mi=Object.create(null),Wi=["left","right",",",".","escape"],Hi=[];class Gi extends N.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||Mi}async dispose(){const e=Hi.indexOf(this.mapping);Ce.log("KeyboardScope.dispose",Hi.length,e),e===Hi.length-1?(Hi.pop(),await this.updateKeyCommandsContext(Hi[Hi.length-1])):Hi.splice(e,1)}async begin(){return Hi.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Hi[Hi.length-1];t===this.mapping&&t[e]&&(Ce.log("KeyboardScope.clearKeyCommand",Hi.length,e),t[e]=void 0,await Q(`${H.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Hi[Hi.length-1];i===this.mapping&&(Ce.log("KeyboardScope.setKeyCommand",Hi.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await Q(`${H.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Wi)t.push(Q(`${H.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class ji extends N.Disposable{constructor(){super(()=>this.dispose());const e=Wi.map(e=>N.commands.registerCommand(`${L}.key.${e}`,()=>this.execute(e),this));this._disposable=N.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return Ce.log("Keyboard.beginScope",Hi.length),await new Gi(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Hi.length)try{let t=Hi[Hi.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return Ce.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void Ce.error(e,"Keyboard.execute")}}}class Vi{constructor(e){this.branchOrTag=e,e instanceof Me?(this.label=`${e.current?`$(check)${j.Space}`:j.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${j.Space.repeat(2)} remote branch`:""):(this.label=`${j.Space.repeat(4)} ${e.name}`,this.description=`${j.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Me&&this.branchOrTag.remote}}class Qi{static showProgress(e){return Pi(e,{left:Mi,",":Mi,".":Mi})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new Vi(e)),...t.map(e=>new Vi(e)),...e.filter(e=>e.remote).map(e=>new Vi(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await lr.keyboard.beginScope({left:s.goBackCommand||Mi});s.progressCancellation&&s.progressCancellation.cancel();const a=await N.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Fi()});return await r.dispose(),a}}class Ki{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${j.Space}`:j.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${j.Space.repeat(2)} remote branch`:""}}class zi{static async show(e,t,i={}){const s=e.map(e=>new Ki(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await N.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Fi()})}}class qi extends Ri{constructor(e,t){super({label:`$(link-external) Open ${oe(t)} in ${e.provider.name}`,description:`${w.pad(j.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class Yi extends Ri{constructor(e,t,i){const s=oe(t);let o="";switch(t.type){case ie.Branch:o=`$(git-branch) ${t.branch}`;break;case ie.Branches:o="$(git-branch) Branches";break;case ie.Commit:o=`$(git-commit) ${qt.shortenSha(t.sha)}`;break;case ie.File:o=`$(file-text) ${ke.basename(t.fileName)}`;break;case ie.Repo:o="$(repo) Repository";break;case ie.Revision:if(void 0!==t.commit&&t.commit instanceof Qe)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${ke.basename(t.fileName)} in ${j.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${j.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${ke.basename(t.fileName)} in ${j.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":qt.shortenSha(t.sha);o=`$(file-text) ${ke.basename(t.fileName)}${e?` in ${j.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${j.Ellipsis}`,description:`${w.pad(j.Dash,2,3)} ${o}`},fs.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${w.pad(j.Dash,2,3)} $(repo) ${r.provider.path} ${w.pad(j.Dot,1,1)} ${o}`},fs.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class Xi{static async show(e,t,i,s){const o=e.map(e=>new qi(e,i));s&&o.splice(0,0,s);const r=await N.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Fi()});if(void 0!==r)return r}}class Zi{static showProgress(e){return Pi(`${e} history ${j.Dash} search by commit message, filename, or commit id`,{left:Mi,",":Mi,".":Mi})}static async show(e,t,i,s,o,r){const a=Array.from(m.map(e.commits.values(),e=>new Ni(e))),n=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to ${j.Space}$(git-branch) ${i} history`},fs.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await lr.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&a.splice(0,0,new Yi(h,{type:"branch",branch:i},n)),a.splice(0,0,new Ri({label:"$(search) Show Commit Search",description:`${w.pad(j.Dash,2,3)} search for commits by message, author, files, or commit id`},fs.ShowCommitSearch,[Ae.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new Ri({label:"$(sync) Show All Commits",description:`${w.pad(j.Dash,2,3)} this may take a while`},fs.ShowQuickBranchHistory,[Ae.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new Ri({label:"$(arrow-right) Show Next Commits",description:`${w.pad(j.Dash,2,3)} shows ${e.maxCount} newer commits`},fs.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=m.last(e.commits.values());null!=n&&(c=new Ri({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(j.Dash,2,3)} shows ${e.maxCount} older commits`},fs.ShowQuickBranchHistory,[new Ae(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await lr.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await N.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${j.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Fi()});return await l.dispose(),d}}class Ji extends Ri{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${w.pad(j.Dash,2,3)} $(file-text) ${ke.basename(e.fileName)} in ${j.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await lr.git.checkoutFile(e),Ps(e,{preserveFocus:!0,preview:!1})}}class es extends Bi{constructor(e,t){super(N.Uri.file(ke.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${w.pad(j.Dash,2,3)} ${ke.basename(e.fileName)}`})}}class ts extends Bi{constructor(e,t){let i,s;"D"===e.status?(s=Ae.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${w.pad(j.Dash,2,3)} ${ke.basename(e.fileName)} in ${j.Space}$(git-commit) ${e.previousShortSha} (deleted in ${j.Space}$(git-commit) ${e.shortSha})`):(s=Ae.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${w.pad(j.Dash,2,3)} ${ke.basename(e.fileName)} in ${j.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class is{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&ke.basename(e.workingFileName)||ke.basename(e.fileName),h=e.isUncommitted;if(h){const t=await lr.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new Ji(e)),e.previousFileShortSha&&r.push(new Ri({label:"$(git-compare) Open Changes",description:`${w.pad(j.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${j.Space} $(git-compare) ${j.Space} $(git-commit) ${e.shortSha}`},fs.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Ri({label:"$(git-compare) Open Changes with Working Tree",description:`${w.pad(j.Dash,2,3)} $(git-commit) ${e.shortSha} ${j.Space} $(git-compare) ${j.Space} $(file-text) ${n}`},fs.DiffWithWorking,[N.Uri.file(ke.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new es(e)),r.push(new ts(e));const c=await lr.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await lr.git.getBranch(e.repoPath);void 0!==t&&r.push(new Yi(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new Yi(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new Ji(e)),r.push(new Ri({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(j.Dash,2,3)} ${e.shortSha}`},fs.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Ri({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(j.Dash,2,3)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`},fs.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Ri({label:"$(history) Show File History",description:`${w.pad(j.Dash,2,3)} of ${ke.basename(e.fileName)}`},fs.ShowQuickFileHistory,[N.Uri.file(ke.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new Ri({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${w.pad(j.Dash,2,3)} of ${ke.basename(e.fileName)} ${w.pad(j.Dot,1,1)} from ${j.Space}$(git-commit) ${e.shortSha}`},fs.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new Ri({label:"$(git-commit) Show Commit Details",description:`${w.pad(j.Dash,2,3)} $(git-commit) ${e.shortSha}`},fs.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await lr.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:lr.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Mi;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=m.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?Mi:new Ei(fs.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await lr.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?Mi:new Ei(fs.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new Ei(fs.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new Ei(fs.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const u=await lr.keyboard.beginScope({left:i,",":l,".":d}),g=await N.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${w.pad(j.Dot,1,1)} ${h?`Uncommitted ${j.ArrowRightHollow} `:""}${e.shortSha} ${w.pad(j.Dot,1,1)} ${e.author}, ${e.formattedDate} ${w.pad(j.Dot,1,1)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`,ignoreFocusOut:Fi(),onDidSelectItem:e=>{u.setKeyCommand("right",e)}});return await u.dispose(),g}}class ss extends Bi{constructor(e,t){const i=st(t.status),s=tt.getFormattedDirectory(t,!0);super(Ae.toRevisionUri(e.sha,t,e.repoPath),{label:`${w.pad(i,4,2)} ${ke.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):N.commands.executeCommand(fs.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class os extends Ai{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>Ae.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class rs extends Ai{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>Ae.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${w.pad(j.Dash,2,3)} in ${j.Space}$(git-commit) ${e.shortSha}`})}}class as{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new ss(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new Ri({label:"$(git-pull-request) Apply Stashed Changes",description:`${w.pad(j.Dash,2,3)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`},fs.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Ri({label:"$(x) Delete Stashed Changes",description:`${w.pad(j.Dash,2,3)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`},fs.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Li(e));else{r.splice(n++,0,new Li(e));const t=await lr.git.getRemotes(e.repoPath);t.length&&r.splice(n++,0,new Yi(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new os(e)),r.splice(n++,0,new rs(e)),r.splice(n++,0,new Ri({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${w.pad(j.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${j.Space} $(git-compare) ${j.Space} $(git-commit) ${e.shortSha}`},fs.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new Ri({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${w.pad(j.Dash,2,3)} $(git-commit) ${e.shortSha} ${j.Space} $(git-compare) ${j.Space} $(file-directory) Working Tree`},fs.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new Ri({label:"$(clippy) Copy Commit ID to Clipboard",description:`${w.pad(j.Dash,2,3)} ${e.shortSha}`},fs.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new Ri({label:"$(clippy) Copy Commit Message to Clipboard",description:`${w.pad(j.Dash,2,3)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`},fs.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new Ri({label:"Changed Files",description:e.getDiffStatus()},fs.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await lr.git.getLog(e.repoPath,{maxCount:lr.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Mi:new Ei(fs.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await lr.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&m.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Mi:new Ei(fs.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new Ei(fs.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new Ei(fs.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await lr.keyboard.beginScope({left:i,",":h,".":c}),d=await N.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${w.pad(j.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${w.pad(j.Dot,1,1)} ${e.getShortMessage(`${j.Space}$(ellipsis)`)}`,ignoreFocusOut:Fi(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class ns{static showProgress(e){return Pi(e,{left:Mi,",":Mi,".":Mi})}static async show(e,t,i,s){const o=e&&[...m.map(e.commits.values(),e=>new Ni(e))]||[new Ti("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await lr.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await N.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Fi()});return await r.dispose(),a}}class hs{static showProgress(e){return Pi(e,{left:Mi,",":Mi,".":Mi})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(m.map(e.commits.values(),e=>new Ni(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new Ii(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await lr.git.findWorkingFileName(ke.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new Ri({label:"$(history) Show File History",description:`${w.pad(j.Dash,2,3)} of ${ke.basename(i)}`},fs.ShowQuickFileHistory,[N.Uri.file(ke.resolve(e.repoPath,i)),{goBackCommand:new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to history of ${j.Space}$(file-text) ${ke.basename(t.fsPath)}${t.sha?` from ${j.Space}$(git-commit) ${t.shortSha}`:""}`},fs.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await lr.git.getBranch(t.repoPath);if(void 0!==i){const a=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to history of ${j.Space}$(file-text) ${ke.basename(t.fsPath)}${t.sha?` from ${j.Space}$(git-commit) ${t.shortSha}`:""}`},fs.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new Ri({label:"$(history) Show Branch History",description:`${w.pad(j.Dash,2,3)} shows  ${j.Space}$(git-branch) ${i.name} history`},fs.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=await lr.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new Yi(n,e,a))}}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await lr.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await N.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Fi()});return await a.dispose(),n}}class cs{static async show(){const e=Object.keys(lr.config.modes);if(0===e.length)return;const t=lr.config.mode.active,i=e.map(e=>{const i=lr.config.modes[e];return{label:`${t===e?"$(check)  ":"     "}${i.name} mode`,description:i.description?` ${j.Dash}  ${i.description}`:"",key:e}});return t&&i.splice(0,0,{label:`Exit ${lr.config.modes[t].name} mode`,key:void 0}),await N.window.showQuickPick(i,{placeHolder:"select a GitLens mode to enter"})}}class ls{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class ds{static async show(e,t){const i=[...m.map(await lr.git.getRepositories(),e=>new ls(e))];return void 0!==t&&i.splice(0,0,t),await N.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Fi()})}}class us extends Bi{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":j.Space.repeat(3)}${w.pad(s,2,2)} ${ke.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new Qe(Le.File,e.repoPath,qt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new Qe(Le.File,e.repoPath,qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?qt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return N.commands.executeCommand(fs.DiffWithPrevious,Ae.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class ms extends Ri{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},fs.OpenChangedFiles,[void 0,{uris:i}])}}class gs{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...m.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new us(e.with({indexStatus:null}),e.indexStatus),new us(e.with({workTreeStatus:null}))]:[new us(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to ${j.Space}$(git-branch) ${e.branch} status`},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new Ri({label:"Unstaged Files",description:o.unstagedStatus},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new ms(o.stagedAddsAndChanges,{label:`${j.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new ms(o.unstagedAddsAndChanges,{label:`${j.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Ri({label:"Staged Files",description:o.stagedStatus},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Ri({label:"Unstaged Files",description:o.unstagedStatus},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new ms(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Ri({label:"$(x) Close Unchanged Files",description:""},fs.CloseUnchangedFiles))):i.push(new Ri({label:"No changes in the working tree",description:""},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Ri({label:"$(inbox) Show Stashed Changes",description:`${w.pad(j.Dash,2,3)} shows stashed changes in the repository`},fs.ShowQuickStashList,[Ae.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Ri({label:`$(cloud-upload)${j.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${j.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(j.Dash,2,3)} shows commits in ${j.Space}$(git-branch) ${e.branch} but not ${j.Space}$(git-branch) ${e.upstream}`},fs.ShowQuickBranchHistory,[Ae.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Ri({label:`$(cloud-download)${j.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${j.Space}$(git-branch) ${e.upstream}`,description:`${w.pad(j.Dash,2,3)} shows commits in ${j.Space}$(git-branch) ${e.upstream} but not ${j.Space}$(git-branch) ${e.branch}${e.sha?` (since ${j.Space}$(git-commit) ${qt.shortenSha(e.sha)})`:""}`},fs.ShowQuickBranchHistory,[Ae.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Ri({label:`$(git-branch) ${e.branch} is up-to-date with ${j.Space}$(git-branch) ${e.upstream}`,description:""},fs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await lr.keyboard.beginScope({left:t}),a=await N.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${w.pad(j.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Fi(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class ps{static showProgress(e){return Pi("apply"===e?`Apply stashed changes to your working tree${j.Ellipsis}`:`stashed changes ${j.Dash} search by message, filename, or commit id`,{left:Mi,",":Mi,".":Mi})}static async show(e,t,i,s,o){const r=e&&Array.from(m.map(e.commits.values(),e=>new Ni(e)))||[];if("list"===t&&r.splice(0,0,new Ri({label:"$(plus) Stash Changes",description:`${w.pad(j.Dash,2,3)} stashes all changes`},fs.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await lr.keyboard.beginScope({left:s});i.cancel();const n=await N.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${j.Ellipsis}`:`stashed changes ${j.Dash} search by message, filename, or commit id`,ignoreFocusOut:Fi()});return await a.dispose(),n}}var fs;function vs(e,t){if(e instanceof N.Uri)return e;if(null==t)return;const i=t.document;return null!=i?i.uri:void 0}async function ws(e,t,i,s){let o=await lr.git.getRepoPathOrActive(e,t);if(!o){const e=await ds.show(i,s);if(e instanceof Ri)return void await e.execute();if(void 0===e)return void(void 0!==s&&await s.execute());o=e.repoPath}return o}function bs(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Me}function Cs(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof Oe}function ys(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof Ye}function xs(e){return null!=e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function $s(e){return null!=e&&null!=e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithPreviousInDiff="gitlens.diffWithPreviousInDiff",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowGitExplorer="gitlens.showGitExplorer",e.ShowHistoryExplorer="gitlens.showHistoryExplorer",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowResultsExplorer="gitlens.showResultsExplorer",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.SwitchMode="gitlens.switchMode",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame",e.ToggleReviewMode="gitlens.toggleReviewMode",e.ToggleZenMode="gitlens.toggleZenMode"}(fs||(fs={}));class Ss extends N.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=N.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>N.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=N.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=Ss.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(null==o||function(e){return null!=e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(null==o||o instanceof N.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof Yt){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if($s(o)){const t=[];let s=0;for(const e of i){if(!$s(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(xs(o)){const t=[];let s=0;for(const e of i){if(!xs(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Ds extends Ss{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,N.window.activeTextEditor,...t)}}let _s=void 0;class ks extends Ds{constructor(e){super(e)}_execute(e,...t){return _s={command:e,args:t},super._execute(e,...t)}}class Fs extends N.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(N.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=N.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Ps(e,t={}){const{rethrow:i}=t,s=c.__rest(t,["rethrow"]);try{if(e instanceof Ae&&(e=e.fileUri({noSha:!0})),e.scheme===G.GitLensGit){const t=Ae.fromRevisionUri(e);if(q.includes(ke.extname(t.fsPath))){const i=await lr.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==i)return e=N.Uri.file(i),void await N.commands.executeCommand(W.Open,e)}}const o=await N.workspace.openTextDocument(e);return N.window.showTextDocument(o,Object.assign({preserveFocus:!1,preview:!0,viewColumn:N.ViewColumn.Active},s))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await N.commands.executeCommand(W.Open,e);if(i)throw t;return void Ce.error(t,"openEditor")}}class Rs extends Fs{constructor(){super([fs.ClearFileAnnotations,fs.ComputingFileAnnotations])}async execute(e,t,i){if(null!=e){if(null!=i&&!ee.equals(i,e.document.uri)){const t=N.window.visibleTextEditors.find(e=>ee.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return lr.fileAnnotations.clear(e)}catch(e){return Ce.error(e,"ClearFileAnnotationsCommand"),N.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Ts extends N.Disposable{constructor(){super(()=>this.dispose());const e=u.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=N.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return N.commands.executeCommand(W.CloseActiveEditor)}async next(){return N.commands.executeCommand(W.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(N.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}class Es extends Ds{constructor(){super(fs.CloseUnchangedFiles)}async execute(e,t,i={}){t=vs(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await ws(t,e,`Close unchanged files in which repository${j.Ellipsis}`);if(!s)return;const o=await lr.git.getStatusForRepo(s);if(void 0===o)return N.window.showWarningMessage("Unable to close unchanged files");i.uris=o.files.map(e=>e.uri)}if(0===i.uris.length)return N.commands.executeCommand(W.CloseAllEditors);const s=new Ts;let o=0,r=void 0;for(e=N.window.activeTextEditor;;){if(null!=e){if(J.equals(r,e,{useId:!0,usePosition:!0}))break;if(void 0!==e.document&&(e.document.isDirty||i.uris.some(t=>ee.equals(t,e.document&&e.document.uri)))){const t=r;if(r=e,e=await s.awaitNext(500),J.equals(t,e,{useId:!0,usePosition:!0}))break;continue}}if(r=e,e=await s.awaitClose(500),void 0===r&&null==e){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return Ce.error(e,"CloseUnchangedFilesCommand"),N.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Bs extends Ds{constructor(){super(fs.CopyMessageToClipboard)}async preExecute(e,t={}){return Cs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=vs(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await lr.git.getActiveRepoPath(e);if(!t)return;const i=await lr.git.getLog(t,{maxCount:1});if(!i)return;return s.message=m.first(i.commits.values()).message,void o.copy(s.message)}const i=await Ae.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await lr.git.getBlameForLineContents(i,t,e.document.getText()):await lr.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return Ce.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await lr.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void N.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");Ce.error(e,"CopyMessageToClipboardCommand"),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return Ce.error(e,"CopyMessageToClipboardCommand"),N.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class As extends Ds{constructor(){super(fs.CopyShaToClipboard)}async preExecute(e,t={}){return Cs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=vs(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await lr.git.getActiveRepoPath(e);if(!t)return;const i=await lr.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=m.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await Ae.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await lr.git.getBlameForLineContents(i,t,e.document.getText()):await lr.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return Ce.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void N.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");Ce.error(e,"CopyShaToClipboardCommand"),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return Ce.error(e,"CopyShaToClipboardCommand"),N.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}class Ns extends Ds{constructor(){super([fs.DiffHeadWithBranch,fs.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case fs.DiffHeadWithBranch:t.ref2="HEAD";break;case fs.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=vs(t,e);try{const o=await ws(t,e,`Compare with branch or tag in which repository${j.Ellipsis}`);if(!o)return;if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${j.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to ${j.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${j.Ellipsis}`}s=Qi.showProgress(e);const[t,r]=await Promise.all([lr.git.getBranches(o),lr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Qi.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Ri)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void lr.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return Ce.error(e,"DiffBranchWithBranchCommand"),N.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.cancel()}}}class Ls extends Ds{constructor(){super([fs.DiffDirectory,fs.ExternalDiffAll,fs.ExplorersOpenDirectoryDiff,fs.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case fs.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case fs.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof Si&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case fs.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof Xt})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=vs(t,e);try{const o=await ws(t,e,`Compare directory in which repository${j.Ellipsis}`);if(!o)return;if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${j.Ellipsis}`;s=Qi.showProgress(e);const[t,r]=await Promise.all([lr.git.getBranches(o),lr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await Qi.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Ri)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void lr.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await N.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return N.commands.executeCommand(W.Open,N.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return Ce.error(e,"DiffDirectoryCommand"),N.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.cancel()}}}var Us,Os,Is;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitDisabledWarning="suppressGitDisabledWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice"}(Us||(Us={}));class Ms{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Ms.showMessage("info","Commit has no previous commit.",Us.CommitHasNoPreviousCommitWarning):Ms.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,Us.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Ms.showMessage("warn",`${e}. The commit could not be found.`,Us.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Ms.showMessage("warn",`${e}. The file is probably not under source control.`,Us.FileNotUnderSourceControlWarning)}static showGitDisabledErrorMessage(){return Ms.showMessage("error","GitLens requires Git to be enabled. Please re-enable Git — set `git.enabled` to true and reload",Us.GitDisabledWarning)}static showGitVersionUnsupportedErrorMessage(e){return Ms.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,Us.GitVersionWarning)}static async showKeyBindingsInfoMessage(){if(lr.config.advanced.messages.suppressShowKeyBindingsNotice)return;if(lr.config.keymap!==E.Alternate)return void await this.suppressedMessage(Us.ShowKeyBindingsNotice);const e=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],t=await Ms.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",Us.ShowKeyBindingsNotice,null,...e);switch(t){case e[1]:await mr.update(mr.name("keymap").value,E.Chorded,N.ConfigurationTarget.Global);break;case e[2]:await mr.update(mr.name("keymap").value,E.None,N.ConfigurationTarget.Global)}return t}static showLineUncommittedWarningMessage(e){return Ms.showMessage("warn",`${e}. The line has uncommitted changes.`,Us.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Ms.showMessage("warn",`${e}. No repository could be found.`,Us.NoRepositoryWarning)}static async showMessage(e,t,i,s={title:"Don't Show Again"},...o){if(Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),mr.get(mr.name("advanced")("messages")(i).value))return void Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await N.window.showInformationMessage(t,...o);break;case"warn":r=await N.window.showWarningMessage(t,...o);break;case"error":r=await N.window.showErrorMessage(t,...o)}return null!==s&&r!==s||(Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`),await this.suppressedMessage(i),r!==s)?(Ce.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r?r.title:r}`),r):void 0}static suppressedMessage(e){const t=mr.name("advanced")("messages").value,i=mr.get(t);i[e]=!0;for(const[e,t]of Object.entries(i))!0!==t&&(i[e]=void 0);return mr.update(t,i,N.ConfigurationTarget.Global)}}class Ws extends Ds{constructor(){super(fs.DiffLineWithPrevious)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||qt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await lr.git.getBlameForLineContents(s,t,e.document.getText()):await lr.git.getBlameForLine(s,t);if(void 0===o)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await lr.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:qt.stagedUncommittedSha}))}}catch(e){return Ce.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:qt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,o)}}class Hs extends Ds{constructor(){super(fs.DiffLineWithWorking)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||qt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await lr.git.getBlameForLineContents(s,t,e.document.getText()):await lr.git.getBlameForLine(s,t);if(void 0===o)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await lr.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?qt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return Ce.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,o)}}class Gs extends Ds{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Oe){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:qt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(fs.DiffWith,i)}constructor(){super(fs.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{qt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await lr.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),qt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await lr.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([lr.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),lr.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=qt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==qt.deletedSha||(o="added in ");let r="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(r="not in ",o=""):r="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==qt.deletedSha&&(void 0!==t||""!==r)){const e=qt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${ke.basename(i.lhs.uri.fsPath)}${""!==e?` (${r}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==qt.deletedSha){const e=qt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${ke.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${j.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=N.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new N.Range(i.line,0,i.line,0)),await N.commands.executeCommand(W.Diff,void 0===t?Ae.toRevisionUri(qt.deletedSha,i.lhs.uri.fsPath,i.repoPath):N.Uri.file(t),void 0===s?Ae.toRevisionUri(qt.deletedSha,i.rhs.uri.fsPath,i.repoPath):N.Uri.file(s),a,i.showOptions)}catch(e){return Ce.error(e,"DiffWithCommand","getVersionedFile"),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class js extends Ds{constructor(){super(fs.DiffWithBranch)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Ae.fromUri(t);if(!s.repoPath)return Ms.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${ke.basename(s.fsPath)} with ${j.Ellipsis}`,r=Qi.showProgress(o);try{const[e,t]=await Promise.all([lr.git.getBranches(s.repoPath),lr.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await Qi.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof Ri)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await lr.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=w.normalizePath(ke.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=N.Uri.file(ke.join(s.repoPath,t.originalFileName)),c=`${ke.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${ke.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,d)}finally{r.cancel()}}}class Vs extends Ds{constructor(){super(fs.DiffWithNext)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Ae.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof Qe)||void 0!==i.range)try{const r=void 0===i.commit?s.sha:i.commit.sha;if(qt.isStagedUncommitted(r)){const e={repoPath:s.repoPath,lhs:{sha:r,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,e)}const a=await lr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==r?void 0:2,range:i.range,renames:!0});if(void 0===a)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=r&&a.commits.get(r)||m.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await lr.git.getStatusForFile(s.repoPath,s.fsPath)))return N.commands.executeCommand(fs.DiffWithWorking,t)}catch(e){return Ce.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await lr.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:qt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,e)}return N.commands.executeCommand(fs.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,r)}}class Qs extends Ds{constructor(){super([fs.DiffWithPrevious,fs.DiffWithPreviousInDiff])}async preExecute(e,t={}){return e.command===fs.DiffWithPreviousInDiff&&(t.inDiffEditor=!0),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Ae.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===qt.deletedSha)return Ms.showCommitHasNoPreviousCommitWarningMessage();let o=!1;qt.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0),i.inDiffEditor&&void 0!==s&&(s+="^");const r=await lr.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||m.first(r.commits.values()),void 0===e.sha){const s=await lr.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.previousSha||qt.deletedSha:i.commit.sha,uri:i.inDiffEditor?i.commit.previousUri:i.commit.uri},rhs:{sha:i.inDiffEditor?i.commit.sha:qt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.sha:qt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:i.inDiffEditor?qt.stagedUncommittedSha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,e)}if(!i.inDiffEditor)return N.commands.executeCommand(fs.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return Ce.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:qt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,s)}}class Ks extends Ds{constructor(){super(fs.DiffWithRevision)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Ae.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${w.pad(j.Dot,1,1)} ${s.shortSha}`:""} with ${j.Ellipsis}`,r=hs.showProgress(o);try{const a=await lr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===a)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Ri({label:"$(arrow-right) Show Next Commits",description:`${w.pad(j.Dash,2,3)} shows ${a.maxCount} newer commits`},fs.DiffWithRevision,[t,Object.assign({},i)]),s=m.last(a.commits.values());null!=s&&(n=new Ri({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(j.Dash,2,3)} shows ${a.maxCount} older commits`},fs.DiffWithRevision,[new Ae(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await hs.show(a,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to history of ${j.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${j.Space}$(git-commit) ${s.shortSha}`:""}`},fs.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Ri({label:"$(sync) Show All Commits",description:`${w.pad(j.Dash,2,3)} this may take a while`},fs.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof Ii){const e=await h.execute();if(void 0===e)return;if(e instanceof Ri)return e.execute();c=e.name}else{if(h instanceof Ri)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await N.commands.executeCommand(fs.DiffWith,l)}catch(e){return Ce.error(e,"DiffWithRevisionCommand"),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.cancel()}}}class zs extends Ds{constructor(){super(fs.DiffWithWorking)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||qt.isUncommitted(i.commit.sha)){if(void 0===s.sha)return N.window.showInformationMessage("File matches the working tree");if(qt.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await lr.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:qt.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,e)}}try{if(i.commit=await lr.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return Ce.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),N.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await lr.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return N.commands.executeCommand(fs.DiffWith,r)}}!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Os||(Os={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Is||(Is={}));class qs{constructor(e,t){this.uri=e,this.staged=t}}class Ys extends Ss{constructor(){super(fs.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new qs(e.resourceUri,e.resourceGroupType===Is.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new qs(e.resourceUri,e.resourceGroupType===Is.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Os.BOTH_MODIFIED||t===Os.INDEX_MODIFIED||t===Os.MODIFIED}async execute(e={}){try{const t=await ws(void 0,void 0,`Open changes from which repository${j.Ellipsis}`);if(!t)return;const i=await lr.git.getDiffTool(t);if(void 0===i){if(!await N.window.showWarningMessage("Unable to open changes in diff tool because there is no Git diff tool configured","View Git Docs"))return;return N.commands.executeCommand(W.Open,N.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await lr.git.getStatusForRepo(t);if(void 0===i)return N.window.showWarningMessage("Unable to open changes in diff tool");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new qs(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new qs(t.uri,!1))}for(const s of e.files)lr.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return Ce.error(e,"ExternalDiffCommand"),N.window.showErrorMessage("Unable to open changes in diff tool. See output channel for more details")}}}class Xs extends Ds{constructor(){super(fs.OpenBranchesInRemote)}async preExecute(e,t={}){return ys(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=vs(t,e))&&await Ae.fromUri(t),o=await ws(s,e,`Open branches in remote for which repository${j.Ellipsis}`);if(o)try{const s=await lr.git.getRemotes(o);return N.commands.executeCommand(fs.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenBranchesInRemoteCommand"),N.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class Zs extends Ds{constructor(){super(fs.OpenBranchInRemote)}async preExecute(e,t={}){return bs(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=vs(t,e))&&await Ae.fromUri(t),o=await ws(s,e,`Open branch in remote for which repository${j.Ellipsis}`);if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await lr.git.getBranches(o),t=await zi.show(e,`Open which branch in remote${j.Ellipsis}`);if(void 0===t)return;if(t instanceof Ri)return;if(i.branch=t.branch.name,void 0===i.branch)return}const s=await lr.git.getRemotes(o);return N.commands.executeCommand(fs.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenBranchInRemoteCommandArgs"),N.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class Js extends Ds{constructor(){super(fs.OpenChangedFiles)}async execute(e,t,i={}){t=vs(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await ws(t,e,`Open changed files in which repository${j.Ellipsis}`);if(!s)return;const r=await lr.git.getStatusForRepo(s);if(void 0===r)return N.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(r.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Ps(e,{preserveFocus:!0,preview:!1});return}catch(e){return Ce.error(e,"OpenChangedFilesCommand"),N.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class eo extends Ds{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(fs.OpenCommitInRemote,t)}constructor(){super(fs.OpenCommitInRemote)}async preExecute(e,t={}){return Cs(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=null==e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await lr.git.getBlameForLineContents(s,t,e.document.getText()):await lr.git.getBlameForLine(s,t);if(void 0===o)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=await lr.git.getRemotes(s.repoPath);return N.commands.executeCommand(fs.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return Ce.error(e,"OpenCommitInRemoteCommand"),N.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class to extends Ds{constructor(){super(fs.OpenFileInRemote)}async preExecute(e,t={range:!0}){return Cs(e)?((t=Object.assign({},t)).range=!1,bs(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await lr.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=await lr.git.getRemotes(s.repoPath),r=i.range&&null!=e?new N.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return N.commands.executeCommand(fs.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return Ce.error(e,"OpenFileInRemoteCommand"),N.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class io extends Ds{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof N.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(fs.OpenFileRevision,s)}constructor(){super(fs.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=vs(t,e)))return;const o=await Ae.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${w.pad(j.Dot,1,1)} ${o.shortSha}`:""} in revision ${j.Ellipsis}`;s=hs.showProgress(r);const a=await lr.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Ri({label:"$(arrow-right) Show Next Commits",description:`${w.pad(j.Dash,2,3)} shows ${a.maxCount} newer commits`},fs.OpenFileRevision,[t,Object.assign({},i)]),s=m.last(a.commits.values());null!=s&&(n=new Ri({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(j.Dash,2,3)} shows ${a.maxCount} older commits`},fs.OpenFileRevision,[new Ae(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await hs.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to history of ${j.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${j.Space}$(git-commit) ${o.shortSha}`:""}`},fs.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Ri({label:"$(sync) Show All Commits",description:`${w.pad(j.Dash,2,3)} this may take a while`},fs.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof Ii){const e=await h.execute();if(void 0===e)return;if(e instanceof Ri)return e.execute();i.uri=Ae.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Ri)return h.execute();i.uri=Ae.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new N.Range(i.line,0,i.line,0));const o=await Ps(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:lr.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return Ce.error(e,"OpenFileRevisionCommand"),N.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.cancel()}}}class so extends Ds{constructor(){super(fs.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length)return this.ensureRemoteBranchName(i),new qi(i.remotes[0],i.resource).execute();let t="";switch(i.resource.type){case ie.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${j.Ellipsis}`;break;case ie.Commit:t=`open commit ${qt.shortenSha(i.resource.sha)} in${j.Ellipsis}`;break;case ie.File:t=`open ${i.resource.fileName} in${j.Ellipsis}`;break;case ie.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof Qe)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${w.pad(j.Dot,1,1)} ${i.resource.commit.previousShortSha} in${j.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${w.pad(j.Dot,1,1)} ${i.resource.commit.shortSha} in${j.Ellipsis}`);else{const e=void 0===i.resource.sha?"":qt.shortenSha(i.resource.sha),s=e?` ${w.pad(j.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${j.Ellipsis}`}}if(1===i.remotes.length)return new qi(i.remotes[0],i.resource).execute();const s=await Xi.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return s.execute()}catch(e){return Ce.error(e,"OpenInRemoteCommand"),N.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class oo extends Ds{constructor(){super(fs.OpenRepoInRemote)}async preExecute(e,t={}){return ys(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=vs(t,e))&&await Ae.fromUri(t),o=await ws(s,e,`Open which repository in remote${j.Ellipsis}`);if(o)try{const s=await lr.git.getRemotes(o);return N.commands.executeCommand(fs.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return Ce.error(e,"OpenRepoInRemoteCommand"),N.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class ro extends Ds{constructor(){super(fs.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=vs(t,e)))return;if(i.uri=await Ae.fromUri(t),i.uri instanceof Ae&&i.uri.sha){const[e,t]=await lr.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Ae(N.Uri.file(ke.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new N.Range(i.line,0,i.line,0));const s=await Ps(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:lr.fileAnnotations.show(s,i.annotationType,i.line)}catch(e){return Ce.error(e,"OpenWorkingFileCommand"),N.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class ao extends Ss{constructor(){super(fs.ResetSuppressedWarnings)}async execute(){await mr.update(mr.name("advanced")("messages").value,void 0,N.ConfigurationTarget.Global)}}const no=/^([@~=:#])/,ho=new Map([["@",Vt.Author],["~",Vt.Changes],["=",Vt.ChangedOccurrences],[":",Vt.Files],["#",Vt.Sha]]);class co extends ks{constructor(){super(fs.ShowCommitSearch)}async execute(e,t,i={}){const s=(t=vs(t,e))&&await Ae.fromUri(t),o=await ws(s,e,`Search for commits in which repository${j.Ellipsis}`,i.goBackCommand);if(!o)return;i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&null!=e&&null!=s){const t=await lr.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){Ce.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await N.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=no.exec(i.search);t&&t[1]?(i.searchBy=ho.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):qt.isSha(i.search)?i.searchBy=Vt.Sha:i.searchBy=Vt.Message}void 0===i.searchBy&&(i.searchBy=Vt.Message);let a=void 0;switch(i.searchBy){case Vt.Author:a=`commits with an author matching '${i.search}'`;break;case Vt.Changes:a=`commits with changes matching '${i.search}'`;break;case Vt.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Vt.Files:a=`commits with files matching '${i.search}'`;break;case Vt.Message:a=`commits with a message matching '${i.search}'`;break;case Vt.Sha:a=`commits with an id matching '${i.search}'`}const n=ns.showProgress(a);try{const s=await lr.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to commit search`},fs.ShowCommitSearch,[t,r]),c=await ns.show(s,a,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new Ri({label:"$(sync) Show All Commits",description:`${w.pad(j.Dash,2,3)} this may take a while`},fs.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new Oi(s,a):void 0});if(void 0===c)return;return c instanceof Ri?c.execute():N.commands.executeCommand(fs.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,2)} to search for ${a}`},fs.ShowCommitSearch,[t,i])})}catch(e){return Ce.error(e,"ShowCommitSearchCommand"),N.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.cancel()}}}class lo extends Ss{constructor(){super(fs.ShowGitExplorer)}execute(){return lr.gitExplorer.show(P.Repository)}}class uo extends Ss{constructor(){super(fs.ShowHistoryExplorer)}execute(){return lr.config.historyExplorer.enabled?lr.historyExplorer.show():lr.gitExplorer.show(P.History)}}class mo extends Ss{constructor(){super(fs.ShowLastQuickPick)}async execute(){const e=_s;if(void 0!==e)try{return N.commands.executeCommand(e.command,...e.args)}catch(e){return Ce.error(e,"ShowLastQuickPickCommand"),N.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class go extends ks{constructor(){super(fs.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=vs(t,e))&&await Ae.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:Zi.showProgress(i.branch);try{const r=i.repoPath||await ws(s,e,`Show branch history in which repository${j.Ellipsis}`);if(!r)return;if(void 0===i.branch){const s=await lr.git.getBranches(r);let a;await lr.git.getRepoPathOrActive(t,e)||(a=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to which repository`},fs.ShowQuickBranchHistory,[t,i]));const n=await zi.show(s,`Show history for branch${j.Ellipsis}`,{goBackCommand:a});if(void 0===n)return;if(n instanceof Ri)return n.execute();if(i.branch=n.branch.name,void 0===i.branch)return;o=Zi.showProgress(i.branch)}if(void 0===i.log&&(i.log=await lr.git.getLog(r,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return N.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await Zi.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof Ri)return a.execute();const n=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to ${j.Space}$(git-branch) ${i.branch} history`},fs.ShowQuickBranchHistory,[t,Object.assign({},i)]);return N.commands.executeCommand(fs.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:n})}catch(e){return Ce.error(e,"ShowQuickBranchHistoryCommand"),N.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.cancel()}}}class po extends ks{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(fs.ShowQuickCommitDetails,t)}constructor(){super(fs.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Cs(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;const s=await Ae.fromUri(t);let o=s.repoPath,r=ke.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await lr.git.getBlameForLine(s,t);if(void 0===a)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(a.commit.isUncommitted)return Ms.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=a.commit.sha,o=a.commit.repoPath,r=a.commit.fileName,i.commit=a.commit}catch(e){return Ce.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await lr.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Ms.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Ms.showCommitNotFoundWarningMessage("Unable to show commit details");if(void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand){const e=await lr.git.getBranch(i.commit.repoPath);void 0!==e&&(i.goBackCommand=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to ${e.name} history`},fs.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]))}const s=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to details of ${j.Space}$(git-commit) ${i.commit.shortSha}`},fs.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),a=await as.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===a)return;return a instanceof ss?N.commands.executeCommand(fs.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.sha,goBackCommand:s}):a.execute()}catch(e){return Ce.error(e,"ShowQuickCommitDetailsCommand"),N.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class fo extends ks{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(fs.ShowQuickCommitFileDetails,t)}constructor(){super(fs.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,Cs(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Ae.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await lr.git.getBlameForLine(o,t);if(void 0===r)return Ms.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(r.commit.isUncommitted)return Ms.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=r.commit.sha,i.commit=r.commit,s=ke.relative(i.commit.repoPath,o.fsPath)}catch(e){return Ce.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),N.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await lr.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Ms.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Ms.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await lr.git.findWorkingFileName(i.commit);const r=qt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to details of ${j.Space}$(git-commit) ${r}`},fs.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to details of ${j.Space}$(file-text) ${ke.basename(i.commit.fileName)} in ${j.Space}$(git-commit) ${r}`},fs.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await is.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===n)return;return n instanceof Ri?n.execute():void 0}catch(e){return Ce.error(e,"ShowQuickCommitFileDetailsCommand"),N.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class vo extends ks{constructor(){super(fs.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=vs(t,e);try{const s=await ws(t,e,`Show current branch history for which repository${j.Ellipsis}`);if(!s)return;const o=await lr.git.getBranch(s);if(void 0===o)return;return N.commands.executeCommand(fs.ShowQuickBranchHistory,t,{branch:o.name,repoPath:s,goBackCommand:i.goBackCommand})}catch(e){return Ce.error(e,"ShowQuickCurrentBranchHistoryCommand"),N.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class wo extends ks{constructor(){super(fs.ShowQuickFileHistory)}async execute(e,t,i={}){if(null==(t=vs(t,e)))return N.commands.executeCommand(fs.ShowQuickCurrentBranchHistory);const s=await Ae.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${w.pad(j.Dot,1,1)} ${s.shortSha}`:""}`,r=hs.showProgress(o);try{if(void 0===i.log&&(i.log=await lr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Ms.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let a=void 0;if(i.log.truncated){const e=new Ri({label:"$(arrow-right) Show Next Commits",description:`${w.pad(j.Dash,2,3)} shows ${i.log.maxCount} newer commits`},fs.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=m.last(i.log.commits.values());null!=o&&(a=new Ri({label:"$(arrow-left) Show Previous Commits",description:`${w.pad(j.Dash,2,3)} shows ${i.log.maxCount} older commits`},fs.ShowQuickFileHistory,[new Ae(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await hs.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==i.log&&i.log.truncated?new Ri({label:"$(sync) Show All Commits",description:`${w.pad(j.Dash,2,3)} this may take a while`},fs.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Ui(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof Ri)return n.execute();const h=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to history of ${j.Space}$(file-text) ${ke.basename(n.commit.fileName)}${s.sha?` from ${j.Space}$(git-commit) ${s.shortSha}`:""}`},fs.ShowQuickFileHistory,[t,i]);return N.commands.executeCommand(fs.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return Ce.error(e,"ShowQuickFileHistoryCommand"),N.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.cancel()}}}class bo extends ks{constructor(){super(fs.ShowQuickRepoStatus)}async execute(e,t,i={}){t=vs(t,e);try{const s=await ws(t,e,`Show status for which repository${j.Ellipsis}`);if(!s)return;const o=await lr.git.getStatusForRepo(s);if(void 0===o)return N.window.showWarningMessage("Unable to show repository status");const r=await gs.show(o,i.goBackCommand);if(void 0===r)return;return r instanceof Ri?r.execute():void 0}catch(e){return Ce.error(e,"ShowQuickRepoStatusCommand"),N.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class Co extends ks{constructor(){super(fs.ShowQuickStashList)}async execute(e,t,i={}){t=vs(t,e);const s=ps.showProgress("list");try{const o=await ws(t,e,`Show stashed changes for which repository${j.Ellipsis}`);if(!o)return;const r=await lr.git.getStashList(o);if(void 0===r)return N.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to stashed changes`},fs.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await ps.show(r,"list",s,i.goBackCommand,a);if(void 0===n)return;return n instanceof Ri?n.execute():N.commands.executeCommand(fs.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:a})}catch(e){return Ce.error(e,"ShowQuickStashListCommand"),N.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.cancel()}}}class yo extends Ss{constructor(){super(fs.ShowResultsExplorer)}execute(){return lr.resultsExplorer.show()}}class xo extends Ss{constructor(){super(fs.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return Cs(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await lr.git.getActiveRepoPath();if(!i){const s=await ds.show(`Apply stashed changes from which repository${j.Ellipsis}`,e.goBackCommand);if(s instanceof Ri)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to pick another repository`},fs.StashApply,[e]),i=s.repoPath}const s=ps.showProgress("apply");try{const o=await lr.git.getStashList(i);if(void 0===o)return N.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new Ri({label:`go back ${j.ArrowBack}`,description:`${w.pad(j.Dash,2,3)} to apply stashed changes`},fs.StashApply,[e]),a=await ps.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof Ri)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.cancel()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${j.Ellipsis}`:e.stashItem.message,i=await N.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await lr.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return Ce.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?N.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?N.window.showInformationMessage("Stash applied with conflicts"):N.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class $o extends Ss{constructor(){super(fs.StashDelete)}async preExecute(e,t={confirm:!0}){return Cs(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${j.Ellipsis}`:e.stashItem.message,i=await N.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await lr.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return Ce.error(e,"StashDeleteCommand"),N.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class So extends Ss{constructor(){super(fs.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await lr.git.getHighlanderRepoPath();if(!t){const i=await ds.show(`Stash changes for which repository${j.Ellipsis}`,e.goBackCommand);if(i instanceof Ri)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await N.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await lr.git.stashSave(t,e.message,e.uris)}catch(e){Ce.error(e,"StashSaveCommand");const t=e&&e.message;return t.includes("newer version of Git")?N.window.showErrorMessage(`Unable to save stash. ${t}`):N.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class Do extends Ss{constructor(){super(fs.SwitchMode)}async execute(){const e=await cs.show();void 0!==e&&await mr.update(mr.name("mode")("active").value,e.key,N.ConfigurationTarget.Global)}}class _o extends Ss{constructor(){super(fs.ToggleReviewMode)}async execute(){if(!Object.keys(lr.config.modes).includes("review"))return;const e="review"===lr.config.mode.active?void 0:"review";await mr.update(mr.name("mode")("active").value,e,N.ConfigurationTarget.Global)}}class ko extends Ss{constructor(){super(fs.ToggleZenMode)}async execute(){if(!Object.keys(lr.config.modes).includes("zen"))return;const e="zen"===lr.config.mode.active?void 0:"zen";await mr.update(mr.name("mode")("active").value,e,N.ConfigurationTarget.Global)}}class Fo extends Ss{constructor(){super(fs.ToggleCodeLens)}execute(){return lr.codeLens.toggleCodeLens()}}class Po extends Ds{constructor(){super(fs.ToggleFileBlame)}async execute(e,t,i={}){if(null!=e&&null!=t&&!ee.equals(t,e.document.uri)){const i=N.window.visibleTextEditors.find(e=>ee.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:F.Blame})),lr.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return Ce.error(e,"ToggleFileBlameCommand"),N.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Ro extends Ds{constructor(){super(fs.ToggleFileHeatmap)}async execute(e,t){N.commands.executeCommand(fs.ToggleFileBlame,t,{type:F.Heatmap})}}class To extends Ds{constructor(){super(fs.ToggleFileRecentChanges)}async execute(e,t){N.commands.executeCommand(fs.ToggleFileBlame,t,{type:F.RecentChanges})}}class Eo extends Ds{constructor(){super(fs.ToggleLineBlame)}async execute(e,t){try{return lr.lineAnnotations.toggle(e)}catch(e){return Ce.error(e,"ToggleLineBlameCommand"),N.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const Bo=/[`\>\#\*\_\-\+\.]/g;class Ao{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=h.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${j.MuchGreaterThan}\`](${Gs.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===F.RecentChanges&&(i=F.Blame);const t=Ae.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${j.SquareWithTopShadow}\`](${io.getMarkdownCommandArgs(t,i||F.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${j.ArrowUpRight}\`](${eo.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${j.MiddleEllipsis}\`](${fo.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",a="",n="";if(e.isUncommitted)n=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{a=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${po.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=e.message;for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(Bo,"\\$&").replace(/^===/gm,`${j.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}const h=new N.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(lr.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${a}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&qt.isStagedUncommitted(t.sha)?`[\`Changes\`](${Gs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${j.Dash} &nbsp; [\`${e.previousShortSha}\`](${po.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${j.ArrowLeftRightLong} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Gs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${j.Dash} &nbsp; _uncommitted changes_\n${s}`:`[\`Changes\`](${Gs.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${j.Dash} &nbsp; [\`${e.previousShortSha}\`](${po.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${j.ArrowLeftRightLong} [\`${e.shortSha}\`](${po.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new N.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&qt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await lr.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=Gt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=w.pad(r.replace(/ /g,j.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let r=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){r=-1;break}r+=e.truncateTo}r>=0&&(r+=w.width(w.interpolate(i,void 0)))>0&&(r+=3);let a=void 0,n=void 0;return t.enabled&&(a="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new N.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:a,borderWidth:n,color:new N.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:r>=0?`${r}ch`:void 0,uncommittedColor:new N.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return Ao.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:j.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,s=!0){const o=Gt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new N.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new N.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:w.pad(o.replace(/ /g,j.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${s?"":" position: absolute;"}`}}}}}class No extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?lr.git.getBlameForFileContents(this._uri,e.document.getText()):lr.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?lr.git.getBlameForFileContents(this._uri,this.editor.document.getText()):lr.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=m.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new N.Range(e.line,0,e.line,M)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!lr.config.hovers.enabled||!lr.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(N.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(N.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=N.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await lr.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=Ao.getHoverMessage(o||s,lr.config.defaultDateFormat,await lr.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new N.Hover(r,e.validateRange(new N.Range(t.line,0,t.line,M)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await Ao.changesHover(s,t.line,await Ae.fromUri(e.uri));return void 0!==o.hoverMessage?new N.Hover(o.hoverMessage,e.validateRange(new N.Range(t.line,0,t.line,M))):void 0}async getCommitForHover(e){if("line"!==lr.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Lo extends No{async onProvideAnnotation(e,t){this.annotationType=F.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),r=lr.config.blame,a=w.getTokensFromTemplate(r.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===r.dateFormat?lr.config.defaultDateFormat:r.dateFormat,tokenOptions:a},h=Date.now(),c=r.avatars,l=lr.config.defaultGravatarsStyle,d=r.separateLines,u=Ao.gutterRenderOptions(d,r.heatmap,r.format,n);this.decorations=[];const m=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,b=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(b=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=m[e.sha])?(f=Ao.gutter(p,r.format,n,u),r.heatmap.enabled&&Ao.applyHeatmap(f,p.date,h),f.range=new N.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),m[e.sha]=f):(f=Object.assign({},f,{range:new N.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),r.compact&&!b&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:j.Space.repeat(w.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),b=!0),f.range=new N.Range(t,0,t,0),this.decorations.push(f),c&&!r.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const C=process.hrtime(o);return Ce.log(`${1e3*C[0]+Math.floor(C[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(lr.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:N.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class Uo extends No{async onProvideAnnotation(e,t){this.annotationType=F.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),r=Ao.heatmapRenderOptions();this.decorations=[];const a=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=a[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=Ao.heatmap(n,o,r)).range=new N.Range(t,0,t,0),this.decorations.push(h),a[e.sha]=h):(h=Object.assign({},h,{range:new N.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return Ce.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(lr.config.hovers.annotations),this.selection(e,i),!0}}class Oo extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=F.RecentChanges;const t=await lr.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await lr.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=lr.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new N.Range(new N.Position(i,0),new N.Position(i,M)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:Ao.getHoverMessage(t,r,await lr.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&void 0===(a=Ao.getHoverDiffMessage(t,this._uri,s)))||this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const a=process.hrtime(s);return Ce.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Io;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(Io||(Io={}));const Mo={blameAnnotation:N.window.createTextEditorDecorationType({rangeBehavior:N.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:N.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class Wo extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new N.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Mo.blameAnnotation&&Mo.blameAnnotation.dispose(),Mo.blameHighlight&&Mo.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=mr.initializing(e),i=lr.config;if(t||mr.changed(e,mr.name("blame")("highlight").value)){Mo.blameHighlight&&Mo.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Mo.blameHighlight=N.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:N.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new N.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new N.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?lr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?lr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Mo.blameHighlight=void 0}if(t||mr.changed(e,mr.name("recentChanges")("highlight").value)){Mo.recentChangesAnnotation&&Mo.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Mo.recentChangesAnnotation=N.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:N.OverviewRulerLane.Right,backgroundColor:e.locations.includes(T.Line)?new N.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(T.Overview)?new N.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(T.Gutter)?lr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(T.Gutter)?lr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||mr.changed(e,mr.name("blame")("toggleMode").value))&&(this._toggleModes.set(F.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==y.File||this.clearAll()),(t||mr.changed(e,mr.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(F.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==y.File||this.clearAll()),(t||mr.changed(e,mr.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(F.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==y.File||this.clearAll()),!t&&(mr.changed(e,mr.name("blame").value)||mr.changed(e,mr.name("recentChanges").value)||mr.changed(e,mr.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===F.RecentChanges?e.reset({decoration:Mo.recentChangesAnnotation,highlightDecoration:Mo.recentChangesHighlight}):e.annotationType===F.Blame?e.reset({decoration:Mo.blameAnnotation,highlightDecoration:Mo.blameHighlight}):this.show(e.editor,F.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!z(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(Q(H.AnnotationStatus,void 0),this.detachKeyboardHook()):(Q(H.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=N.window.activeTextEditor;void 0!==t&&this.clear(t,Io.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Io.DocumentChanged)}onTextDocumentClosed(e){if(lr.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Io.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=m.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Io.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===y.Window}getToggleMode(e){return void 0===e?y.File:this._toggleModes.get(e)||y.File}clear(e,t=Io.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(se.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,Io.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await lr.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(se.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===y.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of N.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await lr.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await N.window.withProgress({location:N.ProgressLocation.Window},async o=>{await Q(H.AnnotationStatus,te.Computing);const r=this.showAnnotationsCore(s,e,t,i,o),a=await r;return e===this._editor&&await Q(H.AnnotationStatus,a&&a.status),r})}async toggle(e,t,i){if(void 0!==e){const i=await lr.tracker.getOrAdd(e.document);if(t===F.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,Io.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await lr.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Io.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(Ce.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==se.getCorrelationKey(this._editor)||(await Q(H.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(Ce.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case F.Blame:e="blame annotations";break;case F.Heatmap:e="heatmap annotations";break;case F.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${ke.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await lr.tracker.getOrAdd(t.document);let a=void 0;switch(i){case F.Blame:a=new Lo(t,r,Mo.blameAnnotation,Mo.blameHighlight);break;case F.Heatmap:a=new Uo(t,r,Mo.heatmapAnnotation,Mo.heatmapHighlight);break;case F.RecentChanges:a=new Oo(t,r,Mo.recentChangesAnnotation,Mo.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Io.User),this._annotationsDisposable||0!==this._annotationProviders.size||(Ce.log("Add listener registrations for annotations"),this._annotationsDisposable=N.Disposable.from(N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveTextEditorChanged,50),this),N.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),N.window.onDidChangeVisibleTextEditors(u.debounce(this.onVisibleTextEditorsChanged,50),this),N.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),lr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),lr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class Ho extends N.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class Go extends N.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class jo{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new N.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=lr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=mr.get(mr.name("codeLens").value,e.uri);let r=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==r?r={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}:(void 0===r.scopes&&(r.scopes=o.scopes),void 0===r.symbolScopes&&(r.symbolScopes=o.symbolScopes)),r.symbolScopes=null!=r.symbolScopes?r.symbolScopes=r.symbolScopes.map(e=>e.toLowerCase()):[];const a=[],n=i.uri;let h,c;if(s)1===r.scopes.length&&r.scopes.includes($.Document)||(c=await N.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return a;if(1===r.scopes.length&&r.scopes.includes($.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),N.commands.executeCommand(W.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return a}if(t.isCancellationRequested)return a;const l=u.once(()=>e.validateRange(new N.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(Ce.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(a,e,t,r,l,h,n,o,s,d))),(r.scopes.includes($.Document)||r.symbolScopes.includes("file"))&&!r.symbolScopes.includes("!file")&&!a.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;if(s||o.recentChange.enabled){s||(t=u.once(()=>this._git.getBlameForRangeSync(h,n,e)));const i=new N.SymbolInformation(n.getFilename(),N.SymbolKind.File,"",new N.Location(n.fileUri(),new N.Range(0,0,0,e.start.character)));a.push(new Ho(i,n,t,e,!0,i.location.range,o.recentChange.command,d))}if(!s&&o.authors.enabled){void 0===t&&(t=u.once(()=>this._git.getBlameForRangeSync(h,n,e)));const i=new N.SymbolInformation(n.getFilename(),N.SymbolKind.File,"",new N.Location(n.fileUri(),new N.Range(0,1,0,e.start.character)));a.push(new Go(i,n,t,e,!0,i.location.range,o.authors.command))}}return a}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const r=N.SymbolKind[e.kind].toLowerCase();switch(e.kind){case N.SymbolKind.File:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&(s=i());break;case N.SymbolKind.Package:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case N.SymbolKind.Class:case N.SymbolKind.Interface:case N.SymbolKind.Module:case N.SymbolKind.Namespace:case N.SymbolKind.Struct:(t.scopes.includes($.Containers)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;case N.SymbolKind.Constructor:case N.SymbolKind.Enum:case N.SymbolKind.Function:case N.SymbolKind.Method:(t.scopes.includes($.Blocks)||t.symbolScopes.includes(r))&&(o=!t.symbolScopes.includes(`!${r}`));break;default:t.symbolScopes.includes(r)&&(o=!t.symbolScopes.includes(`!${r}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let m,g=0;if((h||n.recentChange.enabled)&&(h||(m=u.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Ho(i,a,m,l,!1,d.range.with(new N.Position(d.range.start.line,g)),n.recentChange.command,c)),g++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case N.SymbolKind.File:break;case N.SymbolKind.Package:case N.SymbolKind.Module:case N.SymbolKind.Namespace:case N.SymbolKind.Class:case N.SymbolKind.Interface:case N.SymbolKind.Constructor:case N.SymbolKind.Method:case N.SymbolKind.Function:case N.SymbolKind.Enum:s=!0}s&&!h&&(void 0===m&&(m=u.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Go(i,a,m,l,!1,d.range.with(new N.Position(d.range.start.line,g)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof Ho?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Go?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=m.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(lr.config.debug&&(o+=` [${N.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${m.first(i.authors.values()).name}${s>1?" and others":""})`;switch(lr.config.debug&&(o+=` [${N.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${m.join(m.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case x.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case x.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case x.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case x.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case x.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case x.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:fs.DiffWithPrevious,arguments:[N.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitDetails,arguments:[N.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":x.ShowQuickCommitFileDetails,arguments:[N.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickCurrentBranchHistory,arguments:[N.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:x.ShowQuickFileHistory,arguments:[N.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:fs.ToggleFileBlame,arguments:[N.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?lr.config.strings.codeLens.unsavedChanges.recentChangeAndAuthors:e.recentChange.enabled?lr.config.strings.codeLens.unsavedChanges.recentChangeOnly:lr.config.strings.codeLens.unsavedChanges.authorsOnly}}jo.selector=[{scheme:G.File},{scheme:G.Git},{scheme:G.GitLensGit}];class Vo extends N.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=mr.initializing(e),i=mr.name("codeLens").value;if(t||mr.changed(e,i,null)||mr.changed(e,mr.name("defaultDateStyle").value)||mr.changed(e,mr.name("defaultDateFormat").value)){t||Ce.log("CodeLens config changed; resetting CodeLens provider");const e=lr.config.codeLens;e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,Q(H.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(Ce.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=lr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||(Ce.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(Ce.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new jo(lr.context,lr.git,lr.tracker),this._providerDisposable=N.Disposable.from(N.languages.registerCodeLensProvider(jo.selector,this._provider),lr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),lr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}const Qo=N.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:N.DecorationRangeBehavior.ClosedOpen});class Ko extends N.Disposable{constructor(){super(()=>this.dispose()),this._enabled=!1,this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this),lr.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),N.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),lr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=mr.initializing(e);(t||mr.changed(e,mr.name("currentLine").value))&&((t||mr.changed(e,mr.name("currentLine")("enabled").value))&&(lr.config.currentLine.enabled?(this._enabled=!0,this.resume()):(this._enabled=!1,this.setLineTracker(!1))),this.refresh(N.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(this.setLineTracker(!0),e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return this.setLineTracker(!1),"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=N.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(N.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(N.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(N.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Qo,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=lr.lineTracker.lines;if(void 0===e||void 0===t||!z(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=lr.config.currentLine;if(this.suspended)return this.clear(e);if(!(await lr.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!lr.lineTracker.includesAll(t))return;const s=lr.config.currentLine.scrollable,o=[];for(const r of t){const t=lr.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const a=Ao.trailing(t.commit,i.format,null===i.dateFormat?lr.config.defaultDateFormat:i.dateFormat,s);a.range=e.document.validateRange(new N.Range(r,M,r,M)),o.push(a)}e.setDecorations(Qo,o)}setLineTracker(e){e?lr.lineTracker.isSubscribed(this)||lr.lineTracker.start(this,N.Disposable.from(lr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))):lr.lineTracker.stop(this)}}class zo extends N.Disposable{constructor(){super(()=>this.dispose()),this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this),N.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),lr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){(mr.initializing(e)||mr.changed(e,mr.name("hovers")("enabled").value)||mr.changed(e,mr.name("hovers")("currentLine")("enabled").value))&&(lr.config.hovers.enabled&&lr.config.hovers.currentLine.enabled?(lr.lineTracker.start(this,N.Disposable.from(lr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(N.window.activeTextEditor)):(lr.lineTracker.stop(this),this.unregister()))}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=N.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!lr.lineTracker.includes(t.line))return;const s=lr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const r=await lr.fileAnnotations.getAnnotationType(N.window.activeTextEditor);if(void 0!==r&&lr.config.hovers.annotations.details)return;const a=!this.debugging&&"line"===lr.config.hovers.currentLine.over;if(!a&&lr.lineAnnotations.suspended)return;const n=e.validateRange(new N.Range(t.line,a?0:M,t.line,M));if(!a&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await lr.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await lr.tracker.get(e))return;const c=Ao.getHoverMessage(h||o,lr.config.defaultDateFormat,await lr.git.getRemotes(o.repoPath),r,t.line);return new N.Hover(c,n)}async provideChangesHover(e,t,i){if(!lr.lineTracker.includes(t.line))return;const s=lr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(lr.config.hovers.annotations.changes&&void 0!==await lr.fileAnnotations.getAnnotationType(N.window.activeTextEditor))return;const r=!this.debugging&&"line"===lr.config.hovers.currentLine.over;if(!r&&lr.lineAnnotations.suspended)return;const a=e.validateRange(new N.Range(t.line,r?0:M,t.line,M));if(!r&&a.start.character!==t.character)return;const n=await lr.tracker.get(e);if(void 0===n)return;const h=await Ao.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new N.Hover(h.hoverMessage,a):void 0}register(e){if(this.unregister(),void 0===e)return;const t=lr.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(N.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(N.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=N.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}class qo extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new N.EventEmitter,this._onDidChangeTreeData=new N.EventEmitter,lr.explorerCommands,N.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),N.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(k.Auto),this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(k.List),this),N.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(k.Tree),this),N.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(lr.config.gitExplorer.autoRefresh,!0),this),N.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(lr.config.gitExplorer.autoRefresh,!1),this),N.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>qo.setRenameFollowing(!0),this),N.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>qo.setRenameFollowing(!1),this),N.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(P.History),this),N.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(P.Repository),this),N.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),lr.context.subscriptions.push(N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveEditorChanged,500),this),N.window.onDidChangeVisibleTextEditors(u.debounce(this.onVisibleEditorsChanged,500),this),mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=mr.initializing(e);if(!(t||mr.changed(e,mr.name("gitExplorer").value)||mr.changed(e,mr.name("explorers").value)||mr.changed(e,mr.name("defaultGravatarsStyle").value)||mr.changed(e,mr.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||mr.changed(e,mr.name("gitExplorer")("enabled").value)||mr.changed(e,mr.name("gitExplorer")("location").value))&&Q(H.GitExplorer,!!this.config.enabled&&this.config.location),(t||mr.changed(e,mr.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(lr.config.gitExplorer.autoRefresh);let i=this.view;if((t||mr.changed(e,mr.name("gitExplorer")("view").value))&&((i=this.config.view)===P.Auto&&(i=lr.context.workspaceState.get(Y.GitExplorerView,P.Repository)),t))return this.view=i,Q(H.GitExplorerView,this.view),this.setRoot(await this.getRootNode(N.window.activeTextEditor)),this._tree=N.window.createTreeView("gitlens.gitExplorer",{treeDataProvider:this}),void(this._disposable=this._tree);this.reset(i,mr.changed(e,mr.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==P.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Qt.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===P.Repository&&(this.clearRoot(),Ce.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(Qt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===P.History&&(0!==e.length&&e.some(e=>e.document&&lr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Qt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&lr.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},lr.config.explorers,lr.config.gitExplorer)}get view(){return this._view}set view(e){this._view=lr.config.historyExplorer.enabled?P.Repository:e}getParent(e){}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this.view===P.History?[new Zt(`No active file ${j.Dash} no history to show`)]:[new Zt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Qt.Command),Ce.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===P.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(N.window.activeTextEditor))),void 0!==this._root&&this._root.refresh(),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`GitExplorer[view=${this.view}].refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){if(this.setView(e),t&&void 0!==this._root&&this.clearRoot(),this.setRoot(await this.getRootNode(N.window.activeTextEditor))||t)return this.refresh(Qt.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=lr.context.workspaceState.get(Y.GitExplorerAutoRefresh,!0):(i=t,await lr.context.workspaceState.update(Y.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=lr.git.onDidChangeRepositories(this.onRepositoriesChanged,this),lr.context.subscriptions.push(this._autoRefreshDisposable))),Q(H.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Qt.AutoRefreshChanged)}setView(e){this.view!==e&&(lr.config.gitExplorer.view===P.Auto&&lr.context.workspaceState.update(Y.GitExplorerView,e),this.view=e,Q(H.GitExplorerView,this.view),e!==P.Repository&&lr.git.stopWatchingFileSystem())}async show(e){if(void 0===this._root||void 0===this._tree)return;await this.switchTo(e);const[t]=await this._root.getChildren();try{await this._tree.reveal(t,{select:!1})}catch(e){Ce.error(e)}}async switchTo(e){return this.view!==e&&(await this.reset(e,!0),!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case P.History:{const t=this.getHistoryNode(e||N.window.activeTextEditor);return this._loading=t.then(e=>u.wait(0)),t}default:{const e=lr.git.getRepositories();this._loading=e.then(e=>u.wait(0));const t=[...await e];if(0===t.length)return;const i=t.filter(e=>!e.closed);if(0===i.length)return;if(1===i.length){const e=i[0];return new wi(Ae.fromRepoPath(e.path),e,this,!0)}return new ki(i,this)}}}async getHistoryNode(e){return qo.getHistoryNode(this,e,this._root)}async setFilesLayout(e){return mr.update(mr.name("gitExplorer")("files")("layout").value,e,N.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}async undockHistory(e=!0){lr.historyExplorer.undock(e)}static async getHistoryNode(e,t,i){if(null==t||0===N.window.visibleTextEditors.length||!N.window.visibleTextEditors.some(e=>e.document&&lr.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!lr.git.isTrackable(t.document.uri))return i;const s=await Ae.fromUri(t.document.uri),o=await lr.git.getRepository(s);return void 0!==o?ee.equals(s,i&&i.uri)?i:new _i(s,o,e):void 0}static setRenameFollowing(e){mr.updateEffective(mr.name("advanced")("fileHistoryFollowsRenames").value,e)}}class Yo extends N.Disposable{constructor(){super(()=>this.dispose()),N.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),N.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),N.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),N.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),N.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),N.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),N.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),N.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),N.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),N.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),N.commands.registerCommand("gitlens.explorers.closeRepository",this.closeRepository,this),N.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),N.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),N.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),N.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),N.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),N.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),N.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),N.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),N.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),N.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),N.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),N.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),N.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),N.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),N.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),N.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),N.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await lr.git.checkoutFile(e.uri),this.openFile(e)}closeRepository(e){(e instanceof wi||e instanceof ui)&&(e.repo.closed=!0)}compareWithHead(e){e instanceof Xt&&lr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&lr.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof Xt&&lr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await lr.git.getBranch(e.repoPath);if(void 0===t)return;const i=await lr.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&lr.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${qt.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof Xt&&this._selection.repoPath===e.repoPath&&lr.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof Xt))return;const t=e instanceof ri?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},Q(H.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,N.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return N.commands.executeCommand(fs.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Ps(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Ps(t.uri||("D"===e.commit.status?Ae.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Ae.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Ae.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:qt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Ae.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>Ae.fromFileStatus(e,i));for(const e of s)await Ps(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>Ae.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Ps(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return N.commands.executeCommand(fs.DiffWith,o)}async openFileRevisionInRemote(e){return N.commands.executeCommand(fs.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof ri&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof Xt))return;let t=!1,i=void 0;e instanceof ri&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await N.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==s&&""!==s&&this.sendTerminalCommand("branch",`${t?"-t ":""}${s} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof ri&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.getRemote()} :${e.branch.getName()}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof ri&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof ri&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof ri){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof di&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof ri&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof oi&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof oi))return;const t=e.branch||await lr.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof oi&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof oi&&this.sendTerminalCommand("reset",`--soft ${e.ref}^`,e.repoPath)}terminalRevertCommit(e){e instanceof oi&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof ni&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof Xt))return;const t=await N.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await N.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",s,e.repoPath)}terminalDeleteTag(e){e instanceof fi&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=N.window.createTerminal(O),this._disposable=N.window.onDidCloseTerminal(e=>{e.name===O&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),lr.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class Xo{async provideTextDocumentContent(e,t){const i=Ae.fromRevisionUri(e);if(!i.repoPath||i.sha===qt.deletedSha)return"";try{return await lr.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return Ce.error(e,"GitContentProvider","getVersionedFileText"),void N.window.showErrorMessage(`Unable to show Git revision ${qt.shortenSha(i.sha)} of '${ke.relative(i.repoPath,i.fsPath)}'`)}}}Xo.scheme=G.GitLensGit;class Zo extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new N.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||z(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!z(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return Zo.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=N.Disposable.from(N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveTextEditorChanged,0),this),N.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(N.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=u.debounce(e=>{N.window.activeTextEditor===e.editor&&Zo.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{N.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}class Jo{constructor(e,t){this.commit=e,this.logCommit=t}}class er extends Zo{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=lr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}async resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}async suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}isSubscribed(e){return this._subscriptions.has(e)}start(e,t){this.isSubscribed(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=N.Disposable.from(this._disposable,lr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),lr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),lr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await lr.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await lr.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await lr.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new Jo(s.commit))}else{const s=t.document.isDirty?await lr.git.getBlameForFileContents(i.uri,t.document.getText()):await lr.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new Jo(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e)||(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),0))}}class tr extends N.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class ir extends N.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class sr{async provideCodeLenses(e,t){const i=Ae.fromRevisionUri(e.uri),s=[],o=await lr.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new ir(o.previousUri.fsPath,o,new N.Range(0,0,0,1))),s.push(new tr(o.uri.fsPath,o,new N.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof tr?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof ir?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:fs.DiffWithWorking,arguments:[N.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:fs.DiffWithPrevious,arguments:[N.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}sr.selector={scheme:G.GitLensGit};class or extends N.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new N.EventEmitter,lr.explorerCommands,N.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),N.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),N.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),N.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),N.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>qo.setRenameFollowing(!0),this),N.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>qo.setRenameFollowing(!1),this),lr.context.subscriptions.push(N.window.onDidChangeActiveTextEditor(u.debounce(this.onActiveEditorChanged,500),this),N.window.onDidChangeVisibleTextEditors(u.debounce(this.onVisibleEditorsChanged,500),this),mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=mr.initializing(e);(t||mr.changed(e,mr.name("historyExplorer").value)||mr.changed(e,mr.name("explorers").value)||mr.changed(e,mr.name("defaultGravatarsStyle").value)||mr.changed(e,mr.name("advanced")("fileHistoryFollowsRenames").value))&&((t||mr.changed(e,mr.name("historyExplorer")("enabled").value))&&(this.config.enabled?this.undock(!t,!mr.changed(e,mr.name("mode").value)):this.dock(!t,!mr.changed(e,mr.name("mode").value))),!t&&mr.changed(e,mr.name("historyExplorer")("location").value)&&this.config.enabled&&Q(H.HistoryExplorer,this.config.location),t||void 0!==this._root||this.refresh(Qt.ConfigurationChanged),t&&(this.setRoot(await this.getRootNode(N.window.activeTextEditor)),this._tree=N.window.createTreeView("gitlens.historyExplorer",{treeDataProvider:this}),this._disposable=this._tree))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Qt.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&lr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Qt.VisibleEditorsChanged)))}get config(){return Object.assign({},lr.config.explorers,lr.config.historyExplorer)}getParent(e){}async getChildren(e){return void 0===this._root?[new Zt(`No active file ${j.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0,t=!0){e&&await lr.gitExplorer.switchTo(P.History),await Q(H.HistoryExplorer,!1),t&&await mr.updateEffective(mr.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Qt.Command),Ce.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(N.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`HistoryExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async show(){if(void 0!==this._root&&void 0!==this._tree)try{await this._tree.reveal(this._root,{select:!1})}catch(e){Ce.error(e)}}async undock(e=!0,t=!0){e&&await lr.gitExplorer.switchTo(P.Repository),await Q(H.HistoryExplorer,this.config.location),t&&await mr.updateEffective(mr.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){return qo.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}}class rr extends N.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new N.EventEmitter,this._enabled=!1,lr.explorerCommands,N.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),N.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(k.Auto),this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(k.List),this),N.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(k.Tree),this),N.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),N.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),N.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),N.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),N.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),Q(H.ResultsExplorerKeepResults,this.keepResults),lr.context.subscriptions.push(mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=mr.initializing(e);(t||mr.changed(e,mr.name("resultsExplorer").value)||mr.changed(e,mr.name("explorers").value)||mr.changed(e,mr.name("defaultGravatarsStyle").value))&&(!t&&mr.changed(e,mr.name("resultsExplorer")("location").value)&&this.enabled&&Q(H.ResultsExplorer,this.config.location),t||0===this._roots.length||this.refresh(Qt.ConfigurationChanged),t&&(this._tree=N.window.createTreeView("gitlens.resultsExplorer",{treeDataProvider:this}),this._disposable=this._tree))}get config(){return Object.assign({},lr.config.explorers,lr.config.resultsExplorer)}get enabled(){return this._enabled}get keepResults(){return lr.context.workspaceState.get(Y.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),this._enabled=!1,Q(H.ResultsExplorer,!1)}getParent(e){}async getChildren(e){return 0===this._roots.length?[new Zt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Qt.Command),Ce.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){Ce.log(`ResultsExplorer.refreshNode(${e.id})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){Ce.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}async show(){if(void 0!==this._roots&&0!==this._roots.length&&void 0!==this._tree)try{await this._tree.reveal(this._roots[0],{select:!1})}catch(e){Ce.error(e)}}showComparisonInResults(e,t,i){this.showResults(this.addResults(new Si(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)))}showCommitInResults(e){this.showResults(this.addResults(new Ci(e,this)))}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.showResults(this.addResults(new yi(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await lr.git.getRepositoryCount()>1){const t=await lr.git.getRepository(e.repoPath);a=` ${w.pad(j.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},u.seeded(i,e),this,Kt.SearchResults)))}async showResults(e){this._enabled=!0,await Q(H.ResultsExplorer,this.config.location),setTimeout(()=>this._tree.reveal(e,{select:!0}),250)}addResults(e){return this._roots.includes(e)?e:(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),e)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return mr.update(mr.name("resultsExplorer")("files")("layout").value,e,N.ConfigurationTarget.Global)}setKeepResults(e){lr.context.workspaceState.update(Y.ResultsExplorerKeepResults,e),Q(H.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof Si&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class ar extends N.Disposable{constructor(){super(()=>this.dispose()),this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this),...this.registerCommands())}dispose(){this._disposable&&this._disposable.dispose(),this._disposablePanel&&this._disposablePanel.dispose()}onConfigurationChanged(e){this.postUpdatedConfiguration()}onPanelDisposed(){this._disposablePanel&&this._disposablePanel.dispose(),this._panel=void 0}onViewStateChanged(e){if(Ce.log("WebviewEditor.onViewStateChanged",e.webviewPanel.visible),this._invalidateOnVisible&&e.webviewPanel.visible){const e=this._invalidateOnVisible;switch(this._invalidateOnVisible=void 0,e){case"config":this.postUpdatedConfiguration();break;default:this.show()}}}async onMessageReceived(e){if(null!=e)switch(Ce.log(`WebviewEditor.onMessageReceived: type=${e.type}, data=${JSON.stringify(e)}`),e.type){case"saveSettings":const t="workspace"===e.scope?N.ConfigurationTarget.Workspace:N.ConfigurationTarget.Global;for(const i in e.changes){const s=await mr.inspect(i),o=e.changes[i];await mr.update(i,o===s.defaultValue?void 0:o,t)}for(const i of e.removes)await mr.update(i,void 0,t)}}get visible(){return void 0!==this._panel&&this._panel.visible}hide(){void 0!==this._panel&&this._panel.dispose()}async show(){let e=(await this.getHtml()).replace(/{{root}}/g,N.Uri.file(lr.context.asAbsolutePath(".")).with({scheme:"vscode-resource"}).toString());e.includes("'{{bootstrap}}'")&&(e=e.replace("'{{bootstrap}}'",JSON.stringify(this.getBootstrap()))),void 0===this._panel?(this._panel=N.window.createWebviewPanel(this.id,this.title,N.ViewColumn.Active,{retainContextWhenHidden:!0,enableFindWidget:!0,enableCommandUris:!0,enableScripts:!0}),this._disposablePanel=N.Disposable.from(this._panel,this._panel.onDidDispose(this.onPanelDisposed,this),this._panel.onDidChangeViewState(this.onViewStateChanged,this),this._panel.webview.onDidReceiveMessage(this.onMessageReceived,this)),this._panel.webview.html=e):(this._panel.webview.html=e,this._panel.reveal(N.ViewColumn.Active))}async getHtml(){return Ce.isDebugging?new Promise((e,t)=>{_e.readFile(lr.context.asAbsolutePath(this.filename),"utf8",(i,s)=>{i?t(i):e(s)})}):(await N.workspace.openTextDocument(lr.context.asAbsolutePath(this.filename))).getText()}postMessage(e,t="all"){if(void 0===this._panel)return!1;const i=this._panel.webview.postMessage(e);return i||"all"===this._invalidateOnVisible||(this._invalidateOnVisible=t),i}postUpdatedConfiguration(){return this.postMessage({type:"settingsChanged",config:mr.get()},"config")}}class nr extends ar{constructor(){super()}get filename(){return"settings.html"}get id(){return"gitlens.settings"}get title(){return"GitLens Settings"}getBootstrap(){return{config:mr.get(),scope:"user",scopes:this.getAvailableScopes()}}registerCommands(){return[N.commands.registerCommand("gitlens.showSettingsPage",this.show,this)]}getAvailableScopes(){const e=[["user","User"]];return void 0!==N.workspace.workspaceFolders&&N.workspace.workspaceFolders.length&&e.push(["workspace","Workspace"]),e}}class hr extends N.Disposable{constructor(){super(()=>this.dispose()),this._disposable=N.Disposable.from(mr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(mr.initializingChangeEvent)}dispose(){this.clearBlame(),this._blameStatusBarItem&&this._blameStatusBarItem.dispose(),this._modeStatusBarItem&&this._modeStatusBarItem.dispose(),lr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=mr.initializing(e);if(t||mr.changed(e,mr.name("mode").value)){const t=lr.config.mode.active&&lr.config.mode.statusBar.enabled?lr.config.modes[lr.config.mode.active]:void 0;if(t&&t.statusBarItemName){const i="left"!==lr.config.mode.statusBar.alignment?N.StatusBarAlignment.Right:N.StatusBarAlignment.Left;mr.changed(e,mr.name("mode")("statusBar")("alignment").value)&&void 0!==this._modeStatusBarItem&&this._modeStatusBarItem.alignment!==i&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0),this._modeStatusBarItem=this._modeStatusBarItem||N.window.createStatusBarItem(i,i===N.StatusBarAlignment.Right?999:1),this._modeStatusBarItem.command=fs.SwitchMode,this._modeStatusBarItem.text=t.statusBarItemName,this._modeStatusBarItem.tooltip="Switch GitLens Mode",this._modeStatusBarItem.show()}else void 0!==this._modeStatusBarItem&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0)}if(t||mr.changed(e,mr.name("statusBar").value))if(lr.config.statusBar.enabled){const i="left"!==lr.config.statusBar.alignment?N.StatusBarAlignment.Right:N.StatusBarAlignment.Left;mr.changed(e,mr.name("statusBar")("alignment").value)&&void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.alignment!==i&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0),this._blameStatusBarItem=this._blameStatusBarItem||N.window.createStatusBarItem(i,i===N.StatusBarAlignment.Right?1e3:0),this._blameStatusBarItem.command=lr.config.statusBar.command,(t||mr.changed(e,mr.name("statusBar")("enabled").value))&&lr.lineTracker.start(this,N.Disposable.from(lr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else mr.changed(e,mr.name("statusBar")("enabled").value)&&(lr.lineTracker.stop(this),void 0!==this._blameStatusBarItem&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0))}onActiveLinesChanged(e){let t=!(lr.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=lr.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateBlame(i.commit,e.editor);t=!0}t&&this.clearBlame()}async clearBlame(){void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.hide()}updateBlame(e,t){const i=lr.config.statusBar;if(i.enabled&&void 0!==this._blameStatusBarItem&&z(t)){switch(this._blameStatusBarItem.text=`$(git-commit) ${Gt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?lr.config.defaultDateFormat:i.dateFormat})}`,i.command){case A.ToggleFileBlame:this._blameStatusBarItem.tooltip="Toggle Blame Annotations";break;case A.DiffWithPrevious:this._blameStatusBarItem.command=fs.DiffLineWithPrevious,this._blameStatusBarItem.tooltip="Compare Line Revision with Previous";break;case A.DiffWithWorking:this._blameStatusBarItem.command=fs.DiffLineWithWorking,this._blameStatusBarItem.tooltip="Compare Line Revision with Working";break;case A.ToggleCodeLens:this._blameStatusBarItem.tooltip="Toggle Git CodeLens";break;case A.ShowQuickCommitDetails:this._blameStatusBarItem.tooltip="Show Commit Details";break;case A.ShowQuickCommitFileDetails:this._blameStatusBarItem.tooltip="Show Line Commit Details";break;case A.ShowQuickFileHistory:this._blameStatusBarItem.tooltip="Show File History";break;case A.ShowQuickCurrentBranchHistory:this._blameStatusBarItem.tooltip="Show Branch History"}this._blameStatusBarItem.show()}}}class cr extends ar{constructor(){super()}get filename(){return"welcome.html"}get id(){return"gitlens.welcome"}get title(){return"Welcome to GitLens"}getBootstrap(){return{config:lr.config}}registerCommands(){return[N.commands.registerCommand("gitlens.showWelcomePage",this.show,this)]}}class lr{static initialize(e,t){if(this._context=e,this._config=lr.applyMode(t),e.subscriptions.push(this._lineTracker=new er),e.subscriptions.push(this._tracker=new Wt),e.subscriptions.push(this._git=new qt),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new Wo),e.subscriptions.push(this._lineAnnotationController=new Ko),e.subscriptions.push(this._lineHoverController=new zo),e.subscriptions.push(this._statusBarController=new hr),e.subscriptions.push(this._codeLensController=new Vo),e.subscriptions.push(this._keyboard=new ji),e.subscriptions.push(this._settingsEditor=new nr),e.subscriptions.push(this._welcomeEditor=new cr),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new qo);else{let t;t=mr.onDidChange(i=>{mr.changed(i,mr.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new qo))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new or);else{let t;t=mr.onDidChange(i=>{mr.changed(i,mr.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new or))})}e.subscriptions.push(N.workspace.registerTextDocumentContentProvider(Xo.scheme,new Xo)),e.subscriptions.push(N.languages.registerCodeLensProvider(sr.selector,new sr))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=lr.applyMode(mr.get())),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new Yo),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new or),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new rr),this._resultsExplorer}static get settingsEditor(){return this._settingsEditor}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static get welcomeEditor(){return this._welcomeEditor}static resetConfig(){this._config=void 0}static applyMode(e){if(!e.mode.active)return e;const t=e.modes[e.mode.active];return null==t?e:(null!=t.codeLens&&(e.codeLens.enabled=t.codeLens),null!=t.currentLine&&(e.currentLine.enabled=t.currentLine),null!=t.explorers&&(e.gitExplorer.enabled=t.explorers),null!=t.explorers&&(e.historyExplorer.enabled=t.explorers),null!=t.hovers&&(e.hovers.enabled=t.hovers),null!=t.statusBar&&(e.statusBar.enabled=t.statusBar),e)}}const dr=new Proxy({},{get:(e,t,i)=>dr});class ur{constructor(){this._onDidChange=new N.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1},this._configAffectedByMode=[`gitlens.${this.name("mode").value}`,`gitlens.${this.name("modes").value}`,`gitlens.${this.name("codeLens").value}`,`gitlens.${this.name("currentLine").value}`,`gitlens.${this.name("gitExplorer").value}`,`gitlens.${this.name("historyExplorer").value}`,`gitlens.${this.name("hovers").value}`,`gitlens.${this.name("statusBar").value}`]}static configure(e){e.subscriptions.push(N.workspace.onDidChangeConfiguration(mr.onConfigurationChanged,mr))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(L,null))return;lr.resetConfig(),mr.changed(e,mr.name("defaultGravatarsStyle").value)&&Ne.clear();const t=mr.name("keymap").value;if(mr.changed(e,t)&&Q(H.KeyMap,this.get(t)),mr.changed(e,mr.name("mode").value)||mr.changed(e,mr.name("modes").value)){const t=e.affectsConfiguration;e=Object.assign({},e,{affectsConfiguration:(e,i)=>!!this._configAffectedByMode.some(t=>e.startsWith(t))||t(e,i)})}this._onDidChange.fire(e)}get(e,t,i){return void 0===i?N.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e):N.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e,i)}changed(e,t,i){return e.affectsConfiguration(`${L}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return N.workspace.getConfiguration(void 0===e?void 0:L,t).inspect(void 0===e?L:e)}async migrate(e,t,i={}){const s=mr.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,N.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,N.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,N.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,N.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=mr.inspect(e);if(void 0===s)return;const o=mr.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,N.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,N.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,N.ConfigurationTarget.WorkspaceFolder))}name(e){return u.propOf(dr,e)}update(e,t,i,s){return N.workspace.getConfiguration(L,i===N.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await mr.inspect(e,i);if(void 0!==s.workspaceFolderValue){if(s.workspaceFolderValue===t)return;await mr.update(e,t,N.ConfigurationTarget.WorkspaceFolder,i)}else if(void 0!==s.workspaceValue){if(s.workspaceValue===t)return;await mr.update(e,t,N.ConfigurationTarget.Workspace)}else{if(s.globalValue===t)return;await mr.update(e,t,N.ConfigurationTarget.Global)}}}const mr=new ur;async function gr(e){const t=process.hrtime();Ce.configure(e);const i=N.extensions.getExtension(I).packageJSON.version,s=N.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return Ce.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),Q(H.Enabled,s),void Ms.showGitDisabledErrorMessage();ur.configure(e);const o=e.globalState.get(V.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=b.fromString(t);try{if(1!==b.compare(i,b.from(7,5,10))&&(await mr.migrate("annotations.file.gutter.gravatars",mr.name("blame")("avatars").value),await mr.migrate("annotations.file.gutter.compact",mr.name("blame")("compact").value),await mr.migrate("annotations.file.gutter.dateFormat",mr.name("blame")("dateFormat").value),await mr.migrate("annotations.file.gutter.format",mr.name("blame")("format").value),await mr.migrate("annotations.file.gutter.heatmap.enabled",mr.name("blame")("heatmap")("enabled").value),await mr.migrate("annotations.file.gutter.heatmap.location",mr.name("blame")("heatmap")("location").value),await mr.migrate("annotations.file.gutter.lineHighlight.enabled",mr.name("blame")("highlight")("enabled").value),await mr.migrate("annotations.file.gutter.lineHighlight.locations",mr.name("blame")("highlight")("locations").value),await mr.migrate("annotations.file.gutter.separateLines",mr.name("blame")("separateLines").value),await mr.migrate("codeLens.locations",mr.name("codeLens")("scopes").value),await mr.migrate("codeLens.perLanguageLocations",mr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await mr.migrate("codeLens.customLocationSymbols",mr.name("codeLens")("symbolScopes").value),await mr.migrate("annotations.line.trailing.dateFormat",mr.name("currentLine")("dateFormat").value),await mr.migrate("blame.line.enabled",mr.name("currentLine")("enabled").value),await mr.migrate("annotations.line.trailing.format",mr.name("currentLine")("format").value),await mr.migrate("annotations.file.gutter.hover.changes",mr.name("hovers")("annotations")("changes").value),await mr.migrate("annotations.file.gutter.hover.details",mr.name("hovers")("annotations")("details").value),await mr.migrate("annotations.file.gutter.hover.details",mr.name("hovers")("annotations")("enabled").value),await mr.migrate("annotations.file.gutter.hover.wholeLine",mr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await mr.migrate("annotations.line.trailing.hover.changes",mr.name("hovers")("currentLine")("changes").value),await mr.migrate("annotations.line.trailing.hover.details",mr.name("hovers")("currentLine")("details").value),await mr.migrate("blame.line.enabled",mr.name("hovers")("currentLine")("enabled").value),await mr.migrate("annotations.line.trailing.hover.wholeLine",mr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await mr.migrate("gitExplorer.gravatars",mr.name("explorers")("avatars").value),await mr.migrate("gitExplorer.commitFileFormat",mr.name("explorers")("commitFileFormat").value),await mr.migrate("gitExplorer.commitFormat",mr.name("explorers")("commitFormat").value),await mr.migrate("gitExplorer.stashFileFormat",mr.name("explorers")("stashFileFormat").value),await mr.migrate("gitExplorer.stashFormat",mr.name("explorers")("stashFormat").value),await mr.migrate("gitExplorer.statusFileFormat",mr.name("explorers")("statusFileFormat").value),await mr.migrate("recentChanges.file.lineHighlight.locations",mr.name("recentChanges")("highlight")("locations").value)),1!==b.compare(i,b.from(8,0,0,"beta2"))&&(await mr.migrate("debug",mr.name("outputLevel").value,{migrationFn:e=>e?B.Debug:mr.get(mr.name("outputLevel").value)}),await mr.migrate("debug",mr.name("debug").value,{migrationFn:e=>void 0})),1!==b.compare(i,b.from(8,0,0,"rc"))){let e=mr.name("blame")("highlight")("locations").value;await mr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=mr.name("recentChanges")("highlight")("locations").value,await mr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==b.compare(i,b.from(8,0,0))&&(await mr.migrateIfMissing("annotations.file.gutter.gravatars",mr.name("blame")("avatars").value),await mr.migrateIfMissing("annotations.file.gutter.compact",mr.name("blame")("compact").value),await mr.migrateIfMissing("annotations.file.gutter.dateFormat",mr.name("blame")("dateFormat").value),await mr.migrateIfMissing("annotations.file.gutter.format",mr.name("blame")("format").value),await mr.migrateIfMissing("annotations.file.gutter.heatmap.enabled",mr.name("blame")("heatmap")("enabled").value),await mr.migrateIfMissing("annotations.file.gutter.heatmap.location",mr.name("blame")("heatmap")("location").value),await mr.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",mr.name("blame")("highlight")("enabled").value),await mr.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",mr.name("blame")("highlight")("locations").value),await mr.migrateIfMissing("annotations.file.gutter.separateLines",mr.name("blame")("separateLines").value),await mr.migrateIfMissing("codeLens.locations",mr.name("codeLens")("scopes").value),await mr.migrateIfMissing("codeLens.perLanguageLocations",mr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await mr.migrateIfMissing("codeLens.customLocationSymbols",mr.name("codeLens")("symbolScopes").value),await mr.migrateIfMissing("annotations.line.trailing.dateFormat",mr.name("currentLine")("dateFormat").value),await mr.migrateIfMissing("blame.line.enabled",mr.name("currentLine")("enabled").value),await mr.migrateIfMissing("annotations.line.trailing.format",mr.name("currentLine")("format").value),await mr.migrateIfMissing("annotations.file.gutter.hover.changes",mr.name("hovers")("annotations")("changes").value),await mr.migrateIfMissing("annotations.file.gutter.hover.details",mr.name("hovers")("annotations")("details").value),await mr.migrateIfMissing("annotations.file.gutter.hover.details",mr.name("hovers")("annotations")("enabled").value),await mr.migrateIfMissing("annotations.file.gutter.hover.wholeLine",mr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await mr.migrateIfMissing("annotations.line.trailing.hover.changes",mr.name("hovers")("currentLine")("changes").value),await mr.migrateIfMissing("annotations.line.trailing.hover.details",mr.name("hovers")("currentLine")("details").value),await mr.migrateIfMissing("blame.line.enabled",mr.name("hovers")("currentLine")("enabled").value),await mr.migrateIfMissing("annotations.line.trailing.hover.wholeLine",mr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await mr.migrateIfMissing("gitExplorer.gravatars",mr.name("explorers")("avatars").value),await mr.migrateIfMissing("gitExplorer.commitFileFormat",mr.name("explorers")("commitFileFormat").value),await mr.migrateIfMissing("gitExplorer.commitFormat",mr.name("explorers")("commitFormat").value),await mr.migrateIfMissing("gitExplorer.stashFileFormat",mr.name("explorers")("stashFileFormat").value),await mr.migrateIfMissing("gitExplorer.stashFormat",mr.name("explorers")("stashFormat").value),await mr.migrateIfMissing("gitExplorer.statusFileFormat",mr.name("explorers")("statusFileFormat").value),await mr.migrateIfMissing("recentChanges.file.lineHighlight.locations",mr.name("recentChanges")("highlight")("locations").value)),1!==b.compare(i,b.from(8,0,2))){const e=mr.name("keymap").value;await mr.migrate(e,e,{fallbackValue:E.Alternate,migrationFn:e=>"standard"===e?E.Alternate:e})}1!==b.compare(i,b.from(8,2,4))&&await mr.migrate("advanced.menus",mr.name("menus").value,{migrationFn:e=>({editor:{blame:!!e.editorContext.blame,clipboard:!!e.editorContext.copy,compare:!!e.editorContext.lineDiff,details:!!e.editorContext.details,history:!!e.editorContext.history,remote:!!e.editorContext.remote},editorGroup:{blame:!!e.editorTitle.blame,compare:!!e.editorTitle.fileDiff,history:!!e.editorTitle.history,remote:!!e.editorTitle.remote},editorTab:{compare:!!e.editorTitleContext.fileDiff,history:!!e.editorTitleContext.history,remote:!!e.editorTitleContext.remote},explorer:{compare:!!e.explorerContext.fileDiff,history:!!e.explorerContext.history,remote:!!e.explorerContext.remote}})})}catch(e){Ce.error(e,"migrateSettings")}}(0,o);const r=mr.get();try{let t=r.advanced.git;if(!t)try{const i=N.extensions.getExtension("vscode.git");void 0!==i&&(t=await i.exports.getGitPath())}catch(e){}await qt.initialize(t||N.workspace.getConfiguration("git").get("path"))}catch(e){return Ce.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await N.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${L}.${mr.name("advanced")("git").value}' is pointed to its installed location.`),void Q(H.Enabled,!1)}lr.initialize(e,r),Q(H.KeyMap,lr.config.keymap),lr.context.subscriptions.push(new Rs),lr.context.subscriptions.push(new Es),lr.context.subscriptions.push(new Bs),lr.context.subscriptions.push(new As),lr.context.subscriptions.push(new Ns),lr.context.subscriptions.push(new Ls),lr.context.subscriptions.push(new Ws),lr.context.subscriptions.push(new Hs),lr.context.subscriptions.push(new Gs),lr.context.subscriptions.push(new js),lr.context.subscriptions.push(new Vs),lr.context.subscriptions.push(new Qs),lr.context.subscriptions.push(new Ks),lr.context.subscriptions.push(new zs),lr.context.subscriptions.push(new Ys),lr.context.subscriptions.push(new Xs),lr.context.subscriptions.push(new Zs),lr.context.subscriptions.push(new Js),lr.context.subscriptions.push(new eo),lr.context.subscriptions.push(new to),lr.context.subscriptions.push(new io),lr.context.subscriptions.push(new so),lr.context.subscriptions.push(new oo),lr.context.subscriptions.push(new ro),lr.context.subscriptions.push(new ao),lr.context.subscriptions.push(new co),lr.context.subscriptions.push(new lo),lr.context.subscriptions.push(new uo),lr.context.subscriptions.push(new mo),lr.context.subscriptions.push(new go),lr.context.subscriptions.push(new po),lr.context.subscriptions.push(new fo),lr.context.subscriptions.push(new vo),lr.context.subscriptions.push(new wo),lr.context.subscriptions.push(new bo),lr.context.subscriptions.push(new Co),lr.context.subscriptions.push(new yo),lr.context.subscriptions.push(new xo),lr.context.subscriptions.push(new $o),lr.context.subscriptions.push(new So),lr.context.subscriptions.push(new Do),lr.context.subscriptions.push(new Fo),lr.context.subscriptions.push(new Po),lr.context.subscriptions.push(new Ro),lr.context.subscriptions.push(new To),lr.context.subscriptions.push(new Eo),lr.context.subscriptions.push(new _o),lr.context.subscriptions.push(new ko),function(e){-1===qt.compareGitVersion("2.2.0")&&Ms.showGitVersionUnsupportedErrorMessage(e)}(qt.getGitVersion()),async function(e,t){if(void 0===t)return Ce.log("GitLens first-time install"),void(lr.config.showWhatsNewAfterUpgrades&&await N.commands.executeCommand(fs.ShowWelcomePage));if(t!==e&&(Ce.log(`GitLens upgraded from v${t} to v${e}`),0===b.compare(b.fromString(t),b.from(8,0,0))))return void await N.commands.executeCommand(fs.ShowWelcomePage);if(!lr.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");i===o&&s===r||i<o||i===o&&s<r||await N.commands.executeCommand(fs.ShowWelcomePage)}(i,o),Ms.showKeyBindingsInfoMessage(),e.globalState.update(V.GitLensVersion,i);const a=process.hrtime(t);Ce.log(`GitLens(v${i}) activated in ${1e3*a[0]+Math.floor(a[1]/1e6)} ms`)}function pr(){}i.d(t,"activate",function(){return gr}),i.d(t,"deactivate",function(){return pr})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("copy-paste")},function(e,t){e.exports=require("tmp")}]);