module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)i.d(s,o,function(t){return e[t]}.bind(null,o));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i(i.s=9)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t,i){"use strict";i.r(t);var s,o,r,a,n,h,c,l,d,u,m,g,p,f,v,w,b=i(0);!function(e){e.File="file",e.Window="window"}(s||(s={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(o||(o={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(r||(r={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(a||(a={})),function(e){e.Absolute="absolute",e.Relative="relative"}(n||(n={})),function(e){e.List="list",e.Tree="tree"}(h||(h={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(c||(c={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(l||(l={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(d||(d={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(u||(u={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(m||(m={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(g||(g={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(p||(p={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(f||(f={})),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const r=s.length;for(let a=0;a<r;a++)e(t,`${i}[${a}]`,s[a],o);0===r&&(t[i]=null)}else{let r=!0;for(const a in s)r=!1,e(t,i?`${i}.${a}`:a,s[a],o);r&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const r=t[o];"object"==typeof r?s.push(...e(r,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(v||(v={})),function(e){function t(e,i,s=!0){if(void 0===e.children)return e;const o=[...v.values(e.children)];for(const e of o)t(e,i,!1);if(!s&&1===o.length){const t=o[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.groupByMap=function(e,t){return e.reduce((e,i)=>{const s=t(i),o=e.get(s)||[];return e.set(s,o),o.push(i),e},new Map)},e.groupByFilterMap=function(e,t,i){return e.reduce((e,s)=>{const o=i(s);if(null!=o){const i=t(s),r=e.get(i)||[];e.set(i,r),r.push(o)}return e},new Map)},e.makeHierarchical=function(e,i,s,o=!1){const r={name:"",relativePath:"",children:Object.create(null),descendants:[]},a=e.reduce((e,t)=>{let o=e,r="";for(const e of i(t)){r=s(r,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:r,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},r);return o?t(a,s,!0):a},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(w||(w={}));var C=i(6);const y=i(8);y.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let r;return r="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+r:r+" ago":r}}}();const x={addSuffix:!0,locale:y};var $;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),r=s.getTime()-6e4*s.getTimezoneOffset(),a=o.getTime()-6e4*o.getTimezoneOffset();return Math.round((r-a)/864e5)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(C.distanceInWordsToNow)(e,x),format:t=>Object(C.format)(e,t)}}}($||($={}));var S=i(3);const _=i(11),D=i(10);var k,F;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,r=S.__rest(s,["track"]);if(!0!==o)return _(e,t,r);let a=!1;const n=_(function(){return a=!1,e.apply(this,arguments)},t,i),h=function(){return a=!0,n.apply(this,arguments)};return h.pending=function(){return a},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return D(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(k||(k={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e,t){let i,s=0;for(;!(i=e.next()).done;)(void 0===t||t(i.value))&&s++;return s},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(F||(F={}));class P{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class T{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(47===t||92===t){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}class R{isEmpty(){return!(this.left||this.mid||this.right||this.value)}}class E{constructor(e){this._iter=e}static forPaths(){return new E(new T)}static forStrings(){return new E(new P)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new R,this._root.segment=i.value()),s=this._root;;){const e=i.cmp(s.segment);if(e>0)s.left||(s.left=new R,s.left.segment=i.value()),s=s.left;else if(e<0)s.right||(s.right=new R,s.right.segment=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new R,s.mid.segment=i.value()),s=s.mid}}const o=s.value;return s.value=t,s.key=e,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.value:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.value=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.value||i,s=s.mid}}return s&&s.value||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new E(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,e)}_forEach(e,t){void 0!==e&&(this._forEach(e.left,t),e.value&&t(e.value,e.key),this._forEach(e.mid,t),this._forEach(e.right,t))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(e){return void 0===this._root||this._root.isEmpty()?0:F.count(this.entries(),void 0===e?void 0:([t])=>e(t))}entries(){return this._iterator(this._root)}values(){return F.map(this.entries(),([e])=>e)}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}some(e){return void 0!==this._root&&!this._root.isEmpty()&&F.some(this.entries(),([t])=>e(t))}*_iterator(e){void 0!==e&&(yield*this._iterator(e.left),e.value&&(yield[e.value,e.key]),yield*this._iterator(e.mid),yield*this._iterator(e.right))}}var B,A,N=i(5);!function(e){const t=/\\/g,i=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,s=/\$\{(\w*?)(?:\W|\d)*?\}/g;function o(e,t,i=" "){const s=t-c(e);return s<=0?e:i.repeat(s)+e}function r(e,t,i=" "){const s=t-c(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const t=[];let s=i.exec(e);for(;null!=s;){const o=s[2],r=s[3];t.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===r?"left":"right",collapseWhitespace:"?"===r}}),s=i.exec(e)}return t},e.interpolate=function(e,t){return e?void 0===t?e.replace(s,""):(e=e.replace(s,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(N.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(t,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=o,e.padLeftOrTruncate=function(e,t,i){const s=c(e);return s<t?o(e,t,i):s>t?n(e,t):e},e.padRight=r,e.padOrTruncate=function(e,t,i){const s=t<0;t=Math.abs(t);const a=c(e);return a<t?s?o(e,t,i):r(e,t,i):a>t?n(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=c(e);return s<t?r(e,t,i):s>t?n(e,t):e};const a=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function n(e,t,i="…"){if(!e)return e;const s=c(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),r=c(e.substring(0,o));for(;r<t;)r+=c(e[o++]);return r>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(a,t):e},e.sha1=function(e,t="base64"){return Object(N.createHash)("sha1").update(e).digest(t)},e.truncate=n;const h=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function c(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(h,"")];for(let e=0;e<o.length;e++){const r=o[e].codePointAt(0);if(!(r<=31||r>=127&&r<=159||r>=768&&r<=879))if(r>=128512&&r<=128591||r>=127744&&r<=128511||r>=128640&&r<=128767||r>=9728&&r<=9983||r>=9984&&r<=10175||r>=65024&&r<=65039||r>=129280&&r<=129535||r>=65024&&r<=65039||r>=8400&&r<=8447){if(r>=127995&&r<=127999)continue;i++,t+=2}else 8205!==r?(r>65535&&e++,t+=l(r)?2:1):(s++,t-=2)}const r=i-s;return r>1&&(t+=r-1),t}function l(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=c}(B||(B={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,r,a]=i.split(".");return t(o,r,a,s)}}(A||(A={}));const L="gitlens",U="GitLens",O=`eamodio.${L}`,I="GitLens";var M,W,H,G,j;function V(e,t){return b.commands.executeCommand(M.SetContext,e,t)}function Q(e){const t=b.window.activeTextEditor;return null!=t&&t.document===e}function K(e){const t=e.document.uri.scheme;return t!==H.Output&&t!==H.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(M||(M={})),function(e){e.ActiveHasRemotes="gitlens:activeHasRemotes",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.HistoryExplorer="gitlens:historyExplorer",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(W||(W={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(H||(H={})),function(e){e.AngleBracketLeftHeavy="❰",e.AngleBracketRightHeavy="❱",e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowHeadRight="➤",e.ArrowLeft="←",e.ArrowLeftDouble="⇐",e.ArrowLeftRight="↔",e.ArrowLeftRightDouble="⇔",e.ArrowLeftRightDoubleStrike="⇎",e.ArrowLeftRightLong="⟷",e.ArrowRight="→",e.ArrowRightDouble="⇒",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.ArrowsHalfLeftRight="⇋",e.ArrowsHalfRightLeft="⇌",e.ArrowsLeftRight="⇆",e.ArrowsRightLeft="⇄",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.MuchGreaterThan="≪",e.MuchLessThan="⋘",e.Pencil="✎",e.Space=" ",e.SpaceThin=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(G||(G={})),(j||(j={})).GitLensVersion="gitlensVersion";const z=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var q;!function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(q||(q={}));class Y{}const X=new class extends Y{equals(e,t){return e===t}},Z=new class extends Y{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?X.equals(e.document,t.document):e.id===t.id)}},J=new class extends Y{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ee,te;!function(e){e.Computing="computing",e.Computed="computed"}(ee||(ee={}));class ie extends b.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=ie.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=b.Disposable.from(b.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(X.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=k.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ee.Computing,e===b.window.activeTextEditor&&await V(W.AnnotationStatus,this.status),this.editor=e,this.correlationKey=ie.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ee.Computed,e===b.window.activeTextEditor&&(await V(W.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ee.Computing,await this.onProvideAnnotation(e)?(this.status=ee.Computed,!0):(this.status=void 0,!1)}}function se(e){switch(e.type){case te.Branch:return"Branch";case te.Branches:return"Branches";case te.Commit:return"Commit";case te.File:return"File";case te.Repo:return"Repository";case te.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(te||(te={}));class oe{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return b.commands.executeCommand(M.Open,b.Uri.parse(e))}open(e){switch(e.type){case te.Branch:return this.openBranch(e.branch);case te.Branches:return this.openBranches();case te.Commit:return this.openCommit(e.sha);case te.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case te.Repo:return this.openRepo();case te.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}const re=/(^|\s)(issue #([0-9]+))\b/gi,ae=/(^|\s)(pull request #([0-9]+))\b/gi;class ne extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(re,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ae,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const he=/(^|\s)(issue #([0-9]+))\b/gi,ce=/(^|\s)(pull request #([0-9]+))\b/gi;class le extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(he,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(ce,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class de extends oe{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return B.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return B.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return B.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return B.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?B.interpolate(this.urls.fileLine,{line:s.start.line}):B.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?B.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?B.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):B.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const ue=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,me=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class ge extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(ue,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(me,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const pe=/(^|\s)(#([0-9]+))\b/gi;class fe extends oe{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"gitlab"}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(pe,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const ve=/(^|\s)(#([0-9]+))\b/gi,we=/\/_git\/?/i,be=new Map([["bitbucket.org",(e,t)=>new ne(e,t)],["github.com",(e,t)=>new ge(e,t)],["gitlab.com",(e,t)=>new fe(e,t)],["visualstudio.com",(e,t)=>new class extends oe{constructor(e,t,i,s){super(e,t,i,s)}get icon(){return"vsts"}get name(){return"Visual Studio Team Services"}enrichMessage(e){const t=this.baseUrl.replace(we,"/");return e.replace(ve,`$1[$2](${t}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class Ce{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void Cr.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(be);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case a.Bitbucket:return(t,i)=>new ne(t,i,e.protocol,e.name,!0);case a.BitbucketServer:return(t,i)=>new le(t,i,e.protocol,e.name,!0);case a.Custom:return(t,i)=>new de(t,i,e.urls,e.protocol,e.name);case a.GitHub:return(t,i)=>new ge(t,i,e.protocol,e.name,!0);case a.GitLab:return(t,i)=>new fe(t,i,e.protocol,e.name,!0)}}}var ye=i(7),xe=i(2),$e=i(1);const Se="win32"===process.platform;function _e(e){if(e.match(/[\\\/]/))return e;const t=$e.join(".",e);try{if(xe.statSync(t))return t}catch(e){}const i=process.env.PATH.split(Se?";":":");for(const t of i){const i=$e.join(t,e);try{if(xe.statSync(i))return i}catch(e){}}return e}function De(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:r}=s,a=S.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(ye.execFile)(e,t,a,(o,r,n)=>{if(!o)return n&&Cr.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(r);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${a.maxBuffer} bytes`)),s(o)});o&&n.stdin.end(o,r||"utf8")})}async function ke(e){const t=await De(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!Se)return{cmd:_e(t),args:i};if(!xe.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=_e(`${t}${o}`);if(xe.existsSync(s))return e(s,i)}}return t.match(/\.ps1$/i)?{cmd:$e.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)}:t.match(/\.(bat|cmd)$/i)?{cmd:$e.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]}:t.match(/\.(js)$/i)?{cmd:process.execPath,args:[t].concat(i)}:{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Fe(e){return e?ke($e.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}var Pe=i(4);class Te extends b.Uri{constructor(e,t){if(null==e)return void super();if(e.scheme===H.GitLensGit){const t=JSON.parse(e.query),[i,s]=Te.ensureValidUNCPath(e.authority,$e.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Qt.isStagedUncommitted(t.sha)&&Qt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Te.ensureValidUNCPath(e.authority,$e.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Qt.isStagedUncommitted(t.sha)&&Qt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Qt.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?b.Uri.file(this.versionedPath):b.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return Te.getDirectory($e.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return $e.basename($e.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=B.pad(G.Dot,2,2),t){let i=$e.dirname(this.fsPath);return this.repoPath&&(i=$e.relative(this.repoPath,i)),void 0!==t&&(i=$e.relative(t,i)),(i=B.normalizePath(i))&&"."!==i?`${$e.basename(this.fsPath)}${e}${i}`:$e.basename(this.fsPath)}getRelativePath(e){let t=$e.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=$e.relative(e,t)),B.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Te(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Te(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=b.Uri.file($e.resolve(t,s&&e.originalFileName||e.fileName));return new Te(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Te(b.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Te(e)}static async fromUri(e){if(e instanceof Te)return e;if(!gr.git.isTrackable(e))return new Te(e);if(e.scheme===H.GitLensGit)return new Te(e);if(e.scheme===H.Git){const t=JSON.parse(e.query),i=await gr.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Qt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Te(e,{fileName:t.path,repoPath:i,sha:s})}const t=await gr.git.getVersionedUri(e);return void 0!==t?t:new Te(e,await gr.git.getRepoPath(e))}static getDirectory(e,t){let i=$e.dirname(e);return void 0!==t&&(i=$e.relative(t,i)),(i=B.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=B.pad(G.Dot,2,2),i){let s;if(e instanceof b.Uri){if(e instanceof Te)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Te.getDirectory(s,i);return o?`${$e.basename(s)}${t}${o}`:$e.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof b.Uri){if(e instanceof Te)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=$e.relative(i||"",s);return void 0!==t&&(o=$e.relative(t,o)),B.normalizePath(o)}static toKey(e){return B.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,r;"string"==typeof e?(s="string"==typeof t?t:$e.resolve(i,t.fileName),o=e,r=Qt.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,r=e.shortSha);const a={fileName:B.normalizePath($e.relative(i,s)),repoPath:i,sha:o},n=$e.parse(s);return b.Uri.parse(`${H.GitLensGit}:${$e.join(n.dir,n.name)}:${r}${n.ext}?${JSON.stringify(a)}`)}}const Re=new Map;var Ee;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Ee||(Ee={}));const Be={dateFormat:void 0,dateStyle:void 0,reset:()=>{Be.dateStyle=vr.get(vr.name("defaultDateStyle").value),Be.dateFormat=vr.get(vr.name("defaultDateFormat").value)}};class Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=r,this.message=a,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Be.dateStyle===n.Absolute?this.formatDate(Be.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Tt.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Ee.Blame||this.type===Ee.File||this.type===Ee.StashFile}get isStash(){return this.type===Ee.Stash||this.type===Ee.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Tt.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Tt.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Tt.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Tt.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?b.Uri.file($e.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return b.Uri.file($e.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=$.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=$.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=B.pad(G.Dot,2,2)){return Te.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Re.get(i);if(void 0!==s)return s;const o=(s=b.Uri.parse(`https://www.gravatar.com/avatar/${this.email?B.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Re.set(i,s),s}getShortMessage(e=`${G.Space}${G.Ellipsis}`){const t=this.message.indexOf("\n");return-1===t?this.message:`${this.message.substring(0,t)}${e}`}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await gr.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Te.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ne extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l){super(Ee.Blame,e,t,i,s,o,r,a,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ne(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Le{constructor(e,t,i=!1,s,o,r=0,a=0){this.repoPath=e,this.current=i,this.sha=s,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.name=t,this.tracking=""===o||null==o?void 0:o,this.state={ahead:r,behind:a}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Le.getRemote(this.name):void 0!==this.tracking?Le.getRemote(this.tracking):void 0}getTrackingStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.tracking||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}isValid(){return Le.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Ue=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Oe=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Ie=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class Me{static parse(e,t=!1){if(!e)return;const i=[];let s,o,r,a=null;do{if(null==(a=Ie.exec(`${e}\n@@`)))break;s=(" "+a[5]).substr(1),o=parseInt(a[3],10),r=parseInt(a[1],10),i.push(new We(s,{start:o,end:o+parseInt(a[4],10)},{start:r,end:r+parseInt(a[2],10)}))}while(null!=a);return i.length?{diff:t?e:void 0,chunks:i}:void 0}static parseChunk(e){const t=F.skip(B.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const r=[];let a=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))a={line:n.line,state:n.state,previous:[s[e]]},r.push(a);else{if(void 0===a)continue;if(void 0===a.previous){a.previous=[s[e]];continue}a.previous.push(s[e])}return r}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Ue.exec(e)))break;i.push(wt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Oe.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class We{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=Me.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class He extends Ae{constructor(e,t,i,s,o,r,a,n,h,c,l,d,u,m){super(e,t,i,s,o,r,a,n,l,d,u),this.fileStatuses=h,this.status=c,this.parentShas=m}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Tt.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?b.Uri.file($e.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=B.normalizePath($e.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Ee.StashFile:Ee.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new He(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ge,je,Ve;!function(e){e.Fetch="fetch",e.Push="push"}(Ge||(Ge={}));class Qe{constructor(e,t,i,s,o,r,a){this.repoPath=e,this.name=t,this.scheme=i,this.domain=s,this.path=o,this.provider=r,this.types=a}}!function(e){e.Config="config",e.Closed="closed",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(je||(je={}));class Ke{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}(Ve||(Ve={})).StatusNode="statusNode";class ze extends b.Disposable{constructor(e,t,i,s,o,r=!1){if(super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new b.EventEmitter,this._onDidChangeFileSystem=new b.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this._closed=!1,i)this.formattedName=e.name;else{const i=$e.relative(e.uri.fsPath,t);this.formattedName=i?`${e.name} (${i})`:e.name}this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o,this._closed=r;const a=b.workspace.createFileSystemWatcher(new b.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=b.Disposable.from(a,a.onDidChange(this.onRepositoryChanged,this),a.onDidCreate(this.onRepositoryChanged,this),a.onDidDelete(this.onRepositoryChanged,this),vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=vr.initializing(e),i=vr.name("remotes").value;(t||vr.changed(e,i,this.folder.uri))&&(this._providerMap=Ce.createMap(vr.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(je.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(je.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(je.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(je.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(je.Config,je.Remotes);this.onAnyRepositoryChanged(this,je.Repository),this.fireChange(je.Repository)}}}get closed(){return this._closed}set closed(e){const t=this._closed!==e;this._closed=e,t&&(this.onAnyRepositoryChanged(this,je.Closed),this.fireChange(je.Closed))}containsUri(e){return e instanceof Te&&(e=void 0!==e.repoPath?b.Uri.file(e.repoPath):e.fileUri()),this.folder===b.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=gr.git.getBranch(this.path)),this._branch}getBranches(){return gr.git.getBranches(this.path)}getChangedFilesCount(e){return gr.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=vr.get(vr.name("remotes").value,this.folder.uri);this._providerMap=Ce.createMap(e)}this._remotes=gr.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return gr.git.getStashList(this.path)}getStatus(){return gr.git.getStatusForRepo(this.path)}getTags(){return gr.git.getTags(this.path)}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}async hasTrackingBranch(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=b.workspace.createFileSystemWatcher(new b.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=b.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=k.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new Ke(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=k.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}}class qe extends He{constructor(e,t,i,s,o,r,a,n,h,c,l,d){super(e,i,s,"You",void 0,o,r,a,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new qe(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class Ye{constructor(e,t,i,s,o,r){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=r}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${this._diff.added} ${1===this._diff.added?"file":"files"} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${1===this._diff.changed?"file":"files"} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${1===this._diff.deleted?"file":"files"} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),void 0===this.upstream||0===this.state.behind&&0===this.state.ahead)return e.empty;if(e.expand){let t="";return this.state.behind&&(t+=`${this.state.behind} ${1===this.state.behind?"commit":"commits"} behind`),this.state.ahead&&(t+=`${""===t?"":e.separator}${this.state.ahead} ${1===this.state.ahead?"commit":"commits"} ahead`),`${e.prefix}${t}`}return`${e.prefix}${this.state.behind}${G.ArrowDown}${e.separator}${this.state.ahead}${G.ArrowUp}`}}class Xe{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return b.Uri.file($e.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return Xe.getFormattedDirectory(this,e)}getFormattedPath(e=B.pad(G.Dot,2,2)){return Xe.getFormattedPath(this,e)}getOcticon(){return Je(this.status)}getStatusText(e){return Xe.getStatusText(this.status)}with(e){return new Xe(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Te.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${B.pad(G.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=B.pad(G.Dot,2,2),i){return Te.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Te.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return it[e]||it.X}(e)}}const Ze={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function Je(e,t=G.Space.repeat(4)){return Ze[e]||t}const et={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function tt(e){return et[e]||et.X}const it={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class st{constructor(e,t){this.repoPath=e,this.name=t}getBasename(){if(void 0===this._basename){const e=this.name.lastIndexOf("/");this._basename=-1!==e?this.name.substring(e+1):this.name}return this._basename}}class ot{static parse(e,t,i,s){if(!e)return;const o=new Map,r=new Map,a=[];let n,h,c=t&&i,l=void 0,d=!0;for(n of B.lines(e))if(!((h=n.split(" ")).length<2))if(void 0!==l)switch(h[0]){case"author":Tt.isUncommitted(l.sha)?l.author="You":(l.author=h.slice(1).join(" ").trim(),void 0!==s&&s===l.author&&(l.author="You"));break;case"author-mail":l.authorEmail=h.slice(1).join(" ").trim();const e=l.authorEmail.indexOf("<");if(e>=0){const t=l.authorEmail.indexOf(">",e);l.authorEmail=t>e?l.authorEmail.substring(e+1,t):l.authorEmail.substring(e+1)}break;case"author-time":l.authorDate=h[1];break;case"author-tz":l.authorTimeZone=h[1];break;case"summary":l.summary=h.slice(1).join(" ").trim();break;case"previous":l.previousSha=h[1],l.previousFileName=h.slice(2).join(" ");break;case"filename":l.fileName=h.slice(1).join(" "),d&&void 0===t&&(t=B.normalizePath(i.replace(i.startsWith("/")?`/${l.fileName}`:l.fileName,"")),c=B.normalizePath($e.relative(t,i))),d=!1,ot.parseEntry(l,t,c,r,o,a),l=void 0}else l={sha:h[0],originalLine:parseInt(h[1],10)-1,line:parseInt(h[2],10)-1,lineCount:parseInt(h[3],10)};return r.forEach(e=>{if(void 0===e.author)return;const t=o.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...o.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:a}}static parseEntry(e,t,i,s,o,r){let a=s.get(e.sha);if(void 0===a){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}a=new Ne(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,a)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};a.previousSha&&(i.previousSha=a.previousSha),a.lines.push(i),r[i.line]=i}}}const rt=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,at=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class nt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=rt.exec(e)))break;const[o,r]=this.parseState(s[5]);i.push(new Le(t,s[2],"*"===s[1],s[3],s[4],o,r))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=at.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const ht=/diff --git a\/(.*) b\/(.*)/,ct={};class lt{static parse(e,t,i,s,o,r,a,n,h){if(!e)return;let c,l,d=void 0,u=ct,m=void 0,g=0,p=!0;const f=B.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=B.normalizePath(i));const b=new Map,C=new Map;for(;!((v=f.next()).done||(m=v.value,n&&a&&g>=a));)switch(l=m.charCodeAt(1)){case 114:u={ref:m.substring(4)};break;case 97:Tt.isUncommitted(u.ref)?u.author="You":(u.author=m.substring(4),void 0!==r&&r===u.author&&(u.author="You"));break;case 101:u.email=m.substring(4);break;case 100:u.date=m.substring(4);break;case 112:u.parentShas=m.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(m=v.value);)void 0===u.summary?u.summary=m:u.summary+=`\n${m}`;void 0!==u.summary&&(u.summary=u.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(m=v.value);)if(!m.startsWith("warning:"))if(t===Ee.Branch){const e={status:m[0],fileName:m.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===u.fileStatuses&&(u.fileStatuses=[]),u.fileStatuses.push(e))}else{if(m.startsWith("diff")){const e=ht.exec(m);if(null!=e){u.fileName=e[1];const t=e[2];u.fileName!==t&&(u.originalFileName=t),u.status=u.fileName!==u.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}u.status=m[0],u.fileName=m.substring(1),this.parseFileName(u)}void 0!==u.fileStatuses&&(u.fileName=w.filterMap(u.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Ee.File&&void 0!==s?(i=B.normalizePath(s.replace(s.startsWith("/")?`/${u.fileName}`:u.fileName,"")),c=B.normalizePath($e.relative(i,s))):c=u.fileName,p=!1;const e=C.get(u.ref);void 0===e&&g++,d=lt.parseEntry(u,e,t,i,c,C,b,d)}return{repoPath:i,authors:b,commits:C,sha:o,count:g,maxCount:a,range:h,truncated:!!(a&&g>=a&&1!==a)}}static parseEntry(e,t,i,s,o,r,a,n){if(void 0===t){if(void 0!==e.author){let t=a.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},a.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Ee.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new He(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),r.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Ee.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const dt=/^(.*)\t(.*)\s\((.*)\)$/gm,ut=/^(?:(git:\/\/)(.*?)\/|(https?:\/\/)(?:.*?@)?(.*?)\/|git@(.*):|(ssh:\/\/)(?:.*@)?(.*?)(?::.*?)?\/|(?:.*?@)(.*?):)(.*)$/;class mt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let r=null;do{if(null==(r=dt.exec(e)))break;const a=r[2],[n,h,c]=this.parseGitUrl(a),l=`${h}/${c}`;let d=o[l];void 0===d?(d=new Qe(t,r[1],n,h,c,i(h,c),[{url:a,type:r[3]}]),s.push(d),o[l]=d):d.types.push({url:a,type:r[3]})}while(null!=r);return s.length?s:[]}static parseGitUrl(e){const t=ut.exec(e);return null==t?["","",""]:[t[1]||t[3]||t[6],t[2]||t[4]||t[5]||t[7]||t[8],t[9].replace(/\.git\/?$/,"")]}}const gt={};class pt{static parse(e,t){if(!e)return;const i=B.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=B.normalizePath(t));const o=new Map;let r,a=gt,n=void 0;for(;!(s=i.next()).done;)switch(r=(n=s.value).charCodeAt(1)){case 114:a={ref:n.substring(4)};break;case 100:a.date=n.substring(4);break;case 108:a.stashName=n.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(n=s.value);)void 0===a.summary?a.summary=n:a.summary+=`\n${n}`;void 0!==a.summary&&(a.summary=a.summary.slice(0,-1));break;case 102:if(!(s=i.next()).done&&"</f>"!==s.value){for(;!(s=i.next()).done&&"</f>"!==(n=s.value);){if(n.startsWith("warning:"))continue;const e={status:n[0],fileName:n.substring(1),originalFileName:void 0};lt.parseFileName(e),e.fileName&&(void 0===a.fileStatuses&&(a.fileStatuses=[]),a.fileStatuses.push(e))}void 0!==a.fileStatuses&&(a.fileNames=w.filterMap(a.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "))}let e=o.get(a.ref);e=pt.parseEntry(a,e,t,o)}return{repoPath:t,commits:o}}static parseEntry(e,t,i,s){return void 0===t&&(t=new qe(Ee.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const ft=/(?:ahead ([0-9]+))/,vt=/(?:behind ([0-9]+))/;class wt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let r,a=-1;for(;++a<e.length;){const n=e[a];if(n.startsWith("##")){const e=n.split(" ");if([i,r]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=ft.exec(t);o.ahead=null==i?0:+i[1]||0;const s=vt.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,r]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,r.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new Ye(B.normalizePath(t),i||"","",s,o,r)}static parseV2(e,t){let i;const s=[];let o;const r={ahead:0,behind:0};let a,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":a=e[2];break;case"branch.ab":r.ahead=+e[2].substring(1),r.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new Ye(B.normalizePath(t),i||"",o||"",s,r,a)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let r=void 0;return t.length>1&&(""!==(r="."!==t[1]?t[1].trim():void 0)&&null!==r||(r=void 0)),new Xe(e,o,r,i,s)}}class bt{static parse(e,t){if(!e)return;const i=w.filterMap(e.split("\n"),e=>e?new st(t,e):void 0);return i.length?i:void 0}}let Ct;const yt=["blame","--root","--incremental"],xt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],$t=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],St={badRevision:/bad revision \'.*?\'/i},_t={notARepository:/Not a git repository/i,outsideRepository:/is outside repository/i,noPath:/no such path/i,noCommits:/does not have any commits/i,notFound:/Path \'.*?\' does not exist in/i,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/i,headNotABranch:/HEAD does not point to a branch/i,noUpstream:/no upstream configured for branch \'(.*?)\'/i,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree|not stored as a remote-tracking branch/i};async function Dt(e,...t){try{return await Ft(e,...t)}catch(i){return Pt(i,e,...t)}}const kt=new Map;async function Ft(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=S.__rest(e,["correlationKey"]),r=e.encoding||"utf8",a=Object.assign({},o,{encoding:"utf8"===r?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,h=`(${a.cwd}${void 0!==s?s:""}): ${n}`;let c,l,d=kt.get(h);void 0===d?(Cr.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),d=De(Ct.path,t,a),kt.set(h,d)):Cr.log(`Awaiting${h}`);try{c=await d}catch(e){throw l=e,e}finally{kt.delete(h);const e=process.hrtime(i),t=`${void 0===l?"Completed":"FAILED"} in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;Cr.log(`${void 0===l?"Completed":"FAILED"}${h} ${t}`),Cr.logGitCommand(`${n} ${t}`,a.cwd,l)}return"utf8"===r||"binary"===r?c:Pe.decode(Buffer.from(c,"binary"),r)}function Pt(e,t,...i){const s=e&&e.toString();if(s)for(const e of v.values(_t))if(e.test(s))return Cr.warn("git",...i,`  cwd='${t.cwd}'\n\n  `,s.replace(/\r?\n|\r/g," ")),"";throw Cr.error(e,"git",...i,`  cwd='${t.cwd}'\n\n  `),e}class Tt{static gitInfo(){return Ct}static getEncoding(e){return void 0!==e&&Pe.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Ct=await async function(e){try{return await ke(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await De("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return ke(e);try{return await De("xcode-select",["-p"]),ke(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):ke(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Fe(process.env.ProgramW6432).then(null,()=>Fe(process.env["ProgramFiles(x86)"])).then(null,()=>Fe(process.env.ProgramFiles)).then(null,()=>ke("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}(e);const i=process.hrtime(t);return Cr.log(`Git found: ${Ct.version} @ ${"git"===Ct.path?"PATH":Ct.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Ct}static async getVersionedFile(e,t,s){const o=await Tt.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Tt.isStagedUncommitted(s)&&(s="");const r=B.truncate(B.sanitizeForFileSystem(Tt.isSha(s)?Tt.shortenSha(s):s),50,""),a=$e.extname(t),n=await Promise.resolve().then(i.t.bind(null,13,7));return new Promise((i,h)=>{n.file({prefix:`${$e.basename(t,a)}-${r}__`,postfix:a},(r,a,n,c)=>{r?h(r):(Cr.log(`getVersionedFile[${a}]('${e}', '${t}', ${s})`),xe.appendFile(a,o,{encoding:"binary"},e=>{e?h(e):xe.chmod(a,33060,e=>{i(a)})}))})})}static isResolveRequired(e){return Tt.isSha(e)&&!Tt.shaStrictRegex.test(e)}static isSha(e){return Tt.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Tt.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Tt.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(Tt.isStagedUncommitted(e))return t.stagedUncommitted;if(Tt.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=B.normalizePath(e);const i=((t=B.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=B.normalizePath(i?$e.dirname(e):t),e=B.normalizePath(i?$e.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Ct.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...yt];let n;return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),i&&(Tt.isStagedUncommitted(i)?(a.push("--contents","-"),n=await Tt.show(e,t,":")):a.push(i)),Dt({cwd:r,stdin:n},...a,"--",o)}static async blame_contents(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e),a=[...yt];return s.ignoreWhitespace&&a.push("-w"),null!=s.startLine&&null!=s.endLine&&a.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&a.push(...s.args),a.push("--contents","-"),Dt({cwd:r,stdin:i,correlationKey:s.correlationKey},...a,"--",o)}static branch(e,t={all:!1}){const i=["-c","color.branch=false","branch","-vv"];return t.all&&i.push("-a"),Dt({cwd:e},...i)}static branch_contains(e,t,i={remote:!1}){const s=["-c","color.branch=false","branch","--contains"];return i.remote&&s.push("-r"),Dt({cwd:e},...s,t)}static checkout(e,t,i){const[s,o]=Tt.splitPath(t,e);return Dt({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await Ft({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const r=["-c","color.diff=false","diff","--diff-filter=M","-M","--no-ext-diff","--minimal"];return i&&r.push(Tt.isStagedUncommitted(i)?"--staged":i),s&&r.push(Tt.isStagedUncommitted(s)?"--staged":s),Dt({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...r,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["-c","color.diff=false","diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Dt({cwd:e},...o)}static diff_shortstat(e,t){const i=["-c","color.diff=false","diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Dt({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Dt({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Dt({cwd:e},...o)}static log(e,t){const i=[...xt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Tt.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Dt({cwd:e},...i,"--")}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Tt.splitPath(t,e),r=[...xt];return i.maxCount&&!i.reverse&&r.push(`-n${i.maxCount}`),i.renames&&r.push("--follow","-m","--first-parent"),i.ref&&!Tt.isStagedUncommitted(i.ref)&&(i.reverse?r.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):r.push(i.ref)),null!=i.startLine&&null!=i.endLine&&r.push(`-L ${i.startLine},${i.endLine}:${s}`),Dt({cwd:o},...r,"--",s)}static async log_recent(e,t){try{return(await Ft({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await Ft({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...xt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),Dt({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Tt.isStagedUncommitted(t.ref)&&i.push(t.ref),Dt({cwd:e},...i,"--")}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Tt.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await Ft({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Dt({cwd:e},...o,t,i)}static remote(e){return Dt({cwd:e},"remote","-v")}static remote_url(e,t){return Dt({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await Ft({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await Ft(i,...t)}catch(e){const s=e&&e.toString();if(_t.headNotABranch.test(s))return;const o=_t.noUpstream.exec(s);if(null!==o)return o[1];if(_t.unknownRevision.test(s))try{const t=["symbolic-ref","-q","--short","HEAD"];return await Ft(i,...t)}catch(e){return}return Pt(e,i,...t)}}static async revparse_toplevel(e){try{return(await Ft({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,r]=Tt.splitPath(t,e);if(Tt.isStagedUncommitted(i)&&(i=":"),Tt.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const a={cwd:r,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await Ft(a,"show",n,"--")}catch(o){const r=o&&o.toString();if(":"===i&&St.badRevision.test(r))return Tt.show(e,t,"HEAD:",s);if(St.badRevision.test(r)||_t.notFound.test(r)||_t.foundButNotInRevision.test(r))return;return Pt(o,a,n)}}static stash_apply(e,t,i){if(t)return Dt({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Dt({cwd:e},"stash","drop",t)}static stash_list(e){return Dt({cwd:e},...$t)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Dt({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Dt({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Dt({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"-c","color.status=false","status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Tt.splitPath(t,e),r=i>=2?`--porcelain=v${i}`:"--porcelain";return Dt({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"-c","color.status=false","status",r,s)}static tag(e){return Dt({cwd:e},...["tag","-l"])}}Tt.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Tt.shaStrictRegex=/^[0-9a-f]{40}$/,Tt.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Tt.stagedUncommittedSha="0000000000000000000000000000000000000000:",Tt.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Tt.uncommittedSha="0000000000000000000000000000000000000000";class Rt extends b.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new b.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===gr.git&&!await k.waitUntil(()=>void 0!==gr.git,2e3))throw Cr.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Te.fromUri(e),this._disposed)return;const t=await gr.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(je.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){V(W.ActiveIsRevision,this.isRevision),V(W.ActiveFileIsTracked,this.isTracked),V(W.ActiveIsBlameable,this.isBlameable),V(W.ActiveHasRemotes,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,Cr.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&Q(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=b.window.activeTextEditor;return null!=t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await gr.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&void 0===(s=e.repo)&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemotes(),void 0!==t){const s=this.isBlameable;if(V(W.ActiveIsRevision,this.isRevision),V(W.ActiveFileIsTracked,this.isTracked),V(W.ActiveIsBlameable,s),V(W.ActiveHasRemotes,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class Et extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new b.EventEmitter,this._onDidChangeDirtyState=new b.EventEmitter,this._onDidTriggerDirtyIdle=new b.EventEmitter,this._documentMap=new Map,this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this),b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,0),this),b.workspace.onDidChangeTextDocument(k.debounce(this.onTextDocumentChanged,50),this),b.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),b.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(b.window.activeTextEditor)}onConfigurationChanged(e){const t=vr.initializing(e);if(!t&&(vr.changed(e,vr.name("blame")("ignoreWhitespace").value,null)||vr.changed(e,vr.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=vr.name("advanced")("blame")("delayAfterEdit").value;(t||vr.changed(e,i))&&(this._dirtyIdleTriggerDelay=vr.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!K(e))return;if(void 0===e)return V(W.ActiveIsRevision,!1),V(W.ActiveFileIsTracked,!1),V(W.ActiveIsBlameable,!1),void V(W.ActiveHasRemotes,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==H.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=b.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?Q(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof b.Uri)&&(e=Te.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Te)try{e=await b.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new At(e);else{if(!i.includes("File not found"))throw t;e=new Nt(e)}}else e instanceof b.Uri&&(e=await b.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Te?e=Te.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof b.Uri)&&(e=Te.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Te.toKey(e.uri),i=new Rt(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),b.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=k.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=k.debounce(async e=>{b.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class Bt{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=b.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class At extends Bt{}class Nt extends Bt{}class Lt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class Ut extends Et{}class Ot{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=B.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:B.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?B.padLeft(e,i):(t.collapseWhitespace&&(i-=o),B.padRight(e,i))):o<0?B.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof Ot)return B.interpolate(t,e);let o=void 0;return o=null==s||"string"==typeof s?{dateFormat:s,tokenOptions:B.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}:s,void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),B.interpolate(t,this._formatter)}}Ot._formatter=void 0;class It extends Ot{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:gr.config.defaultDateStyle)===n.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;return e=this._item.isStagedUncommitted?"Staged changes":this._item.isUncommitted?"Uncommitted changes":this._options.truncateMessageAtNewLine?this._item.getShortMessage():this._item.message,this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Mt extends Ot{get directory(){const e=Xe.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=$e.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=Xe.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=Xe.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=Xe.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${G.Pencil} ${G.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}const Wt={doesNotExist:/no such file or directory/i};var Ht,Gt,jt,Vt;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Ht||(Ht={}));class Qt extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new b.EventEmitter,this._suspended=!1,this._userNameMapCache=new Map,this._repositoryTree=E.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=b.Disposable.from(b.window.onDidChangeWindowState(this.onWindowStateChanged,this),b.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return gr.config.advanced.caching.enabled}onAnyRepositoryChanged(e,t){this._trackedCache.clear(),t===je.Closed&&setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}onConfigurationChanged(e){(vr.initializing(e)||vr.changed(e,vr.name("defaultDateStyle").value)||vr.changed(e,vr.name("defaultDateFormat").value))&&Be.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:b.workspace.workspaceFolders||[],removed:[]},Cr.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==H.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==H.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...F.map(i.entries(),([t,i])=>[t,$e.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=vr.get(vr.name("advanced")("repositorySearchDepth").value,t);Cr.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const s=process.hrtime(),o=[],r=this.onAnyRepositoryChanged.bind(this),a=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==a&&(Cr.log(`Repository found in '${a}'`),o.push(new ze(e,a,!0,r,this._suspended))),i<=0){const e=process.hrtime(s);return Cr.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),o}let n,h=Object.assign({},b.workspace.getConfiguration("files",t).get("exclude",{}),b.workspace.getConfiguration("search",t).get("exclude",{}));h=[...F.filterMap(v.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));try{n=await this.repositorySearchCore(t.fsPath,i,h)}catch(e){return Wt.doesNotExist.test(e.message||"")?Cr.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' FAILED${e.message?` (${e.message})`:""}`):Cr.error(e,`Searching for repositories (depth=${i}) in '${t.fsPath}' FAILED`),o}for(let t of n){if(t=$e.dirname(t),B.normalizePath(t)===a)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(Cr.log(`Repository found in '${i}'`),o.push(new ze(e,i,!1,r,this._suspended)))}const c=process.hrtime(s);return Cr.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*c[0]+Math.floor(c[1]/1e6)} ms`),o}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,r)=>{xe.readdir(e,async(a,n)=>{if(null!=a)return void r(a);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=$e.resolve(e,t);return new Promise((e,r)=>{xe.stat(o,(r,a)=>{".git"===t?s.push(o):null==r&&!0!==i[t]&&null!=a&&a.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await V(W.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await V(W.HasRemotes,i),!t){const e=b.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=b.Disposable.from(e,e.onDidCreate(async e=>{const i=b.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,Cr.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Tt.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>xe.exists($e.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&F.first(s.commits.values());if(o)return o;const r=await this.findNextFileName(e,t,i);return r&&(o=(s=await this.getLogForFile(e,r,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&F.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Tt.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=F.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Tt.splitPath(s,t)):s=B.normalizePath($e.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){let t;if(null!=(e=e||b.window.activeTextEditor)){const i=await gr.tracker.getOrAdd(e.document.uri);void 0!==i&&(t=i.uri.repoPath)}return null!=t?t:this.getHighlanderRepoPath()}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await gr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return Cr.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}Cr.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Lt(i.key))}else Cr.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(Cr.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return Cr.log(`Skipping blame; '${e.fsPath}' is not tracked`),Qt.emptyPromise;const[s,o]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const r=await Tt.blame(o,s,e.sha,{args:gr.config.advanced.blame.customArguments,ignoreWhitespace:gr.config.blame.ignoreWhitespace});return ot.parse(r,o,s,await this.getCurrentUsername(o))}catch(e){if(void 0!==t.state){const s=e&&e.toString();return Cr.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Qt.emptyPromise,errorMessage:s}),t.setBlameFailure(),Qt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${B.sha1(t)}`,s=await gr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return Cr.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}Cr.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Lt(s.key))}else Cr.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(Cr.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return Cr.log(`Skipping blame; '${e.fsPath}' is not tracked`),Qt.emptyPromise;const[o,r]=Tt.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Tt.blame_contents(r,o,t,{args:gr.config.advanced.blame.customArguments,correlationKey:`:${s}`,ignoreWhitespace:gr.config.blame.ignoreWhitespace});return ot.parse(a,r,o,await this.getCurrentUsername(r))}catch(e){if(void 0!==i.state){const t=e&&e.toString();return Cr.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Qt.emptyPromise,errorMessage:t}),i.setBlameFailure(),Qt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(Cr.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Tt.blame(e.repoPath,o,e.sha,{args:gr.config.advanced.blame.customArguments,ignoreWhitespace:gr.config.blame.ignoreWhitespace,startLine:s,endLine:s}),r=ot.parse(i,e.repoPath,o,await this.getCurrentUsername(e.repoPath));if(void 0===r)return;return{author:F.first(r.authors.values()),commit:F.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(Cr.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const r=s.commits.get(o.sha);if(void 0===r)return;return{author:Object.assign({},s.authors.get(r.author),{lineCount:r.lines.length}),commit:r,line:o}}const o=t+1,r=e.fsPath;try{const s=await Tt.blame_contents(e.repoPath,r,i,{args:gr.config.advanced.blame.customArguments,ignoreWhitespace:gr.config.blame.ignoreWhitespace,startLine:o,endLine:o}),a=await this.getCurrentUsername(e.repoPath),n=ot.parse(s,e.repoPath,r,a);if(void 0===n)return;return{author:F.first(n.authors.values()),commit:F.first(n.commits.values()),line:n.lines[t]}}catch(e){return}}async getBlameForRange(e,t){Cr.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(Cr.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),r=new Map,a=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});a.set(t.sha,e);let s=r.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},r.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...r.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;Cr.log(`getBranch('${e}')`);const t=await Tt.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Le(e,i[0],!0,void 0,i[1])}async getBranches(e){if(void 0===e)return[];Cr.log(`getBranches('${e}')`);const t=await Tt.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return nt.parse(t,e)||[]}async getChangedFilesCount(e,t){Cr.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Tt.diff_shortstat(e,t);return Me.parseShortStat(i)}async getConfig(e,t){return Cr.log(`getConfig('${e}', '${t}')`),await Tt.config_get(e,t)}async getCurrentUsername(e){let t=this._userNameMapCache.get(e);return void 0===t&&(t=await Tt.config_get("user.name",e),this._userNameMapCache.set(e,t)),t}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await gr.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Cr.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),r.item}Cr.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Lt(o.key))}else Cr.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const r=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Qt.getEncoding(e)},o,s);return void 0!==o.state&&(Cr.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getDiffForFileCore(e,t,i,s,o,r,a){const[n,h]=Tt.splitPath(t,e,!1);try{const t=await Tt.diff(h,n,i,s,o);return Me.parse(t)}catch(e){if(void 0!==r.state){const t=e&&e.toString();return Cr.log(`Replace diff cache with empty promise for '${r.state.key}:${a}'`),r.state.set(a,{item:Qt.emptyPromise,errorMessage:t}),Qt.emptyPromise}return}}async getDiffForLine(e,t,i,s){Cr.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const r=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===r)return;return r.lines[t-r.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){Cr.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Tt.diff_nameStatus(e,t,i,s);return Me.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Tt.log_recent(e,t)}async getLogCommit(e,t){Cr.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){Cr.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Tt.isResolveRequired(i.ref)?o||F.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),Cr.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?gr.config.advanced.maxListItems||0:t.maxCount;try{const s=await Tt.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=lt.parse(s,Ee.Branch,e,void 0,t.ref,await this.getCurrentUsername(e),i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){Cr.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?gr.config.advanced.maxListItems||0:s.maxCount,r=void 0;switch(i){case Ht.Author:r=[`--author=${t}`];break;case Ht.ChangedOccurrences:r=[`-S${t}`,"--pickaxe-regex"];break;case Ht.Changes:r=[`-G${t}`];break;case Ht.Files:r=["--",`${t}`];break;case Ht.Message:r=[`--grep=${t}`];break;case Ht.Sha:r=[t],o=1}try{const a=await Tt.log_search(e,r,{maxCount:o}),n=lt.parse(a,Ee.Branch,e,void 0,void 0,await this.getCurrentUsername(e),o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===B.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=gr.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await gr.tracker.getOrAdd(new Te(b.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const r=o.state.get(s);if(void 0!==r)return Cr.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;if("log"!==s){const r=o.state.get("log");if(void 0!==r){if(void 0===i.ref)return Cr.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item;Cr.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await r.item;if(void 0!==o&&o.commits.has(i.ref))return Cr.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),r.item}}}Cr.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new Lt(o.key))}else Cr.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(Cr.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return Cr.log(`Skipping log; '${t}' is not tracked`),Qt.emptyPromise;const[r,a]=Tt.splitPath(t,e,!1);try{const{range:n}=i,h=S.__rest(i,["range"]),c=null==i.maxCount?gr.config.advanced.maxListItems||0:i.maxCount,l=await Tt.log_file(a,r,Object.assign({},h,{maxCount:c,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),d=lt.parse(l,Ee.File,a,r,h.ref,await this.getCurrentUsername(a),c,h.reverse,n);if(void 0!==d){const s=Object.assign({},i);d.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return d}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return Cr.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Qt.emptyPromise,errorMessage:t}),Qt.emptyPromise}return}}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async hasTrackingBranch(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasTrackingBranch()}async getMergeBase(e,t,i,s={}){try{const o=await Tt.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void Cr.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];Cr.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];Cr.log(`getRemotesCore('${e}')`),t=t||Ce.createMap(vr.get(vr.name("remotes").value,null));try{const i=await Tt.remote(e);return mt.parse(i,e,Ce.factory(t))}catch(e){return Cr.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(null==e)return await this.getActiveRepoPath();if(e instanceof Te)return e.repoPath;let i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await gr.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s);let r=void 0===o?b.workspace.getWorkspaceFolder(b.Uri.file(s)):o.folder;if(void 0===r){const e=s.split("/");r={uri:b.Uri.file(s),name:e[e.length-1],index:this._repositoryTree.count()}}return i=new ze(r,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended),this._repositoryTree.set(s,i),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()}),s}async getRepoPathCore(e,t){try{return await Tt.revparse_toplevel(t?e:$e.dirname(e))}catch(e){return void Cr.error(e,"GitService.getRepoPathCore")}}async getRepoPathOrActive(e,t){return await gr.git.getRepoPath(e)||gr.git.getActiveRepoPath(t)}async getRepositories(e){const t=(await this.getRepositoryTree()).values();return void 0!==e?F.filter(t,e):t}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Te){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;Cr.log(`getStashList('${e}')`);const t=await Tt.stash_list(e);return pt.parse(t,e)}async getStatusForFile(e,t){Cr.log(`getStatusForFile('${e}', '${t}')`);const i=Tt.validateVersion(2,11)?2:1,s=await Tt.status_file(e,t,i),o=wt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;Cr.log(`getStatusForRepo('${e}')`);const t=Tt.validateVersion(2,11)?2:1,i=await Tt.status(e,t);return wt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];Cr.log(`getTags('${e}')`);const t=await Tt.tag(e);return bt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(Cr.log(`getVersionedFile('${e}', '${t}', '${i}')`),i===Qt.deletedSha)return;if(!i||Tt.isUncommitted(i)&&!Tt.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Tt.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Te.toKey(s),new Te(b.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return Cr.log(`getVersionedFileText('${e}', '${t}', ${i})`),Tt.show(e,t,i,{encoding:Qt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Te.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===H.File||t===H.Git||t===H.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Qt.deletedSha)return!1;let s,o,r=i.ref;if("string"==typeof e)[o,t]=Tt.splitPath(e,t),s=Te.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,r=e.sha,s=Te.toKey(o)}void 0!==r&&(s+=`:${r}`),Cr.log(`isTracked('${o}', '${t}'${void 0!==r?`, '${r}'`:""})`);let a=this._trackedCache.get(s);try{return void 0!==a?a=await a:(a=this.isTrackedCore(o,void 0===t?"":t,r),i.skipCacheUpdate?a=await a:(this._trackedCache.set(s,a),a=await a,this._trackedCache.set(s,a),a))}finally{Cr.log(`isTracked('${o}', '${t}'${void 0!==r?`, '${r}'`:""}) = ${a}`)}}async isTrackedCore(e,t,i){if(i===Qt.deletedSha)return!1;try{let s=!!await Tt.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Tt.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return Cr.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Tt.config_get("diff.guitool",e)||await Tt.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Cr.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Tt.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return Cr.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Tt.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return Qt.isResolveRequired(t)?(Cr.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),null==i?await Tt.revparse(e,t)||t:await Tt.log_resolve(e,B.normalizePath($e.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return Cr.log(`stashApply('${e}', '${t}', ${i})`),Tt.stash_apply(e,t,i)}stashDelete(e,t){return Cr.log(`stashDelete('${e}', '${t}')`),Tt.stash_delete(e,t)}stashSave(e,t,i){if(Cr.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Tt.stash_save(e,t);Qt.ensureGitVersion("2.13.2","Stashing individual files");const s=i.map(t=>Tt.splitPath(t.fsPath,e)[0]);return Tt.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?b.Uri.file($e.join(e,t)):e;return Tt.getEncoding(b.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Tt.getGitInfo(e)}static getGitPath(){return Tt.gitInfo().path}static getGitVersion(){return Tt.gitInfo().version}static isResolveRequired(e){return Tt.isResolveRequired(e)}static isSha(e){return Tt.isSha(e)}static isStagedUncommitted(e){return Tt.isStagedUncommitted(e)}static isUncommitted(e){return Tt.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===Qt.deletedSha?t.deleted:Tt.isSha(e)||Tt.isStagedUncommitted(e)?Tt.shortenSha(e,t):e}static compareGitVersion(e,t){return A.compare(A.fromString(this.getGitVersion()),A.fromString(e))}static ensureGitVersion(e,t){const i=this.getGitVersion();if(-1===A.compare(A.fromString(i),A.fromString(e)))throw new Error(`${t} requires a newer version of Git (>= ${e}) than is currently installed (${i}). Please install a more recent version of Git to use this GitLens feature.`)}}Qt.emptyPromise=Promise.resolve(void 0),Qt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Qt.stagedUncommittedSha=Tt.stagedUncommittedSha,Qt.uncommittedSha=Tt.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Gt||(Gt={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(jt||(jt={}));class Kt extends b.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class zt extends Kt{get repoPath(){return this.uri.repoPath}}class qt extends Kt{constructor(e,t){super(new Te),this.message=e,this.tooltip=t}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.message,b.TreeItemCollapsibleState.None);return e.contextValue=jt.Message,e.tooltip=this.tooltip,e}}class Yt extends Kt{constructor(e,t,i){super(new Te),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.message,b.TreeItemCollapsibleState.None);return e.contextValue=jt.Pager,e.command=this.getCommand(),e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:gr.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class Xt extends Yt{constructor(e,t,i){super(`${e} ${G.Space}${G.Dash}${G.Space} this may take a while`,t,i),this.args={maxCount:0}}}class Zt extends Kt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of v.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new Zt(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Folder,e.iconPath=b.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(Vt||(Vt={}));class Jt extends Kt{constructor(e,t,i,s){super(Te.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await gr.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&Vt.CommitIcon)===Vt.CommitIcon)e.iconPath={dark:gr.context.asAbsolutePath($e.join("images","dark","icon-commit.svg")),light:gr.context.asAbsolutePath($e.join("images","light","icon-commit.svg"))};else if((this.displayAs&Vt.StatusIcon)===Vt.StatusIcon){const t=tt(this.status.status);e.iconPath={dark:gr.context.asAbsolutePath($e.join("images","dark",t)),light:gr.context.asAbsolutePath($e.join("images","light",t))}}else(this.displayAs&Vt.Gravatar)===Vt.Gravatar&&(e.iconPath=this.commit.getGravatarUri(gr.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&Vt.CommitLabel?It.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dateFormat:gr.config.defaultDateFormat}):Mt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return jt.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&Vt.CommitLabel?this._tooltip=It.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:gr.config.defaultDateFormat}):this._tooltip=Mt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:gs.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ei extends Kt{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(ei.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==c.List){e=[];for(const t of v.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new ei(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof ei?-1:1)-(t instanceof ei?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Folder,e.iconPath=b.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||c.Auto;if(s===c.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return c.List}return c.Tree}return s}}class ti extends zt{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.getBranchTips=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...F.map(e.fileStatuses,t=>new Jt(t,e.toFileCommit(t),this.explorer,Vt.File))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new ei(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=It.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:gr.config.defaultDateFormat});const t=this.getBranchTips&&this.getBranchTips(this.commit.sha);void 0!==t&&(e=`${G.AngleBracketLeftHeavy}${G.SpaceThin}${t}${G.SpaceThin}${G.AngleBracketRightHeavy}${G.ArrowHeadRight}${G.Space} ${e}`);const i=new b.TreeItem(e,b.TreeItemCollapsibleState.Collapsed);return i.contextValue=void 0===this.branch||this.branch.current?jt.CommitOnCurrentBranch:jt.Commit,this.explorer.config.avatars?i.iconPath=this.commit.getGravatarUri(gr.config.defaultGravatarsStyle):i.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-commit.svg"),light:gr.context.asAbsolutePath("images/light/icon-commit.svg")},i.tooltip=It.fromTemplate(this.commit.isUncommitted?`\${author} ${G.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${G.Dash} \${id}${void 0!==t?` (${t})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:gr.config.defaultDateFormat}),i}getCommand(){return{title:"Compare File with Previous Revision",command:gs.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ii extends zt{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===h.List?e:Le.isValid(e)&&!this.current?this.branch.getBasename():e}get markCurrent(){return!0}get ref(){return this.branch.name}async getChildren(){const e=await gr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new qt("No commits yet")];const t=await gr.git.getBranches(this.uri.repoPath),i=t[0].sha.length,s=w.groupByFilterMap(t,e=>e.sha,e=>e.name===this.branch.name?void 0:e.name),o=e=>{const t=s.get(e.substr(0,i));if(void 0!==t&&0!==t.length)return t.join(", ")},r=[...F.map(e.commits.values(),e=>new ti(e,this.explorer,this.branch,o))];return e.truncated&&r.push(new Xt("Show All Commits",this,this.explorer)),r}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=`${this.branch.getTrackingStatus({prefix:`${G.Space} `})}${G.Space} ${G.ArrowLeftRightLong}${G.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${G.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const s=new b.TreeItem(`${this.markCurrent&&this.current?`${G.Check} ${G.Space}`:""}${e}`,b.TreeItemCollapsibleState.Collapsed);return s.tooltip=t,this.branch.remote?s.contextValue=jt.RemoteBranch:this.current?s.contextValue=this.branch.tracking?jt.CurrentBranchWithTracking:jt.CurrentBranch:s.contextValue=this.branch.tracking?jt.BranchWithTracking:jt.Branch,s.iconPath={dark:gr.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:gr.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},s}}class si extends Kt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...F.filterMap(e,e=>e.remote?void 0:new ii(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===h.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=w.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),o=new Zt(this.repo.path,"",void 0,s,this.explorer),r=await o.getChildren();return void 0!==i&&r.splice(0,0,i),r}async getTreeItem(){const e=new b.TreeItem("Branches",b.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?jt.BranchesWithRemotes:jt.Branches,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-branch.svg"),light:gr.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class oi extends Kt{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...F.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new ii(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===h.List)return t;const i=w.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Zt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ge.Fetch),t=this.remote.types.find(e=>e.type===Ge.Push);let i;i=e&&t?G.ArrowLeftRightLong:e?G.ArrowLeft:t?G.ArrowRight:G.Dash;const s=`${this.remote.name} ${G.Space}${i}${G.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${G.Space}${G.Dot}${G.Space} ${this.remote.path}`,o=new b.TreeItem(s,b.TreeItemCollapsibleState.Collapsed);return o.contextValue=jt.Remote,o.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?o.iconPath={dark:gr.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:gr.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:o.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:gr.context.asAbsolutePath("images/light/icon-remote.svg")},o}}class ri extends Kt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new qt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...F.map(e,e=>new oi(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new b.TreeItem("Remotes",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Remotes,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-remote.svg"),light:gr.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class ai extends Kt{constructor(e,t,i,s){super(Te.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new Jt(this.status,e,this.explorer,Vt.CommitLabel|(this.explorer.config.avatars?Vt.Gravatar:Vt.CommitIcon)))}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=b.TreeItemCollapsibleState.None,e.contextValue=jt.StatusFile,this.commit.isStagedUncommitted?e.tooltip=Mt.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=Mt.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=jt.StatusFileCommits,e.tooltip=Mt.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=tt(this.status.status);return e.iconPath={dark:gr.context.asAbsolutePath($e.join("images","dark",t)),light:gr.context.asAbsolutePath($e.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Mt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(`${t} ${1===t?"commit":"commits"}`),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:gs.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ni extends Kt{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await gr.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(F.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...F.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Qt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Qt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Qt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new He(Ee.File,t,Qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const s=w.groupBy(e,e=>e.fileName);let o=[...F.map(v.values(s),e=>new ai(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(o,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new ei(t,"",void 0,e,this.explorer);o=await i.getChildren()}else o.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&o.push(new Xt("Show All Changes",this,this.explorer)),o}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await gr.git.getChangedFilesCount(this.repoPath,this.status.upstream);void 0!==t&&(e=t.files)}const t=`${e} ${1===e?"file":"files"} changed`,i=new b.TreeItem(t,b.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=jt.StatusFiles,i.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-diff.svg"),light:gr.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class hi extends Kt{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await gr.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...F.map(t.commits.values(),e=>new ti(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await gr.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=F.first(t.commits.values())),[...F.map(i,e=>new ti(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} ${1===this.status.state.ahead?"commit":"commits"} (ahead of ${this.status.upstream})`:`${this.status.state.behind} ${1===this.status.state.behind?"commit":"commits"} (behind ${this.status.upstream})`,t=new b.TreeItem(e,b.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=jt.StatusUpstream,t.iconPath={dark:gr.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:gr.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class ci extends Kt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren(),this.children=[];const e=await this.repo.getStatus();if(void 0!==e&&(e.state.behind&&this.children.push(new hi(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new hi(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree)){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new ni(e,t,this.explorer,this.active))}let t=await this.repo.getBranch();return void 0!==t&&(void 0!==e&&(t=new Le(t.repoPath,t.name,t.current,t.sha,t.tracking,e.state.ahead,e.state.behind)),this.children.push(new li(t,this.uri,this.explorer))),this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new b.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=b.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o=`${e.getUpstreamStatus({prefix:`${G.Space} `})}${i?e.getDiffStatus({prefix:`${G.Space} `}):""}`,r=`${e.branch} (current)`,a="";e.upstream&&(this.explorer.config.showTrackingBranch&&(o+=`${G.Space} ${G.ArrowLeftRightLong}${G.Space} ${e.upstream}`),r+=`\n\nTracking ${G.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(a="-red"),e.state.ahead&&(a=e.state.behind?"-yellow":"-green"))),i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),s=(t||i)&&this.active?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.Collapsed;const n=new b.TreeItem(`${e.branch}${o}`,s);return n.id=this.id,n.contextValue=jt.Status,n.tooltip=r,n.iconPath={dark:gr.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:gr.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},n}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class li extends ii{constructor(e,t,i){super(e,t,i)}get markCurrent(){return!1}async getTreeItem(){const e=await super.getTreeItem();return e.label=`History (${e.label})`,e}}class di extends Jt{constructor(e,t,i){super(e,t,i,Vt.File)}get resourceType(){return jt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class ui extends zt{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await gr.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=F.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new di(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new b.TreeItem(It.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:gr.config.defaultDateFormat}),b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Stash,e.tooltip=It.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dateFormat:gr.config.defaultDateFormat}),e}}class mi extends Kt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new qt("No stashed changes")]:[...F.map(e.commits.values(),e=>new ui(e,this.explorer))]}getTreeItem(){const e=new b.TreeItem("Stashes",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Stashes,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-stash.svg"),light:gr.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class gi extends zt{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get label(){return this.explorer.config.branches.layout===h.Tree?this.tag.getBasename():this.tag.name}get ref(){return this.tag.name}async getChildren(){const e=await gr.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new qt("No commits yet")];const t=[...F.map(e.commits.values(),e=>new ti(e,this.explorer))];return e.truncated&&t.push(new Xt("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Tag,e}}class pi extends Kt{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();if(0===e.length)return[new qt("No tags yet")];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...e.map(e=>new gi(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===h.List)return t;const i=w.makeHierarchical(t,e=>e.tag.name.split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Zt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}async getTreeItem(){const e=new b.TreeItem("Tags",b.TreeItemCollapsibleState.Collapsed);return e.contextValue=jt.Tags,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-tag.svg"),light:gr.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class fi extends Kt{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return void 0===this.children&&(this.updateSubscription(),this.children=[new ci(this.uri,this.repo,this.explorer,this.active),new si(this.uri,this.repo,this.explorer,this.active),new ri(this.uri,this.repo,this.explorer,this.active),new mi(this.uri,this.repo,this.explorer,this.active),new pi(this.uri,this.repo,this.explorer,this.active)]),this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${B.pad(G.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new b.TreeItem(e,this.active?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=jt.Repository,t}refresh(){this.resetChildren(),this.updateSubscription()}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||b.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(Cr.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(je.Repository)||e.changed(je.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(je.Stashes)){const e=this.children.find(e=>e instanceof mi);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(je.Remotes)){const e=this.children.find(e=>e instanceof ri);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(je.Tags)){const e=this.children.find(e=>e instanceof pi);void 0!==e&&this.explorer.refreshNode(e)}}}}class vi extends Kt{constructor(e){super(void 0),this.explorer=e,gr.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(b.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!K(e))return;let t=!1;try{const i=await gr.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await gr.git.getRepository(i);if(void 0===s||s.closed)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new fi(Te.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new b.TreeItem("No active repository",b.TreeItemCollapsibleState.None);return e.id=this.id,e}}class wi extends Kt{constructor(e,t,i=jt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new ti(this.commit,this.explorer).getChildren();return e.splice(0,0,new qt(It.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!0}),It.fromTemplate("${message}",this.commit))),e}async getTreeItem(){const e=It.fromTemplate(`Commit \${sha} ${B.pad(G.Dash,1,1)} \${authorAgoOrDate}`,this.commit,gr.config.defaultDateFormat),t=new b.TreeItem(e,b.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class bi extends Kt{constructor(e,t,i,s,o=jt.ResultsCommits){super(Te.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...F.map(e.commits.values(),e=>new ti(e,this.explorer))];return e.truncated&&t.push(new Xt("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new b.TreeItem(await this.getLabel(),e&&e.count>0?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class Ci extends Kt{constructor(e,t,i,s,o){super(Te.fromFileStatus(t,e,i||s||void 0)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new b.TreeItem(this.label,b.TreeItemCollapsibleState.None);e.contextValue=jt.StatusFile,e.tooltip=Mt.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=tt(this.status.status);return e.iconPath={dark:gr.context.asAbsolutePath($e.join("images","dark",t)),light:gr.context.asAbsolutePath($e.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=$e.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Mt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:gs.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Te.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class yi extends Kt{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...F.map(e,e=>new Ci(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==c.List){const e=w.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>B.normalizePath($e.join(...e)),this.explorer.config.files.compact),i=new ei(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new b.TreeItem(await this.getLabel(),e&&e.length>0?b.TreeItemCollapsibleState.Expanded:b.TreeItemCollapsibleState.None);return t.contextValue=jt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await gr.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${0===t?"No":t} ${1===t?"file":"files"} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class xi extends Kt{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){return this.resetChildren(),this.children=[new bi(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>gr.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new yi(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await gr.git.getRepositoryCount()>1){const t=await gr.git.getRepository(this.uri.repoPath);e=` ${B.pad(G.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new b.TreeItem(`Comparing ${this.ref1.label||Qt.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||Qt.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,b.TreeItemCollapsibleState.Expanded);return t.contextValue=jt.ComparisonResults,t}}class $i extends Kt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=Vt.CommitLabel|(this.explorer.config.avatars?Vt.Gravatar:Vt.StatusIcon),i=await gr.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Qt.uncommittedSha,void 0!==i.indexStatus?o=Qt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Qt.stagedUncommittedSha,o="HEAD");const r=new He(Ee.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new Jt(i,r,this.explorer,t))}const s=await gr.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...F.map(s.commits.values(),e=>new Jt(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new qt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new b.TreeItem(`${this.uri.getFormattedPath()}`,b.TreeItemCollapsibleState.Expanded);return e.contextValue=jt.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-history.svg"),light:gr.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable=this.disposable||this.repo.onDidChange(this.onRepoChanged,this)}onRepoChanged(e){e.changed(je.Repository)&&(Cr.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class Si extends Kt{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new $i(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new b.TreeItem(`${this.uri.getFormattedPath()}`,b.TreeItemCollapsibleState.Expanded);return e.contextValue=jt.History,e.iconPath={dark:gr.context.asAbsolutePath("images/dark/icon-history.svg"),light:gr.context.asAbsolutePath("images/light/icon-history.svg")},e}}class _i extends Kt{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return void 0===this.children&&(this.children=this.repositories.sort((e,t)=>e.index-t.index).filter(e=>!e.closed).map(e=>new fi(Te.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new vi(this.explorer))),this.children}refresh(){this.resetChildren()}getTreeItem(){const e=new b.TreeItem("Repositories",b.TreeItemCollapsibleState.Expanded);return e.contextValue=jt.Repositories,e}}function Di(){return!vr.get(vr.name("advanced")("quickPick")("closeOnFocusOut").value)}function ki(e,t){const i=new b.CancellationTokenSource;return async function(e,t,i){const s=i&&await gr.keyboard.beginScope(i);try{await b.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Di()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Fi{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):b.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class Pi extends Fi{constructor(e){super({label:e,description:""})}}class Ti extends Fi{constructor(e,t){super({label:"",description:""},e,t)}}class Ri extends Fi{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return ks(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ei extends Fi{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await ks(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Bi{constructor(e){this.commit=e;const t=e.getShortMessage();e.isStash?(this.label=t,this.description="",this.detail=`${G.Space} ${e.stashName||e.shortSha} ${B.pad(G.Dot,1,1)} ${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${B.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${G.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${B.pad(G.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Ai extends Fi{constructor(e,t={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays commit in the GitLens Results explorer`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){gr.resultsExplorer.showCommitInResults(this.commit)}}class Ni extends Fi{constructor(e,t,i={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays commits in the GitLens Results explorer`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){gr.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Li extends Ni{constructor(e,t,i={label:"Show in Results",description:`${B.pad(G.Dash,2,2)} displays results in the GitLens Results explorer`}){super(e,{label:t},i),this.results=e,this.search=t}}class Ui extends Fi{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${B.pad(G.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=ji.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([gr.git.getBranches(this.repoPath),gr.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return ji.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.cancel()}}}const Oi=Object.create(null),Ii=["left","right",",",".","escape"],Mi=[];class Wi extends b.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||Oi}async dispose(){const e=Mi.indexOf(this.mapping);Cr.log("KeyboardScope.dispose",Mi.length,e),e===Mi.length-1?(Mi.pop(),await this.updateKeyCommandsContext(Mi[Mi.length-1])):Mi.splice(e,1)}async begin(){return Mi.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Mi[Mi.length-1];t===this.mapping&&t[e]&&(Cr.log("KeyboardScope.clearKeyCommand",Mi.length,e),t[e]=void 0,await V(`${W.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Mi[Mi.length-1];i===this.mapping&&(Cr.log("KeyboardScope.setKeyCommand",Mi.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await V(`${W.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Ii)t.push(V(`${W.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class Hi extends b.Disposable{constructor(){super(()=>this.dispose());const e=Ii.map(e=>b.commands.registerCommand(`${L}.key.${e}`,()=>this.execute(e),this));this._disposable=b.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return Cr.log("Keyboard.beginScope",Mi.length),await new Wi(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Mi.length)try{let t=Mi[Mi.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return Cr.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void Cr.error(e,"Keyboard.execute")}}}class Gi{constructor(e){this.branchOrTag=e,e instanceof Le?(this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""):(this.label=`${G.Space.repeat(4)} ${e.name}`,this.description=`${G.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Le&&this.branchOrTag.remote}}class ji{static showProgress(e){return ki(e,{left:Oi,",":Oi,".":Oi})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new Gi(e)),...t.map(e=>new Gi(e)),...e.filter(e=>e.remote).map(e=>new Gi(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await gr.keyboard.beginScope({left:s.goBackCommand||Oi});s.progressCancellation&&s.progressCancellation.cancel();const a=await b.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Di()});return await r.dispose(),a}}class Vi{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${G.Space}`:G.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${G.Space.repeat(2)} remote branch`:""}}class Qi{static async show(e,t,i={}){const s=e.map(e=>new Vi(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await b.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Di()})}}class Ki extends Fi{constructor(e,t){super({label:`$(link-external) Open ${se(t)} in ${e.provider.name}`,description:`${B.pad(G.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class zi extends Fi{constructor(e,t,i){const s=se(t);let o="";switch(t.type){case te.Branch:o=`$(git-branch) ${t.branch}`;break;case te.Branches:o="$(git-branch) Branches";break;case te.Commit:o=`$(git-commit) ${Qt.shortenSha(t.sha)}`;break;case te.File:o=`$(file-text) ${$e.basename(t.fileName)}`;break;case te.Repo:o="$(repo) Repository";break;case te.Revision:if(void 0!==t.commit&&t.commit instanceof He)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${$e.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${G.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${$e.basename(t.fileName)} in ${G.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Qt.shortenSha(t.sha);o=`$(file-text) ${$e.basename(t.fileName)}${e?` in ${G.Space}$(git-commit) ${e}`:""}`}}const r=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===r.provider.name)?r.provider.name:"Remote"}${G.Ellipsis}`,description:`${B.pad(G.Dash,2,3)} ${o}`},gs.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${r.provider.name}`,description:`${B.pad(G.Dash,2,3)} $(repo) ${r.provider.path} ${B.pad(G.Dot,1,1)} ${o}`},gs.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class qi{static async show(e,t,i,s){const o=e.map(e=>new Ki(e,i));s&&o.splice(0,0,s);const r=await b.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Di()});if(void 0!==r)return r}}class Yi{static showProgress(e){return ki(`${e} history ${G.Dash} search by commit message, filename, or commit id`,{left:Oi,",":Oi,".":Oi})}static async show(e,t,i,s,o,r){const a=Array.from(F.map(e.commits.values(),e=>new Bi(e))),n=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i} history`},gs.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=await gr.git.getRemotes(t&&t.repoPath||e.repoPath);h.length&&a.splice(0,0,new zi(h,{type:"branch",branch:i},n)),a.splice(0,0,new Fi({label:"$(search) Show Commit Search",description:`${B.pad(G.Dash,2,3)} search for commits by message, author, files, or commit id`},gs.ShowCommitSearch,[Te.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&a.splice(0,0,new Fi({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},gs.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),r&&a.splice(0,0,r),e.truncated)){const s=new Fi({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${e.maxCount} newer commits`},gs.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),n=F.last(e.commits.values());null!=n&&(c=new Fi({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${e.maxCount} older commits`},gs.ShowQuickBranchHistory,[new Te(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),a.splice(0,0,c))}if(o&&a.splice(0,0,o),s.token.isCancellationRequested)return;const l=await gr.keyboard.beginScope({left:o,",":c,".":r});s.cancel();const d=await b.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${G.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Di()});return await l.dispose(),d}}class Xi extends Fi{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${B.pad(G.Dash,2,3)} $(file-text) ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await gr.git.checkoutFile(e),ks(e,{preserveFocus:!0,preview:!1})}}class Zi extends Ri{constructor(e,t){super(b.Uri.file($e.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)}`})}}class Ji extends Ri{constructor(e,t){let i,s;"D"===e.status?(s=Te.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.previousShortSha} (deleted in ${G.Space}$(git-commit) ${e.shortSha})`):(s=Te.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${B.pad(G.Dash,2,3)} ${$e.basename(e.fileName)} in ${G.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class es{static async show(e,t,i,s,o){const r=[],a=e.isStash,n=e.workingFileName&&$e.basename(e.workingFileName)||$e.basename(e.fileName),h=e.isUncommitted;if(h){const t=await gr.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),a&&r.push(new Xi(e)),e.previousFileShortSha&&r.push(new Fi({label:"$(git-compare) Open Changes",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},gs.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Fi({label:"$(git-compare) Open Changes with Working Tree",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-text) ${n}`},gs.DiffWithWorking,[b.Uri.file($e.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new Zi(e)),r.push(new Ji(e));const c=await gr.git.getRemotes(e.repoPath);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await gr.git.getBranch(e.repoPath);void 0!==t&&r.push(new zi(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}a||r.push(new zi(c,{type:"revision",fileName:e.fileName,commit:e},s))}a||(r.push(new Xi(e)),r.push(new Fi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.shortSha}`},gs.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Fi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage()}`},gs.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Fi({label:"$(history) Show File History",description:`${B.pad(G.Dash,2,3)} of ${$e.basename(e.fileName)}`},gs.ShowQuickFileHistory,[b.Uri.file($e.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),a||(r.push(new Fi({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${B.pad(G.Dash,2,3)} of ${$e.basename(e.fileName)} ${B.pad(G.Dot,1,1)} from ${G.Space}$(git-commit) ${e.shortSha}`},gs.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),r.push(new Fi({label:"$(git-commit) Show Commit Details",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha}`},gs.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&r.splice(0,0,i);let l=void 0,d=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.previousSha){if(void 0===(s=await gr.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:gr.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Oi;void 0===(r=s&&s.commits.get(e.sha))&&e.isMerge&&(r=F.first(s.commits.values())),r&&(r.nextSha=e.nextSha,r.nextFileName=e.nextFileName)}return void 0===r||void 0===r.previousSha?Oi:new Ti(gs.ShowQuickCommitFileDetails,[r.previousUri,{fileLog:s,sha:r.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,r=s&&s.commits.get(e.sha);if(void 0===r||void 0===r.nextSha){s=void 0,r=void 0;const i=await gr.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((r=e).nextSha=i.sha,r.nextFileName=i.originalFileName||i.fileName)}return void 0===r||void 0===r.nextSha?Oi:new Ti(gs.ShowQuickCommitFileDetails,[r.nextUri,{fileLog:s,sha:r.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new Ti(gs.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new Ti(gs.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const u=await gr.keyboard.beginScope({left:i,",":l,".":d}),m=await b.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${B.pad(G.Dot,1,1)} ${h?`Uncommitted ${G.ArrowRightHollow} `:""}${e.shortSha} ${B.pad(G.Dot,1,1)} ${e.author}, ${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getShortMessage()}`,ignoreFocusOut:Di(),onDidSelectItem:e=>{u.setKeyCommand("right",e)}});return await u.dispose(),m}}class ts extends Ri{constructor(e,t){const i=Je(t.status),s=Xe.getFormattedDirectory(t,!0);super(Te.toRevisionUri(e.sha,t,e.repoPath),{label:`${B.pad(i,4,2)} ${$e.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):b.commands.executeCommand(gs.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class is extends Ei{constructor(e,t=!1,i){const s=e.repoPath;super(w.filterMap(e.fileStatuses,e=>Te.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class ss extends Ei{constructor(e,t){super(w.filterMap(e.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${B.pad(G.Dash,2,3)} in ${G.Space}$(git-commit) ${e.shortSha}`})}}class os{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new ts(e,t)),a=e.isStash;let n=0;if(a)r.splice(n++,0,new Fi({label:"$(git-pull-request) Apply Stashed Changes",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage()}`},gs.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Fi({label:"$(x) Delete Stashed Changes",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage()}`},gs.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),r.splice(n++,0,new Ai(e));else{r.splice(n++,0,new Ai(e));const t=await gr.git.getRemotes(e.repoPath);t.length&&r.splice(n++,0,new zi(t,{type:"commit",sha:e.sha},s))}r.splice(n++,0,new is(e)),r.splice(n++,0,new ss(e)),r.splice(n++,0,new Fi({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${G.Space} $(git-compare) ${G.Space} $(git-commit) ${e.shortSha}`},gs.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(n++,0,new Fi({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${B.pad(G.Dash,2,3)} $(git-commit) ${e.shortSha} ${G.Space} $(git-compare) ${G.Space} $(file-directory) Working Tree`},gs.DiffDirectory,[t,{ref1:e.sha}])),a||r.splice(n++,0,new Fi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.shortSha}`},gs.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(n++,0,new Fi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${B.pad(G.Dash,2,3)} ${e.getShortMessage()}`},gs.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(n++,0,new Fi({label:"Changed Files",description:e.getDiffStatus()},gs.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let h=void 0,c=void 0;a||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await gr.git.getLog(e.repoPath,{maxCount:gr.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Oi:new Ti(gs.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await gr.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&F.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Oi:new Ti(gs.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new Ti(gs.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new Ti(gs.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await gr.keyboard.beginScope({left:i,",":h,".":c}),d=await b.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${B.pad(G.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${B.pad(G.Dot,1,1)} ${e.getShortMessage()}`,ignoreFocusOut:Di(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class rs{static showProgress(e){return ki(e,{left:Oi,",":Oi,".":Oi})}static async show(e,t,i,s){const o=e&&[...F.map(e.commits.values(),e=>new Bi(e))]||[new Pi("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const r=await gr.keyboard.beginScope({left:s.goBackCommand});i.cancel();const a=await b.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Di()});return await r.dispose(),a}}class as{static showProgress(e){return ki(e,{left:Oi,",":Oi,".":Oi})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(F.map(e.commits.values(),e=>new Bi(e)));let r=0;if(s.pickerOnly&&(r++,o.splice(0,0,new Ui(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(r++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)r++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await gr.git.findWorkingFileName($e.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,o.splice(0,0,new Fi({label:"$(history) Show File History",description:`${B.pad(G.Dash,2,3)} of ${$e.basename(i)}`},gs.ShowQuickFileHistory,[b.Uri.file($e.resolve(e.repoPath,i)),{goBackCommand:new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},gs.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(r++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(r++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await gr.git.getBranch(t.repoPath);if(void 0!==i){const a=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(t.fsPath)}${t.sha?` from ${G.Space}$(git-commit) ${t.shortSha}`:""}`},gs.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(r++,0,new Fi({label:"$(history) Show Branch History",description:`${B.pad(G.Dash,2,3)} shows  ${G.Space}$(git-branch) ${i.name} history`},gs.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:a}]));const n=await gr.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(r++,0,new zi(n,e,a))}}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await gr.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await b.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Di()});return await a.dispose(),n}}class ns{static async show(){const e=Object.keys(gr.config.modes);if(0===e.length)return;const t=gr.config.mode.active,i=e.map(e=>{const i=gr.config.modes[e];return{label:`${t===e?"$(check)  ":"     "}${i.name} mode`,description:i.description?` ${G.Dash}  ${i.description}`:"",key:e}});return t&&i.splice(0,0,{label:`Exit ${gr.config.modes[t].name} mode`,key:void 0}),await b.window.showQuickPick(i,{placeHolder:"select a GitLens mode to enter"})}}class hs{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class cs{static async show(e,t){const i=[...F.map(await gr.git.getRepositories(),e=>new hs(e))];return void 0!==t&&i.splice(0,0,t),await b.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Di()})}}class ls extends Ri{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":G.Space.repeat(3)}${B.pad(s,2,2)} ${$e.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new He(Ee.File,e.repoPath,Qt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new He(Ee.File,e.repoPath,Qt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Qt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return b.commands.executeCommand(gs.DiffWithPrevious,Te.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class ds extends Fi{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},gs.OpenChangedFiles,[void 0,{uris:i}])}}class us{static computeStatus(e){let t=0,i=0,s=0,o=0,r=0,a=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":r++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":a++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+r,l=i+o+a;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${r}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${a}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...F.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new ls(e.with({indexStatus:null}),e.indexStatus),new ls(e.with({workTreeStatus:null}))]:[new ls(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${e.branch} status`},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const r=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;r>-1&&(i.splice(r,0,new Fi({label:"Unstaged Files",description:o.unstagedStatus},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(r,0,new ds(o.stagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new ds(o.unstagedAddsAndChanges,{label:`${G.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Fi({label:"Staged Files",description:o.stagedStatus},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Fi({label:"Unstaged Files",description:o.unstagedStatus},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new ds(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Fi({label:"$(x) Close Unchanged Files",description:""},gs.CloseUnchangedFiles))):i.push(new Fi({label:"No changes in the working tree",description:""},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Fi({label:"$(inbox) Show Stashed Changes",description:`${B.pad(G.Dash,2,3)} shows stashed changes in the repository`},gs.ShowQuickStashList,[Te.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Fi({label:`$(cloud-upload)${G.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${G.Space}$(git-branch) ${e.upstream}`,description:`${B.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.branch} but not ${G.Space}$(git-branch) ${e.upstream}`},gs.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Fi({label:`$(cloud-download)${G.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${G.Space}$(git-branch) ${e.upstream}`,description:`${B.pad(G.Dash,2,3)} shows commits in ${G.Space}$(git-branch) ${e.upstream} but not ${G.Space}$(git-branch) ${e.branch}${e.sha?` (since ${G.Space}$(git-commit) ${Qt.shortenSha(e.sha)})`:""}`},gs.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Fi({label:`$(git-branch) ${e.branch} is up-to-date with ${G.Space}$(git-branch) ${e.upstream}`,description:""},gs.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await gr.keyboard.beginScope({left:t}),a=await b.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${B.pad(G.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Di(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),a}}class ms{static showProgress(e){return ki("apply"===e?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,{left:Oi,",":Oi,".":Oi})}static async show(e,t,i,s,o){const r=e&&Array.from(F.map(e.commits.values(),e=>new Bi(e)))||[];if("list"===t&&r.splice(0,0,new Fi({label:"$(plus) Stash Changes",description:`${B.pad(G.Dash,2,3)} stashes all changes`},gs.StashSave,[{goBackCommand:o}])),s&&r.splice(0,0,s),i.token.isCancellationRequested)return;const a=await gr.keyboard.beginScope({left:s});i.cancel();const n=await b.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${G.Ellipsis}`:`stashed changes ${G.Dash} search by message, filename, or commit id`,ignoreFocusOut:Di()});return await a.dispose(),n}}var gs;function ps(e,t){if(e instanceof b.Uri)return e;if(null==t)return;const i=t.document;return null!=i?i.uri:void 0}async function fs(e,t,i,s){let o=await gr.git.getRepoPathOrActive(e,t);if(!o){const e=await cs.show(i,s);if(e instanceof Fi)return void await e.execute();if(void 0===e)return void(void 0!==s&&await s.execute());o=e.repoPath}return o}function vs(e){return"view"===e.type&&e.node.branch instanceof Le}function ws(e){return"view"===e.type&&e.node.commit instanceof Ae}function bs(e){return"view"===e.type&&e.node.remote instanceof Qe}function Cs(e){return null!=e&&void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates)}function ys(e){return null!=e&&null!=e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithPreviousInDiff="gitlens.diffWithPreviousInDiff",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowGitExplorer="gitlens.showGitExplorer",e.ShowHistoryExplorer="gitlens.showHistoryExplorer",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowResultsExplorer="gitlens.showResultsExplorer",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.SwitchMode="gitlens.switchMode",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame",e.ToggleReviewMode="gitlens.toggleReviewMode",e.ToggleZenMode="gitlens.toggleZenMode"}(gs||(gs={}));class xs extends b.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=b.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>b.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=b.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=xs.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(null==o||function(e){return null!=e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(null==o||o instanceof b.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof Kt){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(ys(o)){const t=[];let s=0;for(const e of i){if(!ys(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(Cs(o)){const t=[];let s=0;for(const e of i){if(!Cs(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class $s extends xs{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,b.window.activeTextEditor,...t)}}let Ss=void 0;class _s extends $s{constructor(e){super(e)}_execute(e,...t){return Ss={command:e,args:t},super._execute(e,...t)}}class Ds extends b.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(b.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=b.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function ks(e,t={}){const{rethrow:i}=t,s=S.__rest(t,["rethrow"]);try{if(e instanceof Te&&(e=e.fileUri({noSha:!0})),e.scheme===H.GitLensGit){const t=Te.fromRevisionUri(e);if(z.includes($e.extname(t.fsPath))){const i=await gr.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==i)return e=b.Uri.file(i),void await b.commands.executeCommand(M.Open,e)}}const o=await b.workspace.openTextDocument(e);return b.window.showTextDocument(o,Object.assign({preserveFocus:!1,preview:!0,viewColumn:b.ViewColumn.Active},s))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await b.commands.executeCommand(M.Open,e);if(i)throw t;return void Cr.error(t,"openEditor")}}class Fs extends Ds{constructor(){super([gs.ClearFileAnnotations,gs.ComputingFileAnnotations])}async execute(e,t,i){if(null!=e){if(null!=i&&!J.equals(i,e.document.uri)){const t=b.window.visibleTextEditors.find(e=>J.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return gr.fileAnnotations.clear(e)}catch(e){return Cr.error(e,"ClearFileAnnotationsCommand"),b.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Ps extends b.Disposable{constructor(){super(()=>this.dispose());const e=k.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=b.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return b.commands.executeCommand(M.CloseActiveEditor)}async next(){return b.commands.executeCommand(M.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=void 0,t(e))}),s=setTimeout(()=>{t(b.window.activeTextEditor),s=void 0},e)});return this._resolver=void 0,t}}class Ts extends $s{constructor(){super(gs.CloseUnchangedFiles)}async execute(e,t,i={}){t=ps(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await fs(t,e,`Close unchanged files in which repository${G.Ellipsis}`);if(!s)return;const o=await gr.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to close unchanged files");i.uris=o.files.map(e=>e.uri)}if(0===i.uris.length)return b.commands.executeCommand(M.CloseAllEditors);const s=new Ps;let o=0,r=void 0;for(e=b.window.activeTextEditor;;){if(null!=e){if(Z.equals(r,e,{useId:!0,usePosition:!0}))break;if(void 0!==e.document&&(e.document.isDirty||i.uris.some(t=>J.equals(t,e.document&&e.document.uri)))){const t=r;if(r=e,e=await s.awaitNext(500),Z.equals(t,e,{useId:!0,usePosition:!0}))break;continue}}if(r=e,e=await s.awaitClose(500),void 0===r&&null==e){if(++o>=4)break}else o=0}return void s.dispose()}catch(e){return Cr.error(e,"CloseUnchangedFilesCommand"),b.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Rs extends $s{constructor(){super(gs.CopyMessageToClipboard)}async preExecute(e,t={}){return ws(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ps(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await gr.git.getActiveRepoPath(e);if(!t)return;const i=await gr.git.getLog(t,{maxCount:1});if(!i)return;s.message=F.first(i.commits.values()).message}else if(void 0===s.message){const i=await Te.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await gr.git.getBlameForLineContents(i,t,e.document.getText()):await gr.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return Cr.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const o=await gr.git.getLogCommit(i.repoPath,s.sha);if(void 0===o)return;s.message=o.message}return void o.write(s.message)}catch(e){return Cr.error(e,"CopyMessageToClipboardCommand"),b.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class Es extends $s{constructor(){super(gs.CopyShaToClipboard)}async preExecute(e,t={}){return ws(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=ps(t,e);const o=await Promise.resolve().then(i.t.bind(null,12,7));try{if(s=Object.assign({},s),null==t){const t=await gr.git.getActiveRepoPath(e);if(!t)return;const i=await gr.git.getLog(t,{maxCount:1});if(!i)return;s.sha=F.first(i.commits.values()).sha}else if(void 0===s.sha){const i=e&&e.selection.active.line||0;if(i<0)return;try{const o=await Te.fromUri(t),r=e&&e.document&&e.document.isDirty?await gr.git.getBlameForLineContents(o,i,e.document.getText()):await gr.git.getBlameForLine(o,i);if(void 0===r)return;s.sha=r.commit.sha}catch(e){return Cr.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${i})`),b.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.write(s.sha)}catch(e){return Cr.error(e,"CopyShaToClipboardCommand"),b.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}class Bs extends $s{constructor(){super([gs.DiffHeadWithBranch,gs.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case gs.DiffHeadWithBranch:t.ref2="HEAD";break;case gs.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=ps(t,e);try{const o=await fs(t,e,`Compare with branch or tag in which repository${G.Ellipsis}`);if(!o)return;if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to ${G.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to ${G.Ellipsis}`;break;default:e=`Compare ${i.ref2} to ${G.Ellipsis}`}s=ji.showProgress(e);const[t,r]=await Promise.all([gr.git.getBranches(o),gr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await ji.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Fi)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void gr.resultsExplorer.showComparisonInResults(o,i.ref1,i.ref2)}catch(e){return Cr.error(e,"DiffBranchWithBranchCommand"),b.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.cancel()}}}class As extends $s{constructor(){super([gs.DiffDirectory,gs.ExternalDiffAll,gs.ExplorersOpenDirectoryDiff,gs.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case gs.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case gs.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof xi&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case gs.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof zt})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=ps(t,e);try{const o=await fs(t,e,`Compare directory in which repository${G.Ellipsis}`);if(!o)return;if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to ${G.Ellipsis}`;s=ji.showProgress(e);const[t,r]=await Promise.all([gr.git.getBranches(o),gr.git.getTags(o)]);if(s.token.isCancellationRequested)return;const a=await ji.show(t,r,e,{progressCancellation:s});if(void 0===a)return;if(a instanceof Fi)return a.execute();if(i.ref1=a.name,void 0===i.ref1)return}return void gr.git.openDirectoryDiff(o,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await b.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return b.commands.executeCommand(M.Open,b.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return Cr.error(e,"DiffDirectoryCommand"),b.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.cancel()}}}var Ns,Ls,Us;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitDisabledWarning="suppressGitDisabledWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice"}(Ns||(Ns={}));class Os{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Os.showMessage("info","Commit has no previous commit.",Ns.CommitHasNoPreviousCommitWarning):Os.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,Ns.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Os.showMessage("warn",`${e}. The commit could not be found.`,Ns.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Os.showMessage("warn",`${e}. The file is probably not under source control.`,Ns.FileNotUnderSourceControlWarning)}static showGitDisabledErrorMessage(){return Os.showMessage("error","GitLens requires Git to be enabled. Please re-enable Git — set `git.enabled` to true and reload",Ns.GitDisabledWarning)}static showGitVersionUnsupportedErrorMessage(e){return Os.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,Ns.GitVersionWarning)}static async showKeyBindingsInfoMessage(){if(gr.config.advanced.messages.suppressShowKeyBindingsNotice)return;if(gr.config.keymap!==g.Alternate)return void await this.suppressedMessage(Ns.ShowKeyBindingsNotice);const e=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],t=await Os.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",Ns.ShowKeyBindingsNotice,null,...e);switch(t){case e[1]:await vr.update(vr.name("keymap").value,g.Chorded,b.ConfigurationTarget.Global);break;case e[2]:await vr.update(vr.name("keymap").value,g.None,b.ConfigurationTarget.Global)}return t}static showLineUncommittedWarningMessage(e){return Os.showMessage("warn",`${e}. The line has uncommitted changes.`,Ns.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Os.showMessage("warn",`${e}. No repository could be found.`,Ns.NoRepositoryWarning)}static async showMessage(e,t,i,s={title:"Don't Show Again"},...o){if(Cr.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),vr.get(vr.name("advanced")("messages")(i).value))return void Cr.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let r=void 0;switch(e){case"info":r=await b.window.showInformationMessage(t,...o);break;case"warn":r=await b.window.showWarningMessage(t,...o);break;case"error":r=await b.window.showErrorMessage(t,...o)}return null!==s&&r!==s||(Cr.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`),await this.suppressedMessage(i),r!==s)?(Cr.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${r?r.title:r}`),r):void 0}static suppressedMessage(e){const t=vr.name("advanced")("messages").value,i=vr.get(t);i[e]=!0;for(const[e,t]of Object.entries(i))!0!==t&&(i[e]=void 0);return vr.update(t,i,b.ConfigurationTarget.Global)}}class Is extends $s{constructor(){super(gs.DiffLineWithPrevious)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Qt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await gr.git.getBlameForLineContents(s,t,e.document.getText()):await gr.git.getBlameForLine(s,t);if(void 0===o)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await gr.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Qt.stagedUncommittedSha}))}}catch(e){return Cr.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Qt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,o)}}class Ms extends $s{constructor(){super(gs.DiffLineWithWorking)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Qt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await gr.git.getBlameForLineContents(s,t,e.document.getText()):await gr.git.getBlameForLine(s,t);if(void 0===o)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await gr.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Qt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return Cr.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,o)}}class Ws extends $s{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ae){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Qt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(gs.DiffWith,i)}constructor(){super(gs.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Qt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await gr.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Qt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await gr.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[t,s]=await Promise.all([gr.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),gr.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===s?o=Qt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==t&&i.lhs.sha!==Qt.deletedSha||(o="added in ");let r="";if(void 0===t&&""===i.rhs.sha&&(void 0!==s?(r="not in ",o=""):r="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Qt.deletedSha&&(void 0!==t||""!==r)){const e=Qt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${$e.basename(i.lhs.uri.fsPath)}${""!==e?` (${r}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Qt.deletedSha){const e=Qt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${$e.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${G.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=b.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new b.Range(i.line,0,i.line,0)),await b.commands.executeCommand(M.Diff,void 0===t?Te.toRevisionUri(Qt.deletedSha,i.lhs.uri.fsPath,i.repoPath):b.Uri.file(t),void 0===s?Te.toRevisionUri(Qt.deletedSha,i.rhs.uri.fsPath,i.repoPath):b.Uri.file(s),a,i.showOptions)}catch(e){return Cr.error(e,"DiffWithCommand","getVersionedFile"),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Hs extends $s{constructor(){super(gs.DiffWithBranch)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t);if(!s.repoPath)return Os.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${$e.basename(s.fsPath)} with ${G.Ellipsis}`,r=ji.showProgress(o);try{const[e,t]=await Promise.all([gr.git.getBranches(s.repoPath),gr.git.getTags(s.repoPath)]);if(r.token.isCancellationRequested)return;const a=await ji.show(e,t,o,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===a)return;if(a instanceof Fi)return a.execute();const n=a.name;if(void 0===n)return;let h,c;const l=await gr.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=B.normalizePath($e.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=b.Uri.file($e.join(s.repoPath,t.originalFileName)),c=`${$e.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:a.remote?`remotes/${n}`:n,uri:h||s,title:c||`${$e.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,d)}finally{r.cancel()}}}class Gs extends $s{constructor(){super(gs.DiffWithNext)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof He)||void 0!==i.range)try{const r=void 0===i.commit?s.sha:i.commit.sha;if(Qt.isStagedUncommitted(r)){const e={repoPath:s.repoPath,lhs:{sha:r,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,e)}const a=await gr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==r?void 0:2,range:i.range,renames:!0});if(void 0===a)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=r&&a.commits.get(r)||F.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await gr.git.getStatusForFile(s.repoPath,s.fsPath)))return b.commands.executeCommand(gs.DiffWithWorking,t)}catch(e){return Cr.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await gr.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Qt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,e)}return b.commands.executeCommand(gs.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,r)}}class js extends $s{constructor(){super([gs.DiffWithPrevious,gs.DiffWithPreviousInDiff])}async preExecute(e,t={}){return e.command===gs.DiffWithPreviousInDiff&&(t.inDiffEditor=!0),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Te.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===Qt.deletedSha)return Os.showCommitHasNoPreviousCommitWarningMessage();let o=!1;Qt.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0),i.inDiffEditor&&void 0!==s&&(s+="^");const r=await gr.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===r)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&r.commits.get(s)||F.first(r.commits.values()),void 0===e.sha){const s=await gr.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.previousSha||Qt.deletedSha:i.commit.sha,uri:i.inDiffEditor?i.commit.previousUri:i.commit.uri},rhs:{sha:i.inDiffEditor?i.commit.sha:Qt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.sha:Qt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:i.inDiffEditor?Qt.stagedUncommittedSha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,e)}if(!i.inDiffEditor)return b.commands.executeCommand(gs.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return Cr.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Qt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,s)}}class Vs extends $s{constructor(){super(gs.DiffWithRevision)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const s=await Te.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${B.pad(G.Dot,1,1)} ${s.shortSha}`:""} with ${G.Ellipsis}`,r=as.showProgress(o);try{const a=await gr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===a)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Fi({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},gs.DiffWithRevision,[t,Object.assign({},i)]),s=F.last(a.commits.values());null!=s&&(n=new Fi({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},gs.DiffWithRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await as.show(a,s,o,{pickerOnly:!0,progressCancellation:r,currentCommand:new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},gs.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Fi({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},gs.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;let c;if(h instanceof Ui){const e=await h.execute();if(void 0===e)return;if(e instanceof Fi)return e.execute();c=e.name}else{if(h instanceof Fi)return h.execute();c=h.commit.sha}const l={repoPath:s.repoPath,lhs:{sha:c,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await b.commands.executeCommand(gs.DiffWith,l)}catch(e){return Cr.error(e,"DiffWithRevisionCommand"),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.cancel()}}}class Qs extends $s{constructor(){super(gs.DiffWithWorking)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Qt.isUncommitted(i.commit.sha)){if(void 0===s.sha)return b.window.showInformationMessage("File matches the working tree");if(Qt.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await gr.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:Qt.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,e)}}try{if(i.commit=await gr.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return Cr.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),b.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await gr.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return b.commands.executeCommand(gs.DiffWith,r)}}!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Ls||(Ls={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Us||(Us={}));class Ks{constructor(e,t){this.uri=e,this.staged=t}}class zs extends xs{constructor(){super(gs.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new Ks(e.resourceUri,e.resourceGroupType===Us.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=w.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new Ks(e.resourceUri,e.resourceGroupType===Us.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Ls.BOTH_MODIFIED||t===Ls.INDEX_MODIFIED||t===Ls.MODIFIED}async execute(e={}){try{const t=await fs(void 0,void 0,`Open changes from which repository${G.Ellipsis}`);if(!t)return;const i=await gr.git.getDiffTool(t);if(void 0===i){if(!await b.window.showWarningMessage("Unable to open changes in diff tool because there is no Git diff tool configured","View Git Docs"))return;return b.commands.executeCommand(M.Open,b.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await gr.git.getStatusForRepo(t);if(void 0===i)return b.window.showWarningMessage("Unable to open changes in diff tool");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new Ks(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new Ks(t.uri,!1))}for(const s of e.files)gr.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return Cr.error(e,"ExternalDiffCommand"),b.window.showErrorMessage("Unable to open changes in diff tool. See output channel for more details")}}}class qs extends $s{constructor(){super(gs.OpenBranchesInRemote)}async preExecute(e,t={}){return bs(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ps(t,e))&&await Te.fromUri(t),o=await fs(s,e,`Open branches in remote for which repository${G.Ellipsis}`);if(o)try{const s=await gr.git.getRemotes(o);return b.commands.executeCommand(gs.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:s})}catch(e){return Cr.error(e,"OpenBranchesInRemoteCommand"),b.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class Ys extends $s{constructor(){super(gs.OpenBranchInRemote)}async preExecute(e,t={}){return vs(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ps(t,e))&&await Te.fromUri(t),o=await fs(s,e,`Open branch in remote for which repository${G.Ellipsis}`);if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=(await gr.git.getBranches(o)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await Qi.show(e,`Open which branch in remote${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Fi)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}const s=await gr.git.getRemotes(o);return b.commands.executeCommand(gs.OpenInRemote,t,{resource:{type:"branch",branch:i.branch||"HEAD"},remote:i.remote,remotes:s})}catch(e){return Cr.error(e,"OpenBranchInRemoteCommandArgs"),b.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class Xs extends $s{constructor(){super(gs.OpenChangedFiles)}async execute(e,t,i={}){t=ps(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const s=await fs(t,e,`Open changed files in which repository${G.Ellipsis}`);if(!s)return;const o=await gr.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to open changed files");i.uris=w.filterMap(o.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await ks(e,{preserveFocus:!0,preview:!1});return}catch(e){return Cr.error(e,"OpenChangedFilesCommand"),b.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Zs extends $s{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(gs.OpenCommitInRemote,t)}constructor(){super(gs.OpenCommitInRemote)}async preExecute(e,t={}){return ws(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=null==e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await gr.git.getBlameForLineContents(s,t,e.document.getText()):await gr.git.getBlameForLine(s,t);if(void 0===o)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let r=o.commit;r.isUncommitted&&(r=r.with({sha:r.previousSha,fileName:r.previousFileName,previousSha:null,previousFileName:null})),i.sha=r.sha}const o=await gr.git.getRemotes(s.repoPath);return b.commands.executeCommand(gs.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return Cr.error(e,"OpenCommitInRemoteCommand"),b.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class Js extends $s{constructor(){super(gs.OpenFileInRemote)}async preExecute(e,t={range:!0}){return ws(e)?((t=Object.assign({},t)).range=!1,vs(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await gr.git.getBranch(s.repoPath);if(void 0===e||void 0===e.tracking){const e=(await gr.git.getBranches(s.repoPath)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await Qi.show(e,`Open ${s.getRelativePath()} in remote for which branch${G.Ellipsis}`);if(void 0===t)return;if(t instanceof Fi)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}else i.branch=e.name}try{const o=await gr.git.getRemotes(s.repoPath),r=i.range&&null!=e?new b.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return b.commands.executeCommand(gs.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch||"HEAD",fileName:s.getRelativePath(),range:r,sha:s.sha},remotes:o})}catch(e){return Cr.error(e,"OpenFileInRemoteCommand"),b.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class eo extends $s{static getMarkdownCommandArgs(e,t,i){let s;return s=e instanceof b.Uri?{uri:e,line:i,annotationType:t}:e,super.getMarkdownCommandArgsCore(gs.OpenFileRevision,s)}constructor(){super(gs.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=ps(t,e)))return;const o=await Te.fromUri(t),r=`Open ${o.getFormattedPath()}${o.sha?` ${B.pad(G.Dot,1,1)} ${o.shortSha}`:""} in revision ${G.Ellipsis}`;s=as.showProgress(r);const a=await gr.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===a)return Os.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(a.truncated){const e=new Fi({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} newer commits`},gs.OpenFileRevision,[t,Object.assign({},i)]),s=F.last(a.commits.values());null!=s&&(n=new Fi({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${a.maxCount} older commits`},gs.OpenFileRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await as.show(a,o,r,{pickerOnly:!0,progressCancellation:s,currentCommand:new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${G.Space}$(git-commit) ${o.shortSha}`:""}`},gs.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==a&&a.truncated?new Fi({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},gs.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof Ui){const e=await h.execute();if(void 0===e)return;if(e instanceof Fi)return e.execute();i.uri=Te.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Fi)return h.execute();i.uri=Te.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new b.Range(i.line,0,i.line,0));const o=await ks(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:gr.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return Cr.error(e,"OpenFileRevisionCommand"),b.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.cancel()}}}class to extends $s{constructor(){super(gs.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length){this.ensureRemoteBranchName(i);const e=new Ki(i.remotes[0],i.resource);return await e.execute()}let t="";switch(i.resource.type){case te.Branch:this.ensureRemoteBranchName(i),t=`open ${i.resource.branch} branch in${G.Ellipsis}`;break;case te.Commit:t=`open commit ${Qt.shortenSha(i.resource.sha)} in${G.Ellipsis}`;break;case te.File:t=`open ${i.resource.fileName} in${G.Ellipsis}`;break;case te.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof He)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,t=`open ${i.resource.fileName} ${B.pad(G.Dot,1,1)} ${i.resource.commit.previousShortSha} in${G.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,t=`open ${i.resource.fileName} ${B.pad(G.Dot,1,1)} ${i.resource.commit.shortSha} in${G.Ellipsis}`);else{const e=void 0===i.resource.sha?"":Qt.shortenSha(i.resource.sha),s=e?` ${B.pad(G.Dot,1,1)} ${e}`:"";t=`open ${i.resource.fileName}${s} in${G.Ellipsis}`}}if(1===i.remotes.length){const e=new Ki(i.remotes[0],i.resource);return await e.execute()}const s=await qi.show(i.remotes,t,i.resource,i.goBackCommand);if(void 0===s)return;return await s.execute()}catch(e){return Cr.error(e,"OpenInRemoteCommand"),b.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class io extends $s{constructor(){super(gs.OpenRepoInRemote)}async preExecute(e,t={}){return bs(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=ps(t,e))&&await Te.fromUri(t),o=await fs(s,e,`Open which repository in remote${G.Ellipsis}`);if(o)try{const s=await gr.git.getRemotes(o);return b.commands.executeCommand(gs.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:s})}catch(e){return Cr.error(e,"OpenRepoInRemoteCommand"),b.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class so extends $s{constructor(){super(gs.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=ps(t,e)))return;if(i.uri=await Te.fromUri(t),i.uri instanceof Te&&i.uri.sha){const[e,t]=await gr.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Te(b.Uri.file($e.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new b.Range(i.line,0,i.line,0));const s=await ks(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:gr.fileAnnotations.show(s,i.annotationType,i.line)}catch(e){return Cr.error(e,"OpenWorkingFileCommand"),b.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class oo extends xs{constructor(){super(gs.ResetSuppressedWarnings)}async execute(){await vr.update(vr.name("advanced")("messages").value,void 0,b.ConfigurationTarget.Global)}}const ro=/^([@~=:#])/,ao=new Map([["@",Ht.Author],["~",Ht.Changes],["=",Ht.ChangedOccurrences],[":",Ht.Files],["#",Ht.Sha]]);class no extends _s{constructor(){super(gs.ShowCommitSearch)}async execute(e,t,i={}){const s=(t=ps(t,e))&&await Te.fromUri(t),o=await fs(s,e,`Search for commits in which repository${G.Ellipsis}`,i.goBackCommand);if(!o)return;i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&null!=e&&null!=s){const t=await gr.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){Cr.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await b.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=ro.exec(i.search);t&&t[1]?(i.searchBy=ao.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Qt.isSha(i.search)?i.searchBy=Ht.Sha:i.searchBy=Ht.Message}void 0===i.searchBy&&(i.searchBy=Ht.Message);let a=void 0;switch(i.searchBy){case Ht.Author:a=`commits with an author matching '${i.search}'`;break;case Ht.Changes:a=`commits with changes matching '${i.search}'`;break;case Ht.ChangedOccurrences:a=`commits with changed occurrences matching '${i.search}'`;break;case Ht.Files:a=`commits with files matching '${i.search}'`;break;case Ht.Message:a=`commits with a message matching '${i.search}'`;break;case Ht.Sha:a=`commits with an id matching '${i.search}'`}const n=rs.showProgress(a);try{const s=await gr.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const h=i.goBackCommand||new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to commit search`},gs.ShowCommitSearch,[t,r]),c=await rs.show(s,a,n,{goBackCommand:h,showAllCommand:void 0!==s&&s.truncated?new Fi({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},gs.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:h})]):void 0,showInResultsExplorerCommand:void 0!==s?new Li(s,a):void 0});if(void 0===c)return;return c instanceof Fi?c.execute():b.commands.executeCommand(gs.ShowQuickCommitDetails,c.commit.toGitUri(),{sha:c.commit.sha,commit:c.commit,goBackCommand:new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,2)} to search for ${a}`},gs.ShowCommitSearch,[t,i])})}catch(e){return Cr.error(e,"ShowCommitSearchCommand"),b.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.cancel()}}}class ho extends xs{constructor(){super(gs.ShowGitExplorer)}execute(){return gr.gitExplorer.show(d.Repository)}}class co extends xs{constructor(){super(gs.ShowHistoryExplorer)}execute(){return gr.config.historyExplorer.enabled?gr.historyExplorer.show():gr.gitExplorer.show(d.History)}}class lo extends xs{constructor(){super(gs.ShowLastQuickPick)}async execute(){const e=Ss;if(void 0!==e)try{return b.commands.executeCommand(e.command,...e.args)}catch(e){return Cr.error(e,"ShowLastQuickPickCommand"),b.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class uo extends _s{constructor(){super(gs.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=ps(t,e))&&await Te.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:Yi.showProgress(i.branch);try{const r=i.repoPath||await fs(s,e,`Show branch history in which repository${G.Ellipsis}`);if(!r)return;if(void 0===i.branch){const s=await gr.git.getBranches(r);let a;await gr.git.getRepoPathOrActive(t,e)||(a=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to which repository`},gs.ShowQuickBranchHistory,[t,i]));const n=await Qi.show(s,`Show history for branch${G.Ellipsis}`,{goBackCommand:a});if(void 0===n)return;if(n instanceof Fi)return n.execute();if(i.branch=n.branch.name,void 0===i.branch)return;o=Yi.showProgress(i.branch)}if(void 0===i.log&&(i.log=await gr.git.getLog(r,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return b.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await Yi.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof Fi)return a.execute();const n=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${G.Space}$(git-branch) ${i.branch} history`},gs.ShowQuickBranchHistory,[t,Object.assign({},i)]);return b.commands.executeCommand(gs.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:n})}catch(e){return Cr.error(e,"ShowQuickBranchHistoryCommand"),b.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.cancel()}}}class mo extends _s{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(gs.ShowQuickCommitDetails,t)}constructor(){super(gs.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,ws(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;const s=await Te.fromUri(t);let o=s.repoPath,r=$e.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const a=await gr.git.getBlameForLine(s,t);if(void 0===a)return Os.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(a.commit.isUncommitted)return Os.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=a.commit.sha,o=a.commit.repoPath,r=a.commit.fileName,i.commit=a.commit}catch(e){return Cr.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await gr.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Os.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Os.showCommitNotFoundWarningMessage("Unable to show commit details");if(void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand){const e=await gr.git.getBranch(i.commit.repoPath);void 0!==e&&(i.goBackCommand=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to ${e.name} history`},gs.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]))}const s=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${i.commit.shortSha}`},gs.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),a=await os.show(i.commit,t,i.goBackCommand,s,i.repoLog);if(void 0===a)return;return a instanceof ts?b.commands.executeCommand(gs.ShowQuickCommitFileDetails,a.commit.toGitUri(),{commit:a.commit,sha:a.sha,goBackCommand:s}):a.execute()}catch(e){return Cr.error(e,"ShowQuickCommitDetailsCommand"),b.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class go extends _s{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(gs.ShowQuickCommitFileDetails,t)}constructor(){super(gs.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,ws(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const r=await gr.git.getBlameForLine(o,t);if(void 0===r)return Os.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(r.commit.isUncommitted)return Os.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=r.commit.sha,i.commit=r.commit,s=$e.relative(i.commit.repoPath,o.fsPath)}catch(e){return Cr.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),b.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await gr.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Os.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Os.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await gr.git.findWorkingFileName(i.commit);const r=Qt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(git-commit) ${r}`},gs.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to details of ${G.Space}$(file-text) ${$e.basename(i.commit.fileName)} in ${G.Space}$(git-commit) ${r}`},gs.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await es.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===n)return;return n instanceof Fi?n.execute():void 0}catch(e){return Cr.error(e,"ShowQuickCommitFileDetailsCommand"),b.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class po extends _s{constructor(){super(gs.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=ps(t,e);try{const s=await fs(t,e,`Show current branch history for which repository${G.Ellipsis}`);if(!s)return;const o=await gr.git.getBranch(s);if(void 0===o)return;return b.commands.executeCommand(gs.ShowQuickBranchHistory,t,{branch:o.name,repoPath:s,goBackCommand:i.goBackCommand})}catch(e){return Cr.error(e,"ShowQuickCurrentBranchHistoryCommand"),b.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class fo extends _s{constructor(){super(gs.ShowQuickFileHistory)}async execute(e,t,i={}){if(null==(t=ps(t,e)))return b.commands.executeCommand(gs.ShowQuickCurrentBranchHistory);const s=await Te.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${B.pad(G.Dot,1,1)} ${s.shortSha}`:""}`,r=as.showProgress(o);try{if(void 0===i.log&&(i.log=await gr.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Os.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let a=void 0;if(i.log.truncated){const e=new Fi({label:"$(arrow-right) Show Next Commits",description:`${B.pad(G.Dash,2,3)} shows ${i.log.maxCount} newer commits`},gs.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),o=F.last(i.log.commits.values());null!=o&&(a=new Fi({label:"$(arrow-left) Show Previous Commits",description:`${B.pad(G.Dash,2,3)} shows ${i.log.maxCount} older commits`},gs.ShowQuickFileHistory,[new Te(t,o),Object.assign({},i,{log:void 0,nextPageCommand:e})]))}const n=await as.show(i.log,s,o,{progressCancellation:r,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:a,showAllCommand:void 0!==i.log&&i.log.truncated?new Fi({label:"$(sync) Show All Commits",description:`${B.pad(G.Dash,2,3)} this may take a while`},gs.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Ni(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===n)return;if(n instanceof Fi)return n.execute();const h=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to history of ${G.Space}$(file-text) ${$e.basename(n.commit.fileName)}${s.sha?` from ${G.Space}$(git-commit) ${s.shortSha}`:""}`},gs.ShowQuickFileHistory,[t,i]);return b.commands.executeCommand(gs.ShowQuickCommitFileDetails,n.commit.toGitUri(),{commit:n.commit,fileLog:i.log,sha:n.commit.sha,goBackCommand:h})}catch(e){return Cr.error(e,"ShowQuickFileHistoryCommand"),b.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.cancel()}}}class vo extends _s{constructor(){super(gs.ShowQuickRepoStatus)}async execute(e,t,i={}){t=ps(t,e);try{const s=await fs(t,e,`Show status for which repository${G.Ellipsis}`);if(!s)return;const o=await gr.git.getStatusForRepo(s);if(void 0===o)return b.window.showWarningMessage("Unable to show repository status");const r=await us.show(o,i.goBackCommand);if(void 0===r)return;return r instanceof Fi?r.execute():void 0}catch(e){return Cr.error(e,"ShowQuickRepoStatusCommand"),b.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class wo extends _s{constructor(){super(gs.ShowQuickStashList)}async execute(e,t,i={}){t=ps(t,e);const s=ms.showProgress("list");try{const o=await fs(t,e,`Show stashed changes for which repository${G.Ellipsis}`);if(!o)return;const r=await gr.git.getStashList(o);if(void 0===r)return b.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to stashed changes`},gs.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),n=await ms.show(r,"list",s,i.goBackCommand,a);if(void 0===n)return;return n instanceof Fi?n.execute():b.commands.executeCommand(gs.ShowQuickCommitDetails,n.commit.toGitUri(),{commit:n.commit,sha:n.commit.sha,goBackCommand:a})}catch(e){return Cr.error(e,"ShowQuickStashListCommand"),b.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.cancel()}}}class bo extends xs{constructor(){super(gs.ShowResultsExplorer)}execute(){return gr.resultsExplorer.show()}}class Co extends xs{constructor(){super(gs.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return ws(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await gr.git.getActiveRepoPath();if(!i){const s=await cs.show(`Apply stashed changes from which repository${G.Ellipsis}`,e.goBackCommand);if(s instanceof Fi)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to pick another repository`},gs.StashApply,[e]),i=s.repoPath}const s=ms.showProgress("apply");try{const o=await gr.git.getStashList(i);if(void 0===o)return b.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const r=new Fi({label:`go back ${G.ArrowBack}`,description:`${B.pad(G.Dash,2,3)} to apply stashed changes`},gs.StashApply,[e]),a=await ms.show(o,"apply",s,t||e.goBackCommand,r);if(a instanceof Fi)return a.execute();if(void 0===a)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=a.commit}finally{s.cancel()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await b.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await gr.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return Cr.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?b.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?b.window.showInformationMessage("Stash applied with conflicts"):b.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class yo extends xs{constructor(){super(gs.StashDelete)}async preExecute(e,t={confirm:!0}){return ws(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${G.Ellipsis}`:e.stashItem.message,i=await b.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await gr.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return Cr.error(e,"StashDeleteCommand"),b.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class xo extends xs{constructor(){super(gs.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await gr.git.getHighlanderRepoPath();if(!t){const i=await cs.show(`Stash changes for which repository${G.Ellipsis}`,e.goBackCommand);if(i instanceof Fi)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await b.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await gr.git.stashSave(t,e.message,e.uris)}catch(e){Cr.error(e,"StashSaveCommand");const t=e&&e.message;return t.includes("newer version of Git")?b.window.showErrorMessage(`Unable to save stash. ${t}`):b.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class $o extends xs{constructor(){super(gs.SwitchMode)}async execute(){const e=await ns.show();void 0!==e&&await vr.update(vr.name("mode")("active").value,e.key,b.ConfigurationTarget.Global)}}class So extends xs{constructor(){super(gs.ToggleReviewMode)}async execute(){if(!Object.keys(gr.config.modes).includes("review"))return;const e="review"===gr.config.mode.active?void 0:"review";await vr.update(vr.name("mode")("active").value,e,b.ConfigurationTarget.Global)}}class _o extends xs{constructor(){super(gs.ToggleZenMode)}async execute(){if(!Object.keys(gr.config.modes).includes("zen"))return;const e="zen"===gr.config.mode.active?void 0:"zen";await vr.update(vr.name("mode")("active").value,e,b.ConfigurationTarget.Global)}}class Do extends xs{constructor(){super(gs.ToggleCodeLens)}execute(){return gr.codeLens.toggleCodeLens()}}class ko extends $s{constructor(){super(gs.ToggleFileBlame)}async execute(e,t,i={}){if(null!=e&&null!=t&&!J.equals(t,e.document.uri)){const i=b.window.visibleTextEditors.find(e=>J.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:l.Blame})),gr.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return Cr.error(e,"ToggleFileBlameCommand"),b.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Fo extends $s{constructor(){super(gs.ToggleFileHeatmap)}async execute(e,t){b.commands.executeCommand(gs.ToggleFileBlame,t,{type:l.Heatmap})}}class Po extends $s{constructor(){super(gs.ToggleFileRecentChanges)}async execute(e,t){b.commands.executeCommand(gs.ToggleFileBlame,t,{type:l.RecentChanges})}}class To extends $s{constructor(){super(gs.ToggleLineBlame)}async execute(e,t){try{return gr.lineAnnotations.toggle(e)}catch(e){return Cr.error(e,"ToggleLineBlameCommand"),b.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const Ro=/^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d\.]+%?)?\))$/i;function Eo(e){e=e.trim();const t=Ro.exec(e);if(null==t)return null;if("#"===t[1]){const e=t[2];switch(e.length){case 3:return[parseInt(e[0]+e[0],16),parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),1];case 6:return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16),1]}return null}switch(t[3]){case"rgb":return[parseInt(t[4],10),parseInt(t[5],10),parseInt(t[6],10),1];case"rgba":return[parseInt(t[4],10),parseInt(t[5],10),parseInt(t[6],10),parseFloat(t[7])];default:return null}}const Bo="#f66a0a",Ao="#0a60f6",No=/[`\>\#\*\_\-\+\.]/g;let Lo;class Uo{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(t,i);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=t.cold?t.colors.cold:t.colors.hot,s=t.computeAge(e);if(0===s)return i;if(void 0===Lo||Lo.color!==i){let e=Eo(i);null==e&&(e=Eo(t.cold?Ao:Bo));const[s,o,r]=e;Lo={color:i,rgb:`${s}, ${o}, ${r}`}}return`rgba(${Lo.rgb}, ${(1-s/10).toFixed(2)})`}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${G.MuchGreaterThan}\`](${Ws.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===l.RecentChanges&&(i=l.Blame);const t=Te.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${G.SquareWithTopShadow}\`](${eo.getMarkdownCommandArgs(t,i||l.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${G.ArrowUpRight}\`](${Zs.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+`[\`${G.MiddleEllipsis}\`](${go.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s,o=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",a="",n="";if(e.isUncommitted)n=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{a=`\n\n${this.getHoverCommandBar(e,0!==i.length,s,o)}`,n=`[\`${e.shortSha}\`](${mo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=e.message;for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(No,"\\$&").replace(/^===/gm,`${G.ZeroWidthSpace}===`).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}const h=new b.MarkdownString(`${n} &nbsp; ![](${e.getGravatarUri(gr.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${a}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&Qt.isStagedUncommitted(t.sha)?`[\`Changes\`](${Ws.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${mo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} _${t.shortSha}_\n${s}`:`[\`Changes\`](${Ws.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; _uncommitted changes_\n${s}`:`[\`Changes\`](${Ws.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${G.Dash} &nbsp; [\`${e.previousShortSha}\`](${mo.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${G.ArrowLeftRightLong} [\`${e.shortSha}\`](${mo.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const r=new b.MarkdownString(o);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Qt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await gr.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const r=It.fromTemplate(t,e,i);return o.renderOptions.before.contentText=B.pad(r.replace(/ /g,G.Space),1,1),o}static gutterRenderOptions(e,t,i,s){let o=0;for(const e of v.values(s.tokenOptions))if(void 0!==e){if(null==e.truncateTo){o=-1;break}o+=e.truncateTo}o>=0&&(o+=B.width(B.interpolate(i,void 0)))>0&&(o+=3);let r=void 0,a=void 0;return t.enabled&&(r="solid",a="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new b.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:r,borderWidth:a,color:new b.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:o>=0?`${o}ch`:void 0,uncommittedColor:new b.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return Uo.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:G.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,s=!0){const o=It.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new b.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new b.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:B.pad(o.replace(/ /g,G.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${s?"":" position: absolute;"}`}}}}}class Oo extends ie{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?gr.git.getBlameForFileContents(this._uri,e.document.getText()):gr.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?gr.git.getBlameForFileContents(this._uri,this.editor.document.getText()):gr.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=F.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=w.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new b.Range(e.line,0,e.line,Number.MAX_SAFE_INTEGER)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}getComputedHeatmap(e){const t=[];let i,s;for(const o of e.lines)s!==o.sha&&(s=o.sha,void 0!==(i=e.commits.get(o.sha))&&t.push(i.date));t.sort((e,t)=>e.getTime()-t.getTime());const o=Math.floor(t.length/2),r=t.length%2?t[o].getTime():(t[o-1].getTime()+t[o].getTime())/2,a=[],n=t[t.length-1].getTime();let h=(n-r)/5;for(let e=5;e>0;e--)a.push(r+h*e);a.push(r);const c=t[0].getTime();h=(r-c)/4;for(let e=1;e<=4;e++)a.push(r-h*e);const l=new Date;return l.setDate(l.getDate()-(gr.config.heatmap.ageThreshold||90)),{cold:n<l.getTime(),colors:{cold:gr.config.heatmap.coldColor,hot:gr.config.heatmap.hotColor},median:r,newest:n,oldest:c,computeAge:e=>{const t=e.getTime();let i=0;for(let e=0;e<a.length&&(i=e,!(t>=a[e]));e++);return i}}}registerHoverProviders(e){if(!gr.config.hovers.enabled||!gr.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(b.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(b.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=b.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await gr.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const r=Uo.getHoverMessage(o||s,gr.config.defaultDateFormat,await gr.git.getRemotes(s.repoPath),this.annotationType,this.editor.selection.active.line);return new b.Hover(r,e.validateRange(new b.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await Uo.changesHover(s,t.line,await Te.fromUri(e.uri));return void 0!==o.hoverMessage?new b.Hover(o.hoverMessage,e.validateRange(new b.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER))):void 0}async getCommitForHover(e){if("line"!==gr.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class Io extends Oo{async onProvideAnnotation(e,t){this.annotationType=l.Blame;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=gr.config.blame,r=B.getTokensFromTemplate(o.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),a={dateFormat:null===o.dateFormat?gr.config.defaultDateFormat:o.dateFormat,tokenOptions:r},n=o.avatars,h=gr.config.defaultGravatarsStyle,c=o.separateLines,d=Uo.gutterRenderOptions(c,o.heatmap,o.format,a);this.decorations=[];const u=Object.create(null),m=n?Object.create(null):void 0;let g,p,f,w,C=!1;o.heatmap.enabled&&(w=this.getComputedHeatmap(i));for(const e of i.lines){const t=e.line;f!==e.sha?(C=!1,f=e.sha,void 0!==(g=i.commits.get(e.sha))&&(void 0===(p=u[e.sha])?(p=Uo.gutter(g,o.format,a,d),void 0!==w&&Uo.applyHeatmap(p,g.date,w),p.range=new b.Range(t,0,t,0),this.decorations.push(p),n&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,p.range,h,m),u[e.sha]=p):(p=Object.assign({},p,{range:new b.Range(t,0,t,0)}),this.decorations.push(p),n&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,p.range,h,m)))):(p=Object.assign({},p),o.compact&&!C&&(p.renderOptions={before:Object.assign({},p.renderOptions.before,{contentText:G.Space.repeat(B.width(p.renderOptions.before.contentText))})},c&&(p.renderOptions.before.textDecoration="none"),C=!0),p.range=new b.Range(t,0,t,0),this.decorations.push(p),n&&!o.compact&&void 0!==g&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,p.range,h,m))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),n)){this.additionalDecorations=[];for(const e of v.values(m))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const y=process.hrtime(s);return Cr.log(`${1e3*y[0]+Math.floor(y[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(gr.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:b.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class Mo extends Oo{async onProvideAnnotation(e,t){this.annotationType=l.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Uo.heatmapRenderOptions();this.decorations=[];const r=Object.create(null);let a,n;const h=this.getComputedHeatmap(i);for(const e of i.lines){const t=e.line;void 0===(n=r[e.sha])?void 0!==(a=i.commits.get(e.sha))&&((n=Uo.heatmap(a,h,o)).range=new b.Range(t,0,t,0),this.decorations.push(n),r[e.sha]=n):(n=Object.assign({},n,{range:new b.Range(t,0,t,0)}),this.decorations.push(n))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return Cr.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(gr.config.hovers.annotations),this.selection(e,i),!0}}class Wo extends ie{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=l.RecentChanges;const t=await gr.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await gr.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=gr.config,r=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new b.Range(new b.Position(i,0),new b.Position(i,Number.MAX_SAFE_INTEGER)));let a=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:Uo.getHoverMessage(t,r,await gr.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),o.hovers.annotations.changes&&void 0===(a=Uo.getHoverDiffMessage(t,this._uri,s)))||this.decorations.push({hoverMessage:a,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const a=process.hrtime(s);return Cr.log(`${1e3*a[0]+Math.floor(a[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var Ho;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(Ho||(Ho={}));const Go={blameAnnotation:b.window.createTextEditorDecorationType({rangeBehavior:b.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:b.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class jo extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new b.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),Go.blameAnnotation&&Go.blameAnnotation.dispose(),Go.blameHighlight&&Go.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=vr.initializing(e),i=gr.config;if(t||vr.changed(e,vr.name("blame")("highlight").value)){Go.blameHighlight&&Go.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?Go.blameHighlight=b.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:b.OverviewRulerLane.Right,backgroundColor:e.locations.includes(m.Line)?new b.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(m.Overview)?new b.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(m.Gutter)?gr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(m.Gutter)?gr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):Go.blameHighlight=void 0}if(t||vr.changed(e,vr.name("recentChanges")("highlight").value)){Go.recentChangesAnnotation&&Go.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;Go.recentChangesAnnotation=b.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:b.OverviewRulerLane.Right,backgroundColor:e.locations.includes(m.Line)?new b.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(m.Overview)?new b.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(m.Gutter)?gr.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(m.Gutter)?gr.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||vr.changed(e,vr.name("blame")("toggleMode").value))&&(this._toggleModes.set(l.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==s.File||this.clearAll()),(t||vr.changed(e,vr.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(l.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==s.File||this.clearAll()),(t||vr.changed(e,vr.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(l.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==s.File||this.clearAll()),!t&&(vr.changed(e,vr.name("blame").value)||vr.changed(e,vr.name("recentChanges").value)||vr.changed(e,vr.name("heatmap").value)||vr.changed(e,vr.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===l.RecentChanges?e.reset({decoration:Go.recentChangesAnnotation,highlightDecoration:Go.recentChangesHighlight}):e.annotationType===l.Blame?e.reset({decoration:Go.blameAnnotation,highlightDecoration:Go.blameHighlight}):this.show(e.editor,l.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!K(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(V(W.AnnotationStatus,void 0),this.detachKeyboardHook()):(V(W.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=b.window.activeTextEditor;void 0!==t&&this.clear(t,Ho.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,Ho.DocumentChanged)}onTextDocumentClosed(e){if(gr.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,Ho.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=F.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,Ho.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===s.Window}getToggleMode(e){return void 0===e?s.File:this._toggleModes.get(e)||s.File}clear(e,t=Ho.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(ie.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,Ho.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await gr.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(ie.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===s.Window){let i=void 0===this._annotationType;const s=!i&&this._annotationType!==t;if(this._annotationType=t,s&&(await this.clearAll(),i=!0),i)for(const i of b.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await gr.tracker.getOrAdd(e.document)).isBlameable)return!1;const o=this.getProvider(e);return void 0!==o&&o.annotationType===t?(await o.selection(i),!0):void 0!==await b.window.withProgress({location:b.ProgressLocation.Window},async s=>{await V(W.AnnotationStatus,ee.Computing);const r=this.showAnnotationsCore(o,e,t,i,s),a=await r;return e===this._editor&&await V(W.AnnotationStatus,a&&a.status),r})}async toggle(e,t,i){if(void 0!==e){const i=await gr.tracker.getOrAdd(e.document);if(t===l.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,Ho.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await gr.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,Ho.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(Cr.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==ie.getCorrelationKey(this._editor)||(await V(W.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(Cr.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case l.Blame:e="blame annotations";break;case l.Heatmap:e="heatmap annotations";break;case l.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${$e.basename(t.document.fileName)}`})}this.attachKeyboardHook();const r=await gr.tracker.getOrAdd(t.document);let a=void 0;switch(i){case l.Blame:a=new Io(t,r,Go.blameAnnotation,Go.blameHighlight);break;case l.Heatmap:a=new Mo(t,r,Go.heatmapAnnotation,Go.heatmapHighlight);break;case l.RecentChanges:a=new Wo(t,r,Go.recentChangesAnnotation,Go.recentChangesHighlight)}if(void 0!==a&&await a.validate())return void 0!==e&&await this.clearCore(e.correlationKey,Ho.User),this._annotationsDisposable||0!==this._annotationProviders.size||(Cr.log("Add listener registrations for annotations"),this._annotationsDisposable=b.Disposable.from(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,50),this),b.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleTextEditorsChanged,50),this),b.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),gr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),gr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(a.correlationKey,a),await a.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),a):void 0}}class Vo extends b.CodeLens{constructor(e,t,i,s,o,r,a,n){super(r,n),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame&&this.blame()}}class Qo extends b.CodeLens{constructor(e,t,i,s,o,r,a){super(r),this.symbol=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=a}getBlame(){return this.blame()}}class Ko{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new b.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=gr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=vr.get(vr.name("codeLens").value,e.uri);let a=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==a&&(a={language:void 0}),null==a.scopes&&(a.scopes=o.scopes),null==a.symbolScopes&&(a.symbolScopes=o.symbolScopes),a.symbolScopes=null!=a.symbolScopes?a.symbolScopes=a.symbolScopes.map(e=>e.toLowerCase()):[];const n=[],h=i.uri;let c,l;if(s)1===a.scopes.length&&a.scopes.includes(r.Document)||(l=await b.commands.executeCommand(M.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return n;if(1===a.scopes.length&&a.scopes.includes(r.Document)?c=e.isDirty?await this._git.getBlameForFileContents(h,e.getText()):await this._git.getBlameForFile(h):[c,l]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(h,e.getText()):this._git.getBlameForFile(h),b.commands.executeCommand(M.ExecuteDocumentSymbolProvider,e.uri)]),void 0===c||0===c.lines.length)return n}if(t.isCancellationRequested)return n;const d=k.once(()=>e.validateRange(new b.Range(0,1e6,1e6,1e6))),u=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==l&&(Cr.log("GitCodeLensProvider.provideCodeLenses:",`${l.length} symbol(s) found`),l.forEach(t=>this.provideCodeLens(n,e,t,a,d,c,h,o,s,u))),(a.scopes.includes(r.Document)||a.symbolScopes.includes("file"))&&!a.symbolScopes.includes("!file")&&!n.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=d();let t=void 0;if(s||o.recentChange.enabled){s||(t=k.once(()=>this._git.getBlameForRangeSync(c,h,e)));const i=new b.SymbolInformation(h.getFilename(),b.SymbolKind.File,"",new b.Location(h.fileUri(),new b.Range(0,0,0,e.start.character)));n.push(new Vo(i,h,t,e,!0,zo(i),o.recentChange.command,u))}if(!s&&o.authors.enabled){void 0===t&&(t=k.once(()=>this._git.getBlameForRangeSync(c,h,e)));const i=new b.SymbolInformation(h.getFilename(),b.SymbolKind.File,"",new b.Location(h.fileUri(),new b.Range(0,1,0,e.start.character)));n.push(new Qo(i,h,t,e,!0,zo(i),o.authors.command))}}return n}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const a=b.SymbolKind[e.kind].toLowerCase();switch(e.kind){case b.SymbolKind.File:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&(s=i());break;case b.SymbolKind.Package:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&0===zo(e).start.line&&0===zo(e).end.line&&(s=i());break;case b.SymbolKind.Class:case b.SymbolKind.Interface:case b.SymbolKind.Module:case b.SymbolKind.Namespace:case b.SymbolKind.Struct:(t.scopes.includes(r.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;case b.SymbolKind.Constructor:case b.SymbolKind.Enum:case b.SymbolKind.Function:case b.SymbolKind.Method:(t.scopes.includes(r.Blocks)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;default:t.symbolScopes.includes(a)&&(o=!t.symbolScopes.includes(`!${a}`))}return o?s||zo(e):void 0}provideCodeLens(e,t,i,s,o,r,a,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(zo(i).start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let u,m=0;if((h||n.recentChange.enabled)&&(h||(u=k.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Vo(i,a,u,l,!1,d.range.with(new b.Position(d.range.start.line,m)),n.recentChange.command,c)),m++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case b.SymbolKind.File:break;case b.SymbolKind.Package:case b.SymbolKind.Module:case b.SymbolKind.Namespace:case b.SymbolKind.Class:case b.SymbolKind.Interface:case b.SymbolKind.Constructor:case b.SymbolKind.Method:case b.SymbolKind.Function:case b.SymbolKind.Enum:s=!0}s&&!h&&(void 0===u&&(u=k.once(()=>this._git.getBlameForRangeSync(r,a,l))),e.push(new Qo(i,a,u,l,!1,d.range.with(new b.Position(d.range.start.line,m)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof Vo?this.resolveGitRecentChangeCodeLens(e,t):e instanceof Qo?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=F.first(i.commits.values());let r=`${s.author}, ${s.formattedDate}`;switch(gr.config.debug&&(r+=` [${b.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case o.DiffWithPrevious:return this.applyDiffWithPreviousCommand(r,e,i,s);case o.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(r,e,i,s);case o.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(r,e,i,s);case o.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(r,e,i,s);case o.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(r,e,i,s);case o.ToggleFileBlame:return this.applyToggleFileBlameCommand(r,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let r=`${s} ${s>1?"authors":"author"} (${F.first(i.authors.values()).name}${s>1?" and others":""})`;switch(gr.config.debug&&(r+=` [${b.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${F.join(F.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case o.DiffWithPrevious:return this.applyDiffWithPreviousCommand(r,e,i);case o.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(r,e,i);case o.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(r,e,i);case o.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(r,e,i);case o.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(r,e,i);case o.ToggleFileBlame:return this.applyToggleFileBlameCommand(r,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:gs.DiffWithPrevious,arguments:[b.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":o.ShowQuickCommitDetails,arguments:[b.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":o.ShowQuickCommitFileDetails,arguments:[b.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:o.ShowQuickCurrentBranchHistory,arguments:[b.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:o.ShowQuickFileHistory,arguments:[b.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:gs.ToggleFileBlame,arguments:[b.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?gr.config.strings.codeLens.unsavedChanges.recentChangeAndAuthors:e.recentChange.enabled?gr.config.strings.codeLens.unsavedChanges.recentChangeOnly:gr.config.strings.codeLens.unsavedChanges.authorsOnly}}function zo(e){return e.location&&e.location.range||e.range}Ko.selector=[{scheme:H.File},{scheme:H.Git},{scheme:H.GitLensGit}];class qo extends b.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=vr.initializing(e),i=vr.name("codeLens").value;if(t||vr.changed(e,i,null)||vr.changed(e,vr.name("defaultDateStyle").value)||vr.changed(e,vr.name("defaultDateFormat").value)){t||Cr.log("CodeLens config changed; resetting CodeLens provider");const e=gr.config.codeLens;e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,V(W.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(Cr.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=gr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||(Cr.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(Cr.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new Ko(gr.context,gr.git,gr.tracker),this._providerDisposable=b.Disposable.from(b.languages.registerCodeLensProvider(Ko.selector,this._provider),gr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),gr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}const Yo=b.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:b.DecorationRangeBehavior.ClosedOpen});class Xo extends b.Disposable{constructor(){super(()=>this.dispose()),this._enabled=!1,this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this),gr.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),b.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),gr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=vr.initializing(e);(t||vr.changed(e,vr.name("currentLine").value))&&((t||vr.changed(e,vr.name("currentLine")("enabled").value))&&(gr.config.currentLine.enabled?(this._enabled=!0,this.resume()):(this._enabled=!1,this.setLineTracker(!1))),this.refresh(b.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(this.setLineTracker(!0),e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return this.setLineTracker(!1),"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=b.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(b.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(b.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(b.window.activeTextEditor)}async clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Yo,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=gr.lineTracker.lines;if(void 0===e||void 0===t||!K(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=gr.config.currentLine;if(this.suspended)return this.clear(e);if(!(await gr.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!gr.lineTracker.includesAll(t))return;const s=gr.config.currentLine.scrollable,o=[];for(const r of t){const t=gr.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const a=Uo.trailing(t.commit,i.format,null===i.dateFormat?gr.config.defaultDateFormat:i.dateFormat,s);a.range=e.document.validateRange(new b.Range(r,Number.MAX_SAFE_INTEGER,r,Number.MAX_SAFE_INTEGER)),o.push(a)}e.setDecorations(Yo,o)}setLineTracker(e){e?gr.lineTracker.isSubscribed(this)||gr.lineTracker.start(this,b.Disposable.from(gr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))):gr.lineTracker.stop(this)}}class Zo extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this),b.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),gr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){(vr.initializing(e)||vr.changed(e,vr.name("hovers")("enabled").value)||vr.changed(e,vr.name("hovers")("currentLine")("enabled").value))&&(gr.config.hovers.enabled&&gr.config.hovers.currentLine.enabled?(gr.lineTracker.start(this,b.Disposable.from(gr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(b.window.activeTextEditor)):(gr.lineTracker.stop(this),this.unregister()))}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=b.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!gr.lineTracker.includes(t.line))return;const s=gr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;const r=await gr.fileAnnotations.getAnnotationType(b.window.activeTextEditor);if(void 0!==r&&gr.config.hovers.annotations.details)return;const a=!this.debugging&&"line"===gr.config.hovers.currentLine.over;if(!a&&gr.lineAnnotations.suspended)return;const n=e.validateRange(new b.Range(t.line,a?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!a&&n.start.character!==t.character)return;let h=void 0!==s?s.logCommit:void 0;if(void 0!==h||o.isUncommitted||void 0!==(h=await gr.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(h.previousSha=o.previousSha,h.previousFileName=o.previousFileName,void 0!==s&&(s.logCommit=h)),void 0===await gr.tracker.get(e))return;const c=Uo.getHoverMessage(h||o,gr.config.defaultDateFormat,await gr.git.getRemotes(o.repoPath),r,t.line);return new b.Hover(c,n)}async provideChangesHover(e,t,i){if(!gr.lineTracker.includes(t.line))return;const s=gr.lineTracker.getState(t.line),o=void 0!==s?s.commit:void 0;if(void 0===o)return;if(gr.config.hovers.annotations.changes&&void 0!==await gr.fileAnnotations.getAnnotationType(b.window.activeTextEditor))return;const r=!this.debugging&&"line"===gr.config.hovers.currentLine.over;if(!r&&gr.lineAnnotations.suspended)return;const a=e.validateRange(new b.Range(t.line,r?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!r&&a.start.character!==t.character)return;const n=await gr.tracker.get(e);if(void 0===n)return;const h=await Uo.changesHover(o,t.line,n.uri);return void 0!==h.hoverMessage?new b.Hover(h.hoverMessage,a):void 0}register(e){if(this.unregister(),void 0===e)return;const t=gr.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(b.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(b.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=b.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}class Jo extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new b.EventEmitter,this._onDidChangeTreeData=new b.EventEmitter,gr.explorerCommands,b.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),b.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(c.Auto),this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(c.List),this),b.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(c.Tree),this),b.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(gr.config.gitExplorer.autoRefresh,!0),this),b.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(gr.config.gitExplorer.autoRefresh,!1),this),b.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>Jo.setRenameFollowing(!0),this),b.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>Jo.setRenameFollowing(!1),this),b.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(d.History),this),b.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(d.Repository),this),b.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),gr.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleEditorsChanged,500),this),vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=vr.initializing(e);if(!(t||vr.changed(e,vr.name("gitExplorer").value)||vr.changed(e,vr.name("explorers").value)||vr.changed(e,vr.name("defaultGravatarsStyle").value)||vr.changed(e,vr.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||vr.changed(e,vr.name("gitExplorer")("enabled").value)||vr.changed(e,vr.name("gitExplorer")("location").value))&&V(W.GitExplorer,!!this.config.enabled&&this.config.location),(t||vr.changed(e,vr.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(gr.config.gitExplorer.autoRefresh);let i=this.view;if((t||vr.changed(e,vr.name("gitExplorer")("view").value))&&(i=this.config.view)===d.Auto&&(i=gr.context.workspaceState.get(q.GitExplorerView,d.Repository)),t&&(this.view=i,V(W.GitExplorerView,this.view),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),t||vr.changed(e,vr.name("gitExplorer")("location").value))return this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.gitExplorer:${this.config.location}`,{treeDataProvider:this}),void(this._disposable=this._tree);this.reset(i,vr.changed(e,vr.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==d.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Gt.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===d.Repository&&(this.clearRoot(),Cr.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(Gt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===d.History&&(0!==e.length&&e.some(e=>e.document&&gr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Gt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&gr.context.workspaceState.get(q.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},gr.config.explorers,gr.config.gitExplorer)}get view(){return this._view}set view(e){this._view=gr.config.historyExplorer.enabled?d.Repository:e}getParent(e){}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this.view===d.History?[new qt(`No active file ${G.Dash} no history to show`)]:[new qt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Gt.Command),Cr.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===d.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),void 0!==this._root&&this._root.refresh(),this._onDidChangeTreeData.fire()}refreshNode(e,t){Cr.log(`GitExplorer[view=${this.view}].refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){if(this.setView(e),t&&void 0!==this._root&&this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))||t)return this.refresh(Gt.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=gr.context.workspaceState.get(q.GitExplorerAutoRefresh,!0):(i=t,await gr.context.workspaceState.update(q.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=gr.git.onDidChangeRepositories(this.onRepositoriesChanged,this),gr.context.subscriptions.push(this._autoRefreshDisposable))),V(W.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Gt.AutoRefreshChanged)}setView(e){this.view!==e&&(gr.config.gitExplorer.view===d.Auto&&gr.context.workspaceState.update(q.GitExplorerView,e),this.view=e,V(W.GitExplorerView,this.view),e!==d.Repository&&gr.git.stopWatchingFileSystem())}async show(e){if(void 0===this._root||void 0===this._tree)return;await this.switchTo(e);const[t]=await this._root.getChildren();try{await this._tree.reveal(t,{select:!1})}catch(e){Cr.error(e)}}async switchTo(e){return this.view!==e&&(await this.reset(e,!0),!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case d.History:{const t=this.getHistoryNode(e||b.window.activeTextEditor);return this._loading=t.then(e=>k.wait(0)),t}default:{const e=gr.git.getRepositories();this._loading=e.then(e=>k.wait(0));const t=[...await e];if(0===t.length)return;const i=t.filter(e=>!e.closed);if(0===i.length)return;if(1===i.length){const e=i[0];return new fi(Te.fromRepoPath(e.path),e,this,!0)}return new _i(i,this)}}}async getHistoryNode(e){return Jo.getHistoryNode(this,e,this._root)}async setFilesLayout(e){return vr.update(vr.name("gitExplorer")("files")("layout").value,e,b.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}async undockHistory(e=!0){gr.historyExplorer.undock(e)}static async getHistoryNode(e,t,i){if(null==t||0===b.window.visibleTextEditors.length||!b.window.visibleTextEditors.some(e=>e.document&&gr.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!gr.git.isTrackable(t.document.uri))return i;const s=await Te.fromUri(t.document.uri),o=await gr.git.getRepository(s);return void 0!==o?J.equals(s,i&&i.uri)?i:new Si(s,o,e):void 0}static setRenameFollowing(e){vr.updateEffective(vr.name("advanced")("fileHistoryFollowsRenames").value,e)}}class er extends b.Disposable{constructor(){super(()=>this.dispose()),b.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),b.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),b.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),b.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),b.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),b.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),b.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),b.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),b.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),b.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),b.commands.registerCommand("gitlens.explorers.closeRepository",this.closeRepository,this),b.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),b.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),b.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),b.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),b.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),b.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),b.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),b.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),b.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),b.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),b.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),b.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),b.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),b.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),b.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),b.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),b.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await gr.git.checkoutFile(e.uri),this.openFile(e)}closeRepository(e){(e instanceof fi||e instanceof ci)&&(e.repo.closed=!0)}compareWithHead(e){e instanceof zt&&gr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&gr.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof zt&&gr.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await gr.git.getBranch(e.repoPath);if(void 0===t)return;const i=await gr.git.getMergeBase(e.repoPath,t.name,e.ref);void 0!==i&&gr.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${Qt.shortenSha(i)})`},"")}compareWithSelected(e){void 0!==this._selection&&e instanceof zt&&this._selection.repoPath===e.repoPath&&gr.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof zt))return;const t=e instanceof ii?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},V(W.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,b.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return b.commands.executeCommand(gs.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return ks(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return ks(t.uri||("D"===e.commit.status?Te.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Te.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Te.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Qt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=w.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Te.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=w.filterMap(e.commit.fileStatuses,e=>Te.fromFileStatus(e,i));for(const e of s)await ks(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=w.filterMap(e.commit.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await ks(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return b.commands.executeCommand(gs.DiffWith,o)}async openFileRevisionInRemote(e){return b.commands.executeCommand(gs.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof ii&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof zt))return;let t=!1,i=void 0;e instanceof ii&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await b.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==s&&""!==s&&this.sendTerminalCommand("branch",`${t?"-t ":""}${s} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof ii&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.getRemote()} :${e.branch.getName()}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof ii&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof ii&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof ii){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof hi&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof ii&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof ti&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof ti))return;const t=e.branch||await gr.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof ti&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof ti&&this.sendTerminalCommand("reset",`--soft ${e.ref}`,e.repoPath)}terminalRevertCommit(e){e instanceof ti&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof oi&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof zt))return;const t=await b.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await b.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",s,e.repoPath)}terminalDeleteTag(e){e instanceof gi&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=b.window.createTerminal(I),this._disposable=b.window.onDidCloseTerminal(e=>{e.name===I&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),gr.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class tr{async provideTextDocumentContent(e,t){const i=Te.fromRevisionUri(e);if(!i.repoPath||i.sha===Qt.deletedSha)return"";try{return await gr.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return Cr.error(e,"GitContentProvider","getVersionedFileText"),void b.window.showErrorMessage(`Unable to show Git revision ${Qt.shortenSha(i.sha)} of '${$e.relative(i.repoPath,i.fsPath)}'`)}}}tr.scheme=H.GitLensGit;class ir extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLines=new b.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||K(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!K(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return ir.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=b.Disposable.from(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveTextEditorChanged,0),this),b.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(b.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=k.debounce(e=>{b.window.activeTextEditor===e.editor&&ir.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{b.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&t.length===e.length&&t.every((t,i)=>t===e[i])}}class sr{constructor(e,t){this.commit=e,this.logCommit=t}}class or extends ir{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=gr.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}async resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}async suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}isSubscribed(e){return this._subscriptions.has(e)}start(e,t){this.isSubscribed(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=b.Disposable.from(this._disposable,gr.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),gr.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),gr.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await gr.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await gr.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await gr.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new sr(s.commit))}else{const s=t.document.isDirty?await gr.git.getBlameForFileContents(i.uri,t.document.getText()):await gr.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new sr(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e)||(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),0))}}class rr extends b.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class ar extends b.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class nr{async provideCodeLenses(e,t){const i=Te.fromRevisionUri(e.uri),s=[],o=await gr.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new ar(o.previousUri.fsPath,o,new b.Range(0,0,0,1))),s.push(new rr(o.uri.fsPath,o,new b.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof rr?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof ar?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:gs.DiffWithWorking,arguments:[b.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:gs.DiffWithPrevious,arguments:[b.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}nr.selector={scheme:H.GitLensGit};class hr extends b.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new b.EventEmitter,gr.explorerCommands,b.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),b.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),b.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),b.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>Jo.setRenameFollowing(!0),this),b.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>Jo.setRenameFollowing(!1),this),gr.context.subscriptions.push(b.window.onDidChangeActiveTextEditor(k.debounce(this.onActiveEditorChanged,500),this),b.window.onDidChangeVisibleTextEditors(k.debounce(this.onVisibleEditorsChanged,500),this),vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=vr.initializing(e);(t||vr.changed(e,vr.name("historyExplorer").value)||vr.changed(e,vr.name("explorers").value)||vr.changed(e,vr.name("defaultGravatarsStyle").value)||vr.changed(e,vr.name("advanced")("fileHistoryFollowsRenames").value))&&((t||vr.changed(e,vr.name("historyExplorer")("enabled").value)||vr.changed(e,vr.name("historyExplorer")("location").value))&&V(W.HistoryExplorer,!!this.config.enabled&&this.config.location),(t||vr.changed(e,vr.name("historyExplorer")("enabled").value))&&(this.config.enabled?this.undock(!t,!vr.changed(e,vr.name("mode").value)):this.dock(!t,!vr.changed(e,vr.name("mode").value))),t&&this.setRoot(await this.getRootNode(b.window.activeTextEditor)),(t||vr.changed(e,vr.name("historyExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.historyExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||void 0!==this._root||this.refresh(Gt.ConfigurationChanged))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Gt.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&gr.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Gt.VisibleEditorsChanged)))}get config(){return Object.assign({},gr.config.explorers,gr.config.historyExplorer)}getParent(e){}async getChildren(e){return void 0===this._root?[new qt(`No active file ${G.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0,t=!0){e&&await gr.gitExplorer.switchTo(d.History),await V(W.HistoryExplorer,!1),t&&await vr.updateEffective(vr.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Gt.Command),Cr.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(b.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){Cr.log(`HistoryExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async show(){if(void 0!==this._root&&void 0!==this._tree)try{await this._tree.reveal(this._root,{select:!1})}catch(e){Cr.error(e)}}async undock(e=!0,t=!0){e&&await gr.gitExplorer.switchTo(d.Repository),await V(W.HistoryExplorer,this.config.location),t&&await vr.updateEffective(vr.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){return Jo.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}}class cr extends b.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new b.EventEmitter,this._enabled=!1,gr.explorerCommands,b.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),b.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(c.Auto),this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(c.List),this),b.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(c.Tree),this),b.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),b.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),b.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),b.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),b.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),V(W.ResultsExplorerKeepResults,this.keepResults),gr.context.subscriptions.push(vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=vr.initializing(e);(t||vr.changed(e,vr.name("resultsExplorer").value)||vr.changed(e,vr.name("explorers").value)||vr.changed(e,vr.name("defaultGravatarsStyle").value))&&((t||vr.changed(e,vr.name("resultsExplorer")("location").value))&&V(W.ResultsExplorer,!!this.enabled&&this.config.location),(t||vr.changed(e,vr.name("resultsExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new b.EventEmitter),this._tree=b.window.createTreeView(`gitlens.resultsExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||0===this._roots.length||this.refresh(Gt.ConfigurationChanged))}get config(){return Object.assign({},gr.config.explorers,gr.config.resultsExplorer)}get enabled(){return this._enabled}get keepResults(){return gr.context.workspaceState.get(q.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),this._enabled=!1,V(W.ResultsExplorer,!1)}getParent(e){}async getChildren(e){return 0===this._roots.length?[new qt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Gt.Command),Cr.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){Cr.log(`ResultsExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){Cr.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}async show(){if(void 0!==this._roots&&0!==this._roots.length&&void 0!==this._tree)try{await this._tree.reveal(this._roots[0],{select:!1})}catch(e){Cr.error(e)}}showComparisonInResults(e,t,i){this.showResults(this.addResults(new xi(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)))}showCommitInResults(e){this.showResults(this.addResults(new wi(e,this)))}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.showResults(this.addResults(new bi(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,r=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let a="";if(await gr.git.getRepositoryCount()>1){const t=await gr.git.getRepository(e.repoPath);a=` ${B.pad(G.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${r.singular} for ${t.label}${a}`:`${0===s?"No":`${s}${o?"+":""}`} ${r.plural} for ${t.label}${a}`},k.seeded(i,e),this,jt.SearchResults)))}async showResults(e){this._enabled=!0,await V(W.ResultsExplorer,this.config.location),setTimeout(()=>this._tree.reveal(e,{select:!0}),250)}addResults(e){return this._roots.includes(e)?e:(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),e)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return vr.update(vr.name("resultsExplorer")("files")("layout").value,e,b.ConfigurationTarget.Global)}setKeepResults(e){gr.context.workspaceState.update(q.ResultsExplorerKeepResults,e),V(W.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof xi&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class lr extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this),...this.registerCommands())}dispose(){this._disposable&&this._disposable.dispose(),this._disposablePanel&&this._disposablePanel.dispose()}onConfigurationChanged(e){this.postUpdatedConfiguration()}onPanelDisposed(){this._disposablePanel&&this._disposablePanel.dispose(),this._panel=void 0}onViewStateChanged(e){if(Cr.log("WebviewEditor.onViewStateChanged",e.webviewPanel.visible),this._invalidateOnVisible&&e.webviewPanel.visible){const e=this._invalidateOnVisible;switch(this._invalidateOnVisible=void 0,e){case"config":this.postUpdatedConfiguration();break;default:this.show()}}}async onMessageReceived(e){if(null!=e)switch(Cr.log(`WebviewEditor.onMessageReceived: type=${e.type}, data=${JSON.stringify(e)}`),e.type){case"saveSettings":const t="workspace"===e.scope?b.ConfigurationTarget.Workspace:b.ConfigurationTarget.Global;for(const i in e.changes){const s=await vr.inspect(i),o=e.changes[i];await vr.update(i,o===s.defaultValue?void 0:o,t)}for(const i of e.removes)await vr.update(i,void 0,t)}}get visible(){return void 0!==this._panel&&this._panel.visible}hide(){void 0!==this._panel&&this._panel.dispose()}async show(){let e=(await this.getHtml()).replace(/{{root}}/g,b.Uri.file(gr.context.asAbsolutePath(".")).with({scheme:"vscode-resource"}).toString());e.includes("'{{bootstrap}}'")&&(e=e.replace("'{{bootstrap}}'",JSON.stringify(this.getBootstrap()))),void 0===this._panel?(this._panel=b.window.createWebviewPanel(this.id,this.title,b.ViewColumn.Active,{retainContextWhenHidden:!0,enableFindWidget:!0,enableCommandUris:!0,enableScripts:!0}),this._disposablePanel=b.Disposable.from(this._panel,this._panel.onDidDispose(this.onPanelDisposed,this),this._panel.onDidChangeViewState(this.onViewStateChanged,this),this._panel.webview.onDidReceiveMessage(this.onMessageReceived,this)),this._panel.webview.html=e):(this._panel.webview.html=e,this._panel.reveal(b.ViewColumn.Active))}async getHtml(){return Cr.isDebugging?new Promise((e,t)=>{xe.readFile(gr.context.asAbsolutePath(this.filename),"utf8",(i,s)=>{i?t(i):e(s)})}):(await b.workspace.openTextDocument(gr.context.asAbsolutePath(this.filename))).getText()}postMessage(e,t="all"){if(void 0===this._panel)return!1;const i=this._panel.webview.postMessage(e);return i||"all"===this._invalidateOnVisible||(this._invalidateOnVisible=t),i}postUpdatedConfiguration(){return this.postMessage({type:"settingsChanged",config:vr.get()},"config")}}class dr extends lr{constructor(){super()}get filename(){return"settings.html"}get id(){return"gitlens.settings"}get title(){return"GitLens Settings"}getBootstrap(){return{config:vr.get(),scope:"user",scopes:this.getAvailableScopes()}}registerCommands(){return[b.commands.registerCommand("gitlens.showSettingsPage",this.show,this)]}getAvailableScopes(){const e=[["user","User"]];return void 0!==b.workspace.workspaceFolders&&b.workspace.workspaceFolders.length&&e.push(["workspace","Workspace"]),e}}class ur extends b.Disposable{constructor(){super(()=>this.dispose()),this._disposable=b.Disposable.from(vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}dispose(){this.clearBlame(),this._blameStatusBarItem&&this._blameStatusBarItem.dispose(),this._modeStatusBarItem&&this._modeStatusBarItem.dispose(),gr.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=vr.initializing(e);if(t||vr.changed(e,vr.name("mode").value)){const t=gr.config.mode.active&&gr.config.mode.statusBar.enabled?gr.config.modes[gr.config.mode.active]:void 0;if(t&&t.statusBarItemName){const i="left"!==gr.config.mode.statusBar.alignment?b.StatusBarAlignment.Right:b.StatusBarAlignment.Left;vr.changed(e,vr.name("mode")("statusBar")("alignment").value)&&void 0!==this._modeStatusBarItem&&this._modeStatusBarItem.alignment!==i&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0),this._modeStatusBarItem=this._modeStatusBarItem||b.window.createStatusBarItem(i,i===b.StatusBarAlignment.Right?999:1),this._modeStatusBarItem.command=gs.SwitchMode,this._modeStatusBarItem.text=t.statusBarItemName,this._modeStatusBarItem.tooltip="Switch GitLens Mode",this._modeStatusBarItem.show()}else void 0!==this._modeStatusBarItem&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0)}if(t||vr.changed(e,vr.name("statusBar").value))if(gr.config.statusBar.enabled){const i="left"!==gr.config.statusBar.alignment?b.StatusBarAlignment.Right:b.StatusBarAlignment.Left;vr.changed(e,vr.name("statusBar")("alignment").value)&&void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.alignment!==i&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0),this._blameStatusBarItem=this._blameStatusBarItem||b.window.createStatusBarItem(i,i===b.StatusBarAlignment.Right?1e3:0),this._blameStatusBarItem.command=gr.config.statusBar.command,(t||vr.changed(e,vr.name("statusBar")("enabled").value))&&gr.lineTracker.start(this,b.Disposable.from(gr.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else vr.changed(e,vr.name("statusBar")("enabled").value)&&(gr.lineTracker.stop(this),void 0!==this._blameStatusBarItem&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0))}onActiveLinesChanged(e){let t=!(gr.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=gr.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateBlame(i.commit,e.editor);t=!0}t&&this.clearBlame()}async clearBlame(){void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.hide()}updateBlame(e,t){const i=gr.config.statusBar;if(i.enabled&&void 0!==this._blameStatusBarItem&&K(t)){switch(this._blameStatusBarItem.text=`$(git-commit) ${It.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?gr.config.defaultDateFormat:i.dateFormat})}`,i.command){case f.ToggleFileBlame:this._blameStatusBarItem.tooltip="Toggle Blame Annotations";break;case f.DiffWithPrevious:this._blameStatusBarItem.command=gs.DiffLineWithPrevious,this._blameStatusBarItem.tooltip="Compare Line Revision with Previous";break;case f.DiffWithWorking:this._blameStatusBarItem.command=gs.DiffLineWithWorking,this._blameStatusBarItem.tooltip="Compare Line Revision with Working";break;case f.ToggleCodeLens:this._blameStatusBarItem.tooltip="Toggle Git CodeLens";break;case f.ShowQuickCommitDetails:this._blameStatusBarItem.tooltip="Show Commit Details";break;case f.ShowQuickCommitFileDetails:this._blameStatusBarItem.tooltip="Show Line Commit Details";break;case f.ShowQuickFileHistory:this._blameStatusBarItem.tooltip="Show File History";break;case f.ShowQuickCurrentBranchHistory:this._blameStatusBarItem.tooltip="Show Branch History"}this._blameStatusBarItem.show()}}}class mr extends lr{constructor(){super()}get filename(){return"welcome.html"}get id(){return"gitlens.welcome"}get title(){return"Welcome to GitLens"}getBootstrap(){return{config:gr.config}}registerCommands(){return[b.commands.registerCommand("gitlens.showWelcomePage",this.show,this)]}}class gr{static initialize(e,t){if(this._context=e,this._config=gr.applyMode(t),e.subscriptions.push(this._lineTracker=new or),e.subscriptions.push(this._tracker=new Ut),e.subscriptions.push(this._git=new Qt),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new jo),e.subscriptions.push(this._lineAnnotationController=new Xo),e.subscriptions.push(this._lineHoverController=new Zo),e.subscriptions.push(this._statusBarController=new ur),e.subscriptions.push(this._codeLensController=new qo),e.subscriptions.push(this._keyboard=new Hi),e.subscriptions.push(this._settingsEditor=new dr),e.subscriptions.push(this._welcomeEditor=new mr),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new Jo);else{let t;t=vr.onDidChange(i=>{vr.changed(i,vr.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new Jo))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new hr);else{let t;t=vr.onDidChange(i=>{vr.changed(i,vr.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new hr))})}e.subscriptions.push(b.workspace.registerTextDocumentContentProvider(tr.scheme,new tr)),e.subscriptions.push(b.languages.registerCodeLensProvider(nr.selector,new nr))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=gr.applyMode(vr.get())),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new er),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new hr),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new cr),this._resultsExplorer}static get settingsEditor(){return this._settingsEditor}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static get welcomeEditor(){return this._welcomeEditor}static resetConfig(){this._config=void 0}static applyMode(e){if(!e.mode.active)return e;const t=e.modes[e.mode.active];return null==t?e:(null!=t.codeLens&&(e.codeLens.enabled=t.codeLens),null!=t.currentLine&&(e.currentLine.enabled=t.currentLine),null!=t.explorers&&(e.gitExplorer.enabled=t.explorers),null!=t.explorers&&(e.historyExplorer.enabled=t.explorers),null!=t.hovers&&(e.hovers.enabled=t.hovers),null!=t.statusBar&&(e.statusBar.enabled=t.statusBar),e)}}const pr=new Proxy({},{get:(e,t,i)=>pr});class fr{constructor(){this._onDidChange=new b.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1},this._configAffectedByMode=[`gitlens.${this.name("mode").value}`,`gitlens.${this.name("modes").value}`,`gitlens.${this.name("codeLens").value}`,`gitlens.${this.name("currentLine").value}`,`gitlens.${this.name("gitExplorer").value}`,`gitlens.${this.name("historyExplorer").value}`,`gitlens.${this.name("hovers").value}`,`gitlens.${this.name("statusBar").value}`]}static configure(e){e.subscriptions.push(b.workspace.onDidChangeConfiguration(vr.onConfigurationChanged,vr))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(L,null))return;gr.resetConfig(),vr.changed(e,vr.name("defaultGravatarsStyle").value)&&Re.clear();const t=vr.name("keymap").value;if(vr.changed(e,t)&&V(W.KeyMap,this.get(t)),vr.changed(e,vr.name("mode").value)||vr.changed(e,vr.name("modes").value)){const t=e.affectsConfiguration;e=Object.assign({},e,{affectsConfiguration:(e,i)=>!!this._configAffectedByMode.some(t=>e.startsWith(t))||t(e,i)})}this._onDidChange.fire(e)}get(e,t,i){return void 0===i?b.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e):b.workspace.getConfiguration(void 0===e?void 0:L,t).get(void 0===e?L:e,i)}changed(e,t,i){return e.affectsConfiguration(`${L}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return b.workspace.getConfiguration(void 0===e?void 0:L,t).inspect(void 0===e?L:e)}async migrate(e,t,i={}){const s=vr.inspect(e);if(void 0===s)return!1;let o=!1;return void 0!==s.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,b.ConfigurationTarget.Global),o=!0),void 0!==s.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,b.ConfigurationTarget.Workspace),o=!0),void 0!==s.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,b.ConfigurationTarget.WorkspaceFolder),o=!0),o||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,b.ConfigurationTarget.Global),o=!0),o}async migrateIfMissing(e,t,i={}){const s=vr.inspect(e);if(void 0===s)return;const o=vr.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i.migrationFn?i.migrationFn(s.globalValue):s.globalValue,b.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceValue):s.workspaceValue,b.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(s.workspaceFolderValue):s.workspaceFolderValue,b.ConfigurationTarget.WorkspaceFolder))}name(e){return k.propOf(pr,e)}update(e,t,i,s){return b.workspace.getConfiguration(L,i===b.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await vr.inspect(e,i);if(void 0!==s.workspaceFolderValue){if(s.workspaceFolderValue===t)return;await vr.update(e,t,b.ConfigurationTarget.WorkspaceFolder,i)}else if(void 0!==s.workspaceValue){if(s.workspaceValue===t)return;await vr.update(e,t,b.ConfigurationTarget.Workspace)}else{if(s.globalValue===t||void 0===s.globalValue&&s.defaultValue===t)return;await vr.update(e,t,b.ConfigurationTarget.Global)}}}const vr=new fr,wr=`[${U}]`,br=/^--inspect(-brk)?=?/;class Cr{static configure(e){e.subscriptions.push(vr.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(vr.initializingChangeEvent)}static onConfigurationChanged(e){const t=vr.initializing(e),i=vr.name("outputLevel").value;(t||vr.changed(e,i))&&(this.level=vr.get(i),this.level===p.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||b.window.createOutputChannel(U))}static log(e,...t){this.level!==p.Verbose&&this.level!==p.Debug||(Cr.isDebugging&&console.log(this.timestamp,wr,e,...t),void 0!==this.output&&this.output.appendLine((Cr.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" ")))}static error(e,t,...i){this.level!==p.Silent&&(Cr.isDebugging&&console.error(this.timestamp,wr,t,...i,e),void 0!==this.output&&this.output.appendLine((Cr.isDebugging?[this.timestamp,t,...i,e]:[t,...i,e]).join(" ")))}static warn(e,...t){this.level!==p.Silent&&(Cr.isDebugging&&console.warn(this.timestamp,wr,e,...t),void 0!==this.output&&this.output.appendLine((Cr.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" ")))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t,i){this.level===p.Debug&&(void 0===this.gitOutput&&(this.gitOutput=b.window.createOutputChannel(`${U} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})${void 0===i?"":`\n\n${i.toString()}`}`))}static get isDebugging(){if(void 0===this._isDebugging)try{const e=process.execArgv;this._isDebugging=!!e&&e.some(e=>br.test(e))}catch(e){}return this._isDebugging}}async function yr(e){const t=process.hrtime();Cr.configure(e);const i=b.extensions.getExtension(O).packageJSON.version,s=b.workspace.getConfiguration("git",null).get("enabled",!0);if(!s)return Cr.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),V(W.Enabled,s),void Os.showGitDisabledErrorMessage();fr.configure(e);const o=e.globalState.get(j.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=A.fromString(t);try{if(1!==A.compare(i,A.from(7,5,10))&&(await vr.migrate("annotations.file.gutter.gravatars",vr.name("blame")("avatars").value),await vr.migrate("annotations.file.gutter.compact",vr.name("blame")("compact").value),await vr.migrate("annotations.file.gutter.dateFormat",vr.name("blame")("dateFormat").value),await vr.migrate("annotations.file.gutter.format",vr.name("blame")("format").value),await vr.migrate("annotations.file.gutter.heatmap.enabled",vr.name("blame")("heatmap")("enabled").value),await vr.migrate("annotations.file.gutter.heatmap.location",vr.name("blame")("heatmap")("location").value),await vr.migrate("annotations.file.gutter.lineHighlight.enabled",vr.name("blame")("highlight")("enabled").value),await vr.migrate("annotations.file.gutter.lineHighlight.locations",vr.name("blame")("highlight")("locations").value),await vr.migrate("annotations.file.gutter.separateLines",vr.name("blame")("separateLines").value),await vr.migrate("codeLens.locations",vr.name("codeLens")("scopes").value),await vr.migrate("codeLens.perLanguageLocations",vr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await vr.migrate("codeLens.customLocationSymbols",vr.name("codeLens")("symbolScopes").value),await vr.migrate("annotations.line.trailing.dateFormat",vr.name("currentLine")("dateFormat").value),await vr.migrate("blame.line.enabled",vr.name("currentLine")("enabled").value),await vr.migrate("annotations.line.trailing.format",vr.name("currentLine")("format").value),await vr.migrate("annotations.file.gutter.hover.changes",vr.name("hovers")("annotations")("changes").value),await vr.migrate("annotations.file.gutter.hover.details",vr.name("hovers")("annotations")("details").value),await vr.migrate("annotations.file.gutter.hover.details",vr.name("hovers")("annotations")("enabled").value),await vr.migrate("annotations.file.gutter.hover.wholeLine",vr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await vr.migrate("annotations.line.trailing.hover.changes",vr.name("hovers")("currentLine")("changes").value),await vr.migrate("annotations.line.trailing.hover.details",vr.name("hovers")("currentLine")("details").value),await vr.migrate("blame.line.enabled",vr.name("hovers")("currentLine")("enabled").value),await vr.migrate("annotations.line.trailing.hover.wholeLine",vr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await vr.migrate("gitExplorer.gravatars",vr.name("explorers")("avatars").value),await vr.migrate("gitExplorer.commitFileFormat",vr.name("explorers")("commitFileFormat").value),await vr.migrate("gitExplorer.commitFormat",vr.name("explorers")("commitFormat").value),await vr.migrate("gitExplorer.stashFileFormat",vr.name("explorers")("stashFileFormat").value),await vr.migrate("gitExplorer.stashFormat",vr.name("explorers")("stashFormat").value),await vr.migrate("gitExplorer.statusFileFormat",vr.name("explorers")("statusFileFormat").value),await vr.migrate("recentChanges.file.lineHighlight.locations",vr.name("recentChanges")("highlight")("locations").value)),1!==A.compare(i,A.from(8,0,0,"beta2"))&&(await vr.migrate("debug",vr.name("outputLevel").value,{migrationFn:e=>e?p.Debug:vr.get(vr.name("outputLevel").value)}),await vr.migrate("debug",vr.name("debug").value,{migrationFn:e=>void 0})),1!==A.compare(i,A.from(8,0,0,"rc"))){let e=vr.name("blame")("highlight")("locations").value;await vr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=vr.name("recentChanges")("highlight")("locations").value,await vr.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==A.compare(i,A.from(8,0,0))&&(await vr.migrateIfMissing("annotations.file.gutter.gravatars",vr.name("blame")("avatars").value),await vr.migrateIfMissing("annotations.file.gutter.compact",vr.name("blame")("compact").value),await vr.migrateIfMissing("annotations.file.gutter.dateFormat",vr.name("blame")("dateFormat").value),await vr.migrateIfMissing("annotations.file.gutter.format",vr.name("blame")("format").value),await vr.migrateIfMissing("annotations.file.gutter.heatmap.enabled",vr.name("blame")("heatmap")("enabled").value),await vr.migrateIfMissing("annotations.file.gutter.heatmap.location",vr.name("blame")("heatmap")("location").value),await vr.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",vr.name("blame")("highlight")("enabled").value),await vr.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",vr.name("blame")("highlight")("locations").value),await vr.migrateIfMissing("annotations.file.gutter.separateLines",vr.name("blame")("separateLines").value),await vr.migrateIfMissing("codeLens.locations",vr.name("codeLens")("scopes").value),await vr.migrateIfMissing("codeLens.perLanguageLocations",vr.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{return e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}))}}),await vr.migrateIfMissing("codeLens.customLocationSymbols",vr.name("codeLens")("symbolScopes").value),await vr.migrateIfMissing("annotations.line.trailing.dateFormat",vr.name("currentLine")("dateFormat").value),await vr.migrateIfMissing("blame.line.enabled",vr.name("currentLine")("enabled").value),await vr.migrateIfMissing("annotations.line.trailing.format",vr.name("currentLine")("format").value),await vr.migrateIfMissing("annotations.file.gutter.hover.changes",vr.name("hovers")("annotations")("changes").value),await vr.migrateIfMissing("annotations.file.gutter.hover.details",vr.name("hovers")("annotations")("details").value),await vr.migrateIfMissing("annotations.file.gutter.hover.details",vr.name("hovers")("annotations")("enabled").value),await vr.migrateIfMissing("annotations.file.gutter.hover.wholeLine",vr.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await vr.migrateIfMissing("annotations.line.trailing.hover.changes",vr.name("hovers")("currentLine")("changes").value),await vr.migrateIfMissing("annotations.line.trailing.hover.details",vr.name("hovers")("currentLine")("details").value),await vr.migrateIfMissing("blame.line.enabled",vr.name("hovers")("currentLine")("enabled").value),await vr.migrateIfMissing("annotations.line.trailing.hover.wholeLine",vr.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await vr.migrateIfMissing("gitExplorer.gravatars",vr.name("explorers")("avatars").value),await vr.migrateIfMissing("gitExplorer.commitFileFormat",vr.name("explorers")("commitFileFormat").value),await vr.migrateIfMissing("gitExplorer.commitFormat",vr.name("explorers")("commitFormat").value),await vr.migrateIfMissing("gitExplorer.stashFileFormat",vr.name("explorers")("stashFileFormat").value),await vr.migrateIfMissing("gitExplorer.stashFormat",vr.name("explorers")("stashFormat").value),await vr.migrateIfMissing("gitExplorer.statusFileFormat",vr.name("explorers")("statusFileFormat").value),await vr.migrateIfMissing("recentChanges.file.lineHighlight.locations",vr.name("recentChanges")("highlight")("locations").value)),1!==A.compare(i,A.from(8,0,2))){const e=vr.name("keymap").value;await vr.migrate(e,e,{fallbackValue:g.Alternate,migrationFn:e=>"standard"===e?g.Alternate:e})}1!==A.compare(i,A.from(8,2,4))&&await vr.migrate("advanced.menus",vr.name("menus").value,{migrationFn:e=>({editor:{blame:!!e.editorContext.blame,clipboard:!!e.editorContext.copy,compare:!!e.editorContext.lineDiff,details:!!e.editorContext.details,history:!!e.editorContext.history,remote:!!e.editorContext.remote},editorGroup:{blame:!!e.editorTitle.blame,compare:!!e.editorTitle.fileDiff,history:!!e.editorTitle.history,remote:!!e.editorTitle.remote},editorTab:{compare:!!e.editorTitleContext.fileDiff,history:!!e.editorTitleContext.history,remote:!!e.editorTitleContext.remote},explorer:{compare:!!e.explorerContext.fileDiff,history:!!e.explorerContext.history,remote:!!e.explorerContext.remote}})})}catch(e){Cr.error(e,"migrateSettings")}}(0,o);const r=vr.get();try{let t=r.advanced.git;if(!t)try{const i=b.extensions.getExtension("vscode.git");void 0!==i&&(t=await i.exports.getGitPath())}catch(e){}await Qt.initialize(t||b.workspace.getConfiguration("git").get("path"))}catch(e){return Cr.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await b.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${L}.${vr.name("advanced")("git").value}' is pointed to its installed location.`),void V(W.Enabled,!1)}gr.initialize(e,r),V(W.KeyMap,gr.config.keymap),gr.context.subscriptions.push(new Fs),gr.context.subscriptions.push(new Ts),gr.context.subscriptions.push(new Rs),gr.context.subscriptions.push(new Es),gr.context.subscriptions.push(new Bs),gr.context.subscriptions.push(new As),gr.context.subscriptions.push(new Is),gr.context.subscriptions.push(new Ms),gr.context.subscriptions.push(new Ws),gr.context.subscriptions.push(new Hs),gr.context.subscriptions.push(new Gs),gr.context.subscriptions.push(new js),gr.context.subscriptions.push(new Vs),gr.context.subscriptions.push(new Qs),gr.context.subscriptions.push(new zs),gr.context.subscriptions.push(new qs),gr.context.subscriptions.push(new Ys),gr.context.subscriptions.push(new Xs),gr.context.subscriptions.push(new Zs),gr.context.subscriptions.push(new Js),gr.context.subscriptions.push(new eo),gr.context.subscriptions.push(new to),gr.context.subscriptions.push(new io),gr.context.subscriptions.push(new so),gr.context.subscriptions.push(new oo),gr.context.subscriptions.push(new no),gr.context.subscriptions.push(new ho),gr.context.subscriptions.push(new co),gr.context.subscriptions.push(new lo),gr.context.subscriptions.push(new uo),gr.context.subscriptions.push(new mo),gr.context.subscriptions.push(new go),gr.context.subscriptions.push(new po),gr.context.subscriptions.push(new fo),gr.context.subscriptions.push(new vo),gr.context.subscriptions.push(new wo),gr.context.subscriptions.push(new bo),gr.context.subscriptions.push(new Co),gr.context.subscriptions.push(new yo),gr.context.subscriptions.push(new xo),gr.context.subscriptions.push(new $o),gr.context.subscriptions.push(new Do),gr.context.subscriptions.push(new ko),gr.context.subscriptions.push(new Fo),gr.context.subscriptions.push(new Po),gr.context.subscriptions.push(new To),gr.context.subscriptions.push(new So),gr.context.subscriptions.push(new _o),function(e){-1===Qt.compareGitVersion("2.2.0")&&Os.showGitVersionUnsupportedErrorMessage(e)}(Qt.getGitVersion()),async function(e,t){if(void 0===t)return Cr.log("GitLens first-time install"),void(gr.config.showWhatsNewAfterUpgrades&&await b.commands.executeCommand(gs.ShowWelcomePage));if(t!==e&&(Cr.log(`GitLens upgraded from v${t} to v${e}`),0===A.compare(A.fromString(t),A.from(8,0,0))))return void await b.commands.executeCommand(gs.ShowWelcomePage);if(!gr.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,r]=t.split(".");i===o&&s===r||i<o||i===o&&s<r||await b.commands.executeCommand(gs.ShowWelcomePage)}(i,o),Os.showKeyBindingsInfoMessage(),e.globalState.update(j.GitLensVersion,i);const a=process.hrtime(t);Cr.log(`GitLens(v${i}) activated in ${1e3*a[0]+Math.floor(a[1]/1e6)} ms`)}function xr(){}Cr.level=p.Silent,i.d(t,"activate",function(){return yr}),i.d(t,"deactivate",function(){return xr})},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("clipboardy")},function(e,t){e.exports=require("tmp")}]);